### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "Skapar och kontrollerar en tråd, anger prioritet och hämtar dess status."
  remarks: "När en process startas skapar common language runtime automatiskt en enda förgrunden tråd för att köra programkod. En process kan skapa en eller flera trådar för att köra en del av den programkod som är associerade med processen tillsammans med den här huvudsakliga förgrunds-tråden. Dessa trådar kan köras i förgrunden eller i bakgrunden. Du kan dessutom använda den <xref:System.Threading.ThreadPool>klassen för att köra kod i trådar som hanteras av CLR.</xref:System.Threading.ThreadPool>       I det här avsnittet [starta en tråd](#Starting)[hämtar trådobjekt](#Retrieving)[i förgrunden och bakgrunden trådar](#Foreground)[kultur och trådar](#Culture)[och hämta information om och kontrollera trådar](#Properties)[att öppna källkoden för klassen tråd](#Source) <a name=&quot;Starting&quot;> </a> ## från en tråd starta en tråd genom att tillhandahålla en delegat som representerar tråden är i sin klasskonstruktor för att köra metoden.                                Sedan anropar den <xref:System.Threading.Thread.Start%2A>metod för att starta körningen.</xref:System.Threading.Thread.Start%2A>       Tråd-konstruktorer kan ha två delegattyper, beroende på om du kan överföra argument till metoden för att köra:-om metoden inte har något argument du skickar en <xref:System.Threading.ThreadStart>Delegera till konstruktorn.</xref:System.Threading.ThreadStart> Det har signatur: ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ``` i följande exempel skapar och startar en tråd som kör den `ExecuteInForeground` metoden.           Metoden visar information om vissa tråd egenskaper och sedan kör en loop pausar för en halv sekund och visar det förflutna antalet sekunder. Avslutar körning när tråden har körts minst fem sekunder loopen avslutas och tråden.           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -om metoden har ett argument kan du skicka en <xref:System.Threading.ParameterizedThreadStart>Delegera till konstruktorn.</xref:System.Threading.ParameterizedThreadStart>       Det har signatur: ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ``` metoden körs av delegaten kan omvandla (i C#) eller (i Visual Basic) konvertera parametern till lämplig.                     Följande exempel är identiskt med det tidigare förutom att den anropar den <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>konstruktor.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Den här versionen av den `ExecuteInForeground` metoden har en parameter som representerar det ungefärliga antalet millisekunder som slingan är att köra.           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ] det är inte nödvändigt att behålla en referens till en trådobjektet när du har startat tråden.       Fortsätter att köra tills tråd proceduren har slutförts.      <a name=&quot;Retrieving&quot;></a>## Hämtar tråd objekt du kan använda statiskhet (`Shared` i Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A>egenskapen att hämta en referens till tråden körs från den kod som körs i tråden.</xref:System.Threading.Thread.CurrentThread%2A> I följande exempel används den <xref:System.Threading.Thread.CurrentThread%2A>egenskapen för att visa information om programmets tråd, en annan tråd i förgrunden, en bakgrundstråd och en tråd pooltråd.</xref:System.Threading.Thread.CurrentThread%2A>       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> ## förgrunden och bakgrunden trådar instanser av klassen tråd representerar trådar i förgrunden eller bakgrundstrådar.         Bakgrundstrådar är identiska med förgrunden trådar med ett undantag: en bakgrundstråd inte hålla en process som körs om alla trådar i förgrunden har avslutats. När alla trådar i förgrunden har stoppats, stoppar alla bakgrundstrådar körningsmiljön och stängs av.       Som standard följande trådarna körs i förgrunden:-programmets tråd.      -Alla trådar som skapas genom att anropa en tråd klasskonstruktor.       Följande trådarna köras i bakgrunden som standard:-tråd pool trådar, som är en pool av trådar som underhålls av körningsmiljön.  Du kan konfigurera tråd pool och schema arbete på tråd pool trådar med hjälp av <xref:System.Threading.ThreadPool>klassen.</xref:System.Threading.ThreadPool>          > [!NOTE] > Uppgiftsbaserade asynkrona åtgärder kör automatiskt på tråd pool trådar. Uppgiftsbaserade asynkrona åtgärder använder den <xref:System.Threading.Tasks.Task>och <xref:System.Threading.Tasks.Task%601>klasser för att implementera den [uppgiftsbaserade asynkront mönster](~/add/includes/ajax-current-ext-md.md).</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Alla trådar som anger den hantera körningsmiljön från ohanterad kod.       Du kan ändra en tråd som ska köras i bakgrunden genom att ange den <xref:System.Threading.Thread.IsBackground%2A>egenskapen när som helst.</xref:System.Threading.Thread.IsBackground%2A>  Bakgrundstrådar är användbara för någon åtgärd fortsätter så länge som ett program körs men bör inte hindra att programmet avslutas, till exempel övervaka filändringar system eller inkommande socketanslutningar.       I följande exempel visas skillnaden mellan trådar i förgrunden och bakgrunden. Det är det första exemplet i den [starta en tråd](#Starting) avsnitt, förutom att det anger tråden som ska köras i bakgrunden innan du startar den. Som utdata visar avbryts slingan innan utförs för fem sekunder.       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> ## kultur och trådar varje tråd har en kultur som representeras av den <xref:System.Threading.Thread.CurrentCulture%2A>egenskapen och en kultur för Användargränssnittet som representeras av den <xref:System.Threading.Thread.CurrentUICulture%2A>egenskapen.</xref:System.Threading.Thread.CurrentUICulture%2A> </xref:System.Threading.Thread.CurrentCulture%2A>          Den aktuella kulturen stöder kulturen känslig åtgärder som parsning och formatering, strängjämförelse och sortering och kontrollerar även skrivning system och kalender som används av en tråd. Aktuell kultur för Användargränssnittet innehåller för kulturen känslig hämtning av resurser i Resursfiler.       När en ny tråd instansieras dess kultur och kultur för Användargränssnittet definieras av den aktuella systemkulturen och kultur för Användargränssnittet och inte av kultur och kultur för Användargränssnittet för tråden som den nya tråden skapades från. Detta innebär till exempel, som om den aktuella systemkulturen är engelska (USA) och den aktuella kulturen för primära tråden är franska (Frankrike), kultur för en ny tråd som skapats genom att anropa den <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>konstruktorn från den primära tråden är engelska (USA) och inte franska (Frankrike).</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Mer information finns i avsnittet &quot;Kultur och trådar&quot; i den <xref:System.Globalization.CultureInfo>klassen avsnittet.</xref:System.Globalization.CultureInfo>      > [!IMPORTANT] > Detta gäller inte för trådar som kör asynkrona åtgärder för appar som mål i [!INCLUDE[net_v46](~/add/includes/net-v46-md.md)] och senare i det här fallet, kultur och kultur för Användargränssnittet är en del av en asynkrona åtgärder kontexten; tråd där en asynkron åtgärd körs som standard ärver kultur och kultur för Användargränssnittet för tråden som den asynkrona åtgärden har startats. Mer information finns i avsnittet &quot;Kultur och uppgiftsbaserade asynkrona åtgärder&quot; i den <xref:System.Globalization.CultureInfo>klassen avsnittet.</xref:System.Globalization.CultureInfo>       Du kan göra något av följande för att se till att alla trådar körs i ett program delar samma kultur och kultur för Användargränssnittet:-du kan skicka en <xref:System.Globalization.CultureInfo>objekt som representerar den kulturen så att den <xref:System.Threading.ParameterizedThreadStart>Delegera eller <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>metod.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> </xref:System.Threading.ParameterizedThreadStart> </xref:System.Globalization.CultureInfo>      -För appar som körs på den [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] och senare versioner kan du definiera kultur och kultur för Användargränssnittet som ska tilldelas alla trådar som skapats i en tillämpningsdomän genom att ange värdet för den <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>och <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>Egenskaper.</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> </xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> Observera att detta är en inställning per programdomän.       Mer information och exempel finns i avsnittet &quot;Kultur och trådar&quot; för den <xref:System.Globalization.CultureInfo>klassen avsnittet.</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a>## Du kan hämta ett antal egenskapsvärden som innehåller information om en tråd få information om och styra trådar. I vissa fall kan ange du också egenskapsvärdena kontroll för tråden. Egenskaperna tråd innehåller:-namnet. <xref:System.Threading.Thread.Name%2A>är en skrivning-när egenskapen som du kan använda för att identifiera en tråd.</xref:System.Threading.Thread.Name%2A>  Standardvärdet är `null`.      -En Hashkod som du kan hämta genom att anropa den <xref:System.Threading.Thread.GetHashCode%2A>metoden.</xref:System.Threading.Thread.GetHashCode%2A> Hash-koden kan användas för att unikt identifiera en tråd. dess hash-kod kommer inte krockar med värdet från tråden, oavsett den domän där du hämtar värdet för livslängden för en tråd.      -En tråd-ID. Värdet för den skrivskyddade <xref:System.Threading.Thread.ManagedThreadId%2A>egenskapen tilldelas av körningen och som unikt identifierar en tråd i dess process.</xref:System.Threading.Thread.ManagedThreadId%2A>          > [!NOTE] > En operativsystemet [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) har ingen fast koppling till en hanterad tråd eftersom en ohanterad värd kan styra relationen mellan hanterade och ohanterade trådar. Mer specifikt en avancerad värd kan använda den [CLR värd API](https://msdn.microsoft.com/library/ms404385.aspx) att schemalägga många trådar mot operativsystemet samma tråd som hanterade eller för att flytta en hanterad tråd mellan olika operativsystem trådar.      -Trådens aktuella tillstånd. Under hela sin existens, en tråd är alltid i en eller flera av de tillstånd som definieras av den <xref:System.Threading.ThreadState>egenskapen.</xref:System.Threading.ThreadState>      -En schemaläggning prioritetsnivå som definieras av den <xref:System.Threading.ThreadPriority>egenskapen.</xref:System.Threading.ThreadPriority> Även om du kan ange ett värde att begära en trådprioritet, är det inte säkert att användas av operativsystemet.      -Den skrivskyddade <xref:System.Threading.Thread.IsThreadPoolThread%2A>-egenskap som anger om en tråd är en tråd pooltråd.</xref:System.Threading.Thread.IsThreadPoolThread%2A>      - <xref:System.Threading.Thread.IsBackground%2A>Egenskap.</xref:System.Threading.Thread.IsBackground%2A> Mer information finns i [i förgrunden och bakgrunden trådar](#Foreground) avsnitt.      <a name=&quot;Source&quot;></a>## Att öppna källkoden för tråden klassen om du vill visa källkoden för .NET Framework för klassen tråden finns i [referenskälla](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96). Du kan bläddra igenom källkoden online, hämta referens för visning offline och gå igenom källor (inklusive korrigeringarna och programvaruuppdateringarna) vid felsökning. Se [instruktioner](http://referencesource.microsoft.com/)."
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initierar en ny instans av den <xref href=&quot;System.Threading.Thread&quot;> </xref> klassen som anger en delegat som gör att ett objekt som ska skickas till tråden när tråden startades."
  remarks: "En tråd börjar inte körs när den skapas. Om du vill schemalägga tråden för körning av anropa den <xref:System.Threading.Thread.Start%2A>metoden.</xref:System.Threading.Thread.Start%2A> Om du vill lägga till ett dataobjekt i tråden, använda på <xref:System.Threading.Thread.Start%28System.Object%29>metodöverlagringen.</xref:System.Threading.Thread.Start%28System.Object%29>      > [!NOTE] > Visual Basic-användare kan utelämna den <xref:System.Threading.ThreadStart>konstruktor när du skapar en tråd.</xref:System.Threading.ThreadStart> Använd den `AddressOf` operatorn när metoden, till exempel `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatiskt anropar den <xref:System.Threading.ThreadStart>konstruktor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "En delegat som representerar metoderna som anropas när denna tråd påbörjas."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initierar en ny instans av den <xref href=&quot;System.Threading.Thread&quot;> </xref> klass."
  remarks: "En tråd börjar inte körs när den skapas. Om du vill schemalägga tråden för körning av anropa den <xref:System.Threading.Thread.Start%2A>metoden.</xref:System.Threading.Thread.Start%2A>      > [!NOTE] > Visual Basic-användare kan utelämna den <xref:System.Threading.ThreadStart>konstruktor när du skapar en tråd.</xref:System.Threading.ThreadStart> Använd den `AddressOf` operatorn när metoden till exempel `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatiskt anropar den <xref:System.Threading.ThreadStart>konstruktor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "En <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegat som representerar metoderna som anropas när denna tråd påbörjas."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initierar en ny instans av den <xref href=&quot;System.Threading.Thread&quot;> </xref> klass, anger ett ombud som gör att ett objekt som ska skickas till tråden när tråden startades och anger den maximala storleken för tråden."
  remarks: "Undvik att använda den här konstruktorn överlagring. Standardstorleken för stacken som används av den <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>konstruktorn överlagring är den rekommenderade storleken för trådar.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Om en tråd har minnesproblem, är den mest troliga orsaken programmera fel, till exempel oändlig rekursion.      > [!IMPORTANT] > Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], enbart fullständigt betrodd kod kan du ange `maxStackSize` till ett värde som är större än standardstorleken stack (1 megabyte). Om ett större värde har angetts för `maxStackSize` när koden körs med partiellt förtroende `maxStackSize` ignoreras och används för stacken standardstorleken. Inget undantag genereras. Kod på någon förtroendenivån kan du ange `maxStackSize` till ett värde som är mindre än standardstorleken för stacken.      > [!NOTE] > Om du utvecklar ett fullständigt betrodd bibliotek som ska användas av delvis betrodd kod och måste du starta en tråd som kräver en stor stack, måste du assert fullständigt förtroende innan du skapar tråden eller stacken standardstorleken kommer att användas. Gör inte detta om inte helt styra den kod som körs på tråden.       Om `maxStackSize` är mindre än den minsta storleken, används den minsta storleken. Om `maxStackSize` är inte en multipel av storleken på sidan den avrundas till nästa större multipel av storleken på sidan. Till exempel om du använder .NET Framework version 2.0 i Windows Vista, 256KB (262 144 byte) är den minsta storleken och sidstorleken är 64KB (65 536 byte).      > [!NOTE] > På versioner av Microsoft Windows innan Windows XP och Windows Server 2003, `maxStackSize` ignoreras och stackstorleken som angetts i rubriken körbara används.       Om du anger en liten storlek kan behöva du inaktivera avsökning av stackspill. När stacken är mycket begränsad, kan den sökning själva orsaka stackspill. Om du vill inaktivera avsökning av stack spill, lägger du till följande i programmets konfigurationsfil.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "En <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> delegat som representerar metoderna som anropas när denna tråd påbörjas."
    - id: maxStackSize
      type: System.Int32
      description: "Maximal stack storlek i byte som ska användas av tråden, eller 0 för att använda standard maximala stackstorleken angetts i rubriken för den körbara filen.       Viktigt för delvis betrodd kod, `maxStackSize` ignoreras om den är större än standardstorleken för stacken. Inget undantag genereras."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>är mindre än noll."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initierar en ny instans av den <xref href=&quot;System.Threading.Thread&quot;> </xref> klassen som anger den maximala storleken för tråden."
  remarks: "Undvik att använda den här konstruktorn överlagring. Standardstorleken för stacken som används av den <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>konstruktorn överlagring är den rekommenderade storleken för trådar.</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> Om en tråd har minnesproblem, är den mest troliga orsaken programmera fel, till exempel oändlig rekursion.      > [!IMPORTANT] > Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], enbart fullständigt betrodd kod kan du ange `maxStackSize` till ett värde som är större än standardstorleken stack (1 megabyte). Om ett större värde har angetts för `maxStackSize` när koden körs med partiellt förtroende `maxStackSize` ignoreras och används för stacken standardstorleken. Inget undantag genereras. Kod på någon förtroendenivån kan du ange `maxStackSize` till ett värde som är mindre än standardstorleken för stacken.      > [!NOTE] > Om du utvecklar ett fullständigt betrodd bibliotek som ska användas av delvis betrodd kod och måste du starta en tråd som kräver en stor stack, måste du assert fullständigt förtroende innan du skapar tråden eller stacken standardstorleken kommer att användas. Gör inte detta om inte helt styra den kod som körs på tråden.       Om `maxStackSize` är mindre än den minsta storleken, används den minsta storleken. Om `maxStackSize` är inte en multipel av storleken på sidan den avrundas till nästa större multipel av storleken på sidan. Till exempel om du använder .NET Framework version 2.0 i Windows Vista, 256KB (262 144 byte) är den minsta storleken och sidstorleken är 64KB (65 536 byte).      > [!NOTE] > På versioner av Microsoft Windows innan Windows XP och Windows Server 2003, `maxStackSize` ignoreras och stackstorleken som angetts i rubriken körbara används.       Om du anger en liten storlek kan behöva du inaktivera avsökning av stackspill. När stacken är mycket begränsad, kan den sökning själva orsaka stackspill. Om du vill inaktivera avsökning av stack spill, lägger du till följande i programmets konfigurationsfil.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "En <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegat som representerar metoderna som anropas när denna tråd påbörjas."
    - id: maxStackSize
      type: System.Int32
      description: "Maximal stack storlek i byte som ska användas av tråden, eller 0 för att använda standard maximala stackstorleken angetts i rubriken för den körbara filen.       Viktigt för delvis betrodd kod, `maxStackSize` ignoreras om den är större än standardstorleken för stacken. Inget undantag genereras."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>är mindre än noll."
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Genererar en <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> i tråden som metoden anropas, om du vill påbörja avslutar tråden. Den här metoden anropas vanligtvis avbryter tråden."
  remarks: "När den här metoden anropas på en tråd utlöser systemet en <xref:System.Threading.ThreadAbortException>i tråden att avbryta det.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`ett undantag som kan fångas upp av programkod, men är nytt utlöses i slutet av den `catch` blockera om <xref:System.Threading.Thread.ResetAbort%2A>kallas.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Avbryter begäran om att avbryta, och förhindrar att den `ThreadAbortException` avbryter tråden. Ångra `finally` block körs innan Tråden avbröts.      > [!NOTE] > När en tråd anropar `Abort` på själva effekten liknar genererar ett undantag, den <xref:System.Threading.ThreadAbortException>sker omedelbart, och resultatet är förutsägbara.</xref:System.Threading.ThreadAbortException> Men om en tråd anropar `Abort` på en annan tråd avbrottet avbryter oavsett koden körs. Det finns också en risk att en statisk konstruktor kan avbrytas. I sällsynta fall kan detta förhindra instanser av klassen skapas i den domänen. I .NET Framework-versioner 1.0- och 1.1 ökar risken för tråden kan avbryta när en `finally` block körs då den `finally` block har avbrutits.       Tråden är inte säkert att avbryta direkt eller alls. Den här situationen kan inträffa om en tråd har ett obegränsat antal beräkningar i den `finally` block som kallas som en del av proceduren avbrott, vilket på obestämd tid fördröja avbrottet. Om du vill vänta tills en tråd har avbrutits, kan du anropa den <xref:System.Threading.Thread.Join%2A>metoden tråd när du anropar Abort-metoden, men det är inte säkert väntetiden avslutas.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > Tråden som anropar Avbryt kan blockera om tråden som är avbryts är i ett skyddat område i koden, som en `catch` block `finally` block eller begränsat körningsområde. Om tråden som anropar Avbryt har ett lås som den avbrutna tråden kräver, kan det uppstå ett dödläge.       Om `Abort` anropas på en tråd som inte har startats tråden avbryts när <xref:System.Threading.Thread.Start%2A>anropas.</xref:System.Threading.Thread.Start%2A> Om `Abort` anropas på en tråd som är blockerad eller är i viloläge tråden avbryts och sedan avbryts.       Om `Abort` anropas på en tråd som har pausats kan en <xref:System.Threading.ThreadStateException>genereras i tråden som kallas <xref:System.Threading.Thread.Abort%2A>, och <xref:System.Threading.ThreadState>läggs till i <xref:System.Threading.Thread.ThreadState%2A>-egenskapen för tråden som avslutades.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> En <xref:System.Threading.ThreadAbortException>inte genereras i avbrutna tråden tills <xref:System.Threading.Thread.Resume%2A>kallas.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Om `Abort` anropas på en hanterad tråd medan det körs ohanterad kod en `ThreadAbortException` genereras inte förrän tråden returnerar till förvaltad kod.       Om två anrop till `Abort` kommer samtidigt, är det möjligt för ett anrop för att ange tillståndsinformationen och andra anropet för att köra den `Abort`. Ett program kan emellertid identifiera denna situation.       Efter `Abort` anropas på en tråd Trådens tillstånd inkluderar <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> När tråden har avslutats på grund av en lyckade anrop till `Abort`, Trådens tillstånd ändras till <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Med tillräcklig behörighet, en tråd som är mål för en `Abort` kan avbryta Avbryt med hjälp av den `ResetAbort` metoden. Ett exempel som visar anropar den `ResetAbort` -metoden finns i `ThreadAbortException` klass."
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden är avbryts är tillfälligt avbruten."
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Genererar en <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> i tråden som metoden anropas, om du vill påbörja avslutar tråden samtidigt som undantagsinformation om tråden avbröts. Den här metoden anropas vanligtvis avbryter tråden."
  remarks: "När den här metoden anropas på en tråd utlöser systemet en <xref:System.Threading.ThreadAbortException>i tråden att avbryta det.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`ett undantag som kan fångas upp av programkod, men är nytt utlöses i slutet av den `catch` blockera om <xref:System.Threading.Thread.ResetAbort%2A>kallas.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Avbryter begäran om att avbryta, och förhindrar att den `ThreadAbortException` avbryter tråden. Ångra `finally` block körs innan Tråden avbröts.      > [!NOTE] > När en tråd anropar `Abort` på själva effekten liknar genererar ett undantag, den <xref:System.Threading.ThreadAbortException>sker omedelbart, och resultatet är förutsägbara.</xref:System.Threading.ThreadAbortException> Men om en tråd anropar `Abort` på en annan tråd avbrottet avbryter oavsett koden körs. Det finns en risk att en statisk konstruktor kan avbrytas. I sällsynta fall kan detta förhindra instanser av klassen skapas i den domänen. I .NET Framework-versioner 1.0- och 1.1 ökar risken för tråden kan avbryta när en `finally` block körs då den `finally` block har avbrutits.       Tråden är inte säkert att avbryta direkt eller alls. Den här situationen kan inträffa om en tråd har ett obegränsat antal beräkningar i den `finally` block som kallas som en del av proceduren avbrott, vilket på obestämd tid fördröja avbrottet. Om du vill vänta tills en tråd har avbrutits, kan du anropa den <xref:System.Threading.Thread.Join%2A>metoden tråd när du anropar Abort-metoden, men det finns ingen garanti för att vänta avslutas.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > Tråden som anropar <xref:System.Threading.Thread.Abort%2A>kan blockera om tråden som är avbryts är i ett skyddat område i koden, som en `catch` block `finally` block eller begränsat körningsområde.</xref:System.Threading.Thread.Abort%2A> Om tråden som anropar <xref:System.Threading.Thread.Abort%2A>har ett lås som krävs för den avbrutna tråden, kan uppstå ett dödläge.</xref:System.Threading.Thread.Abort%2A>       Om `Abort` anropas på en tråd som inte har startats tråden avbryts när <xref:System.Threading.Thread.Start%2A>anropas.</xref:System.Threading.Thread.Start%2A> Om `Abort` anropas på en tråd som är blockerad eller är i viloläge tråden avbryts och sedan avbryts.       Om `Abort` anropas på en tråd som har pausats kan en <xref:System.Threading.ThreadStateException>genereras i tråden som kallas <xref:System.Threading.Thread.Abort%2A>, och <xref:System.Threading.ThreadState>läggs till i <xref:System.Threading.Thread.ThreadState%2A>-egenskapen för tråden som avslutades.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> En <xref:System.Threading.ThreadAbortException>inte genereras i avbrutna tråden tills <xref:System.Threading.Thread.Resume%2A>kallas.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Om `Abort` anropas på en hanterad tråd medan det körs ohanterad kod en `ThreadAbortException` genereras inte förrän tråden returnerar till förvaltad kod.       Om två anrop till `Abort` kommer samtidigt, är det möjligt för ett anrop för att ange tillståndsinformationen och andra anropet för att köra den `Abort`. Ett program kan emellertid identifiera denna situation.       Efter `Abort` anropas på en tråd Trådens tillstånd inkluderar <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> När tråden har avslutats på grund av en lyckade anrop till `Abort`, Trådens tillstånd ändras till <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Med tillräcklig behörighet, en tråd som är mål för en `Abort` kan avbryta Avbryt med hjälp av den `ResetAbort` metoden. Ett exempel som visar anropar den `ResetAbort` -metoden finns i `ThreadAbortException` klass."
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "Ett objekt som innehåller programspecifik information, till exempel tillstånd, som kan användas av tråden som avslutades."
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden är avbryts är tillfälligt avbruten."
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Allokerar en namnlösa datautrymmet på alla trådar. För bättre prestanda använder fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut i stället.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut) och data kortplatser.</xref:System.ThreadStaticAttribute> Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll. Mer information om hur du använder TLS finns [tråd lokal lagring: tråden relativt statiska fält och Data fack](~/add/includes/ajax-current-ext-md.md).       Platsen är allokerat på alla trådar.       Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data. Common language runtime allokerar en matris med flera fack data store på varje process när den skapas. Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla. Data platser är unikt för varje tråd. Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "Den allokerade namngivna datautrymmet på alla trådar."
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Allokerar en namngiven datautrymmet på alla trådar. För bättre prestanda använder fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut i stället.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut) och data kortplatser.</xref:System.ThreadStaticAttribute> Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll. Mer information om hur du använder TLS finns [tråd lokal lagring: tråden relativt statiska fält och Data fack](~/add/includes/ajax-current-ext-md.md).       Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data. Common language runtime allokerar en matris med flera fack data store på varje process när den skapas. Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla. Data platser är unikt för varje tråd. Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.       Det är inte nödvändigt att använda metoden AllocateNamedDataSlot för att allokera en namngiven datautrymmet eftersom den <xref:System.Threading.Thread.GetNamedDataSlot%2A>metoden allokerar facket om den inte redan är tilldelad.</xref:System.Threading.Thread.GetNamedDataSlot%2A>      > [!NOTE] > Om metoden AllocateNamedDataSlot används den ska anropas i huvudtråden vid programstart, eftersom den genererar ett undantag om en plats med det angivna namnet har redan allokerats. Det går inte att kontrollera om en plats har redan allokerats.       Med den här metoden har allokerats måste frigöras med <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</xref:System.Threading.Thread.FreeNamedDataSlot%2A>"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "Namnet på datautrymmet allokeras."
    return:
      type: System.LocalDataStoreSlot
      description: "Den allokerade namngivna datautrymmet på alla trådar."
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "En namngiven datautrymmet med det angivna namnet finns redan."
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar eller anger inneslutningstillståndet för tråden."
  remarks: "**Egenskapen försöka är föråldrad.**  Ej föråldrade alternativen är den <xref:System.Threading.Thread.GetApartmentState%2A>metod för att hämta inneslutningstillståndet och <xref:System.Threading.Thread.SetApartmentState%2A>metod för att ställa in inneslutningstillståndet.</xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>       I .NET Framework-version 1.0 och 1.1, den `ApartmentState` egenskapen markerar en tråd för att ange att den körs i en enkeltrådad eller flertrådade inneslutning. Den här egenskapen kan anges när tråden är i den `Unstarted` eller `Running` tråd tillstånd, men den kan bara anges en gång för en tråd. Om egenskapen inte har angetts, returnerar `Unknown`.       Ett försök att använda egenskapen försöka att ställa in en tråd har redan ställts in vars inneslutningstillståndet-inneslutningstillståndet ignoreras. Men den <xref:System.Threading.Thread.SetApartmentState%2A>metoden returnerar en <xref:System.InvalidOperationException>i det här fallet.</xref:System.InvalidOperationException> </xref:System.Threading.Thread.SetApartmentState%2A>      > [!IMPORTANT] > In the .NET Framework version 2.0, nya trådar har initierats som <xref:System.Threading.ApartmentState?displayProperty=fullName>om deras inneslutningstillståndet inte har angetts innan de startas.</xref:System.Threading.ApartmentState?displayProperty=fullName> Programmets tråden har initierats till <xref:System.Threading.ApartmentState?displayProperty=fullName>som standard.</xref:System.Threading.ApartmentState?displayProperty=fullName> Du kan inte längre ange programmets tråd och <xref:System.Threading.ApartmentState?displayProperty=fullName>genom att ange den <xref:System.Threading.ApartmentState?displayProperty=fullName>egenskapen på den första raden i koden.</xref:System.Threading.ApartmentState?displayProperty=fullName> </xref:System.Threading.ApartmentState?displayProperty=fullName> Använd den <xref:System.STAThreadAttribute>i stället.</xref:System.STAThreadAttribute>       Du kan ange COM trådad modell för att använda en C++ program i .NET Framework version 2.0 av [/CLRTHREADATTRIBUTE (Ange CLR-tråden attribut)](~/add/includes/ajax-current-ext-md.md) länkaralternativet."
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "En av de <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> värden. Det första värdet är <xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Ett försök görs att ange egenskapen till ett tillstånd som inte är en giltig inneslutningstillståndet (ett annat tillstånd än enkeltrådad inneslutning (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) eller flertrådade innesluten (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))."
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Meddelar en värd att körningen håller på att ange en region i koden där effekterna av att en tråd Avbryt eller undantag kan äventyra andra aktiviteter i programdomänen."
  remarks: "Värdar för CLR (CLR), till exempel Microsoft SQL Server 2005 kan upprätta olika principer för fel i kritiska och icke-kritiska områden i koden. En kritisk region är ett där effekterna av att en tråd Avbryt eller ett ohanterat undantag inte kanske är begränsad till den aktuella aktiviteten. Däremot påverkar ett avbrott eller fel i en icke-kritiska region i koden endast aktiviteten där felet inträffar.       Anta till exempel att en uppgift som försöker att allokera minne Håll ett lås. Om det inte går att allokera minne, avbryter den aktuella åtgärden är inte tillräcklig för stabilitet i <xref:System.AppDomain>, eftersom det kan finnas andra uppgifter i den domän som väntar på samma låset.</xref:System.AppDomain> Om den aktuella aktiviteten avslutas kan du ett dödläge andra aktiviteter.       När ett fel uppstår i en kritisk region, värden kan besluta att ta bort hela <xref:System.AppDomain>i stället för att ta risken för fortsätter körningen i ett potentiellt instabilt tillstånd.</xref:System.AppDomain> För att informera värden att koden är att ange en kritisk region, anropa BeginCriticalRegion. Anropa <xref:System.Threading.Thread.EndCriticalRegion%2A>när körningen returnerar till en icke-kritiska region i koden.</xref:System.Threading.Thread.EndCriticalRegion%2A>       Med den här metoden i kod som körs i SQL Server 2005 kräver koden som ska köras vid den högsta skyddsnivån för värden."
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Meddelar en värd som förvaltad kod håller på att köra instruktioner som är beroende av identiteten för den aktuella tråden fysiska operativsystem."
  remarks: "Vissa värdar i CLR, till exempel Microsoft SQL Server 2005, tillhandahålla sina egna tråd-hantering. En värd som tillhandahåller egna tråd hantering kan du flytta en aktivitet som körs från en fysisk operativsystemstråden till en annan när som helst. De flesta uppgifter påverkas inte av den här växlar. Dock vissa aktiviteter har trådtilldelning - som är de beroende av identiteten för en fysisk operativsystemet tråd. Dessa uppgifter måste informera värden när de kör kod som inte bör stängas.       Till exempel om programmet anropar system API för att låsa ett operativsystem som har trådtilldelning, till exempel en Win32-CRITICAL_SECTION måste du anropa BeginThreadAffinity innan låshämtning, och <xref:System.Threading.Thread.EndThreadAffinity%2A>efter bort låset.</xref:System.Threading.Thread.EndThreadAffinity%2A>       Med den här metoden i kod som körs i SQL Server 2005 kräver koden som ska köras vid den högsta skyddsnivån för värden."
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar den aktuella kontexten där tråden körs."
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "En <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref> som representerar den aktuella tråd-kontexten."
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar eller anger kulturen för den aktuella tråden."
  remarks: "Den <xref:System.Globalization.CultureInfo>objekt som returneras av den här egenskapen tillsammans med alla associerade objekt avgöra standardformatet för datum, tider, siffror, valuta, sorteringsordning för text, versaler och gemener konventioner, och de jämförelser.</xref:System.Globalization.CultureInfo> Finns det <xref:System.Globalization.CultureInfo>klassen om du vill lära kultur namn och identifierare, skillnaderna mellan invariant neutral och specifika kulturer och hur kultur informationen påverkar trådar och programdomäner.</xref:System.Globalization.CultureInfo> Finns det <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>egenskapen vill lära dig hur en tråd standardkulturen bestäms och hur användare ange information om kultur för sina datorer.</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>       Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], kan du ange egenskapen CurrentCulture till en neutral kultur. Detta beror på att beteendet för den <xref:System.Globalization.CultureInfo>klass har ändrats: när den representerar en neutral kultur egenskapsvärdena (särskilt den <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, och <xref:System.Globalization.CultureInfo.TextInfo%2A>Egenskaper) nu återspeglar specifik kultur som är associerad med neutral kultur.</xref:System.Globalization.CultureInfo.TextInfo%2A> </xref:System.Globalization.CultureInfo.NumberFormat%2A> </xref:System.Globalization.CultureInfo.DateTimeFormat%2A> </xref:System.Globalization.CultureInfo.CompareInfo%2A> </xref:System.Globalization.CultureInfo.Calendar%2A> </xref:System.Globalization.CultureInfo> I tidigare versioner av .NET Framework egenskapen CurrentCulture utlöste ett <xref:System.NotSupportedException>undantag när en neutral kultur tilldelades.</xref:System.NotSupportedException>"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Ett objekt som representerar kultur för den aktuella tråden."
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egenskapen anges till <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar eller anger trådens aktuella huvudnamn (för rollbaserad säkerhet)."
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "En <xref:System.Security.Principal.IPrincipal>-värde som representerar säkerhetskontexten.</xref:System.Security.Principal.IPrincipal>"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte den behörighet som krävs för att ange huvudnamn."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar tråden som för närvarande körs."
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "En <xref href=&quot;System.Threading.Thread&quot;> </xref> som är en representation av tråden som för närvarande körs."
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar eller anger den aktuella kulturen som används av Resource Manager för att leta upp kultur-specifika resurser vid körning."
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Ett objekt som representerar den aktuella kulturen."
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Egenskapen anges till <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Egenskapen anges till ett kulturnamn som inte kan användas för att hitta en resursfil. Resursfilnamn måste innehålla endast bokstäver, siffror, bindestreck och understreck."
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Stänger av automatisk rensning av körningsmiljön callable omslutningar (RCW) för den aktuella tråden."
  remarks: "Som standard rensar common language runtime (CLR) runtime callable omslutningar automatiskt. CLR pumpar meddelanden under rensning, vilket kan orsaka problem återinträde för några program som uppfyller följande kriterier för ovanliga:-programmet har ett eget meddelande pumpa.      -Programmet måste kontrollera exakt när meddelandet pumpa inträffar.       Sådana program kan använda metoden DisableComObjectEagerCleanup för att förhindra att CLR automatisk makulering av körningsmiljön callable omslutningar.       När den här metoden har anropats på en tråd, kan inte automatisk rensning aktiveras igen för tråden. När programmet är redo att rensa runtime callable omslutningar använder den <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>metod för att instruera runtime att rensa alla runtime callable omslutningar i den aktuella kontexten.</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> Meddelandet pumpa inträffar när metoden körs."
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Meddelar en värd att körningen håller på att ange en del av kod som effekterna av att en tråd Avbryt eller undantag är begränsad till den aktuella aktiviteten."
  remarks: "Värdar för CLR (CLR), till exempel Microsoft SQL Server 2005 kan upprätta olika principer för fel i kritiska och icke-kritiska områden i koden. En kritisk region är ett där effekterna av att en tråd Avbryt eller ett ohanterat undantag inte kanske är begränsad till den aktuella aktiviteten. Däremot påverkar ett avbrott eller fel i en icke-kritiska region i koden endast aktiviteten där felet inträffar.       Anta till exempel att en uppgift som försöker att allokera minne Håll ett lås. Om det inte går att allokera minne, avbryter den aktuella åtgärden är inte tillräcklig för stabilitet i <xref:System.AppDomain>, eftersom det kan finnas andra uppgifter i den domän som väntar på samma låset.</xref:System.AppDomain> Om den aktuella aktiviteten avslutas kan du ett dödläge andra aktiviteter.       När ett fel uppstår i en kritisk region, värden kan besluta att ta bort hela <xref:System.AppDomain>i stället för att ta risken för fortsätter körningen i ett potentiellt instabilt tillstånd.</xref:System.AppDomain> För att informera värden att koden är att ange en kritisk region, anropa <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</xref:System.Threading.Thread.BeginCriticalRegion%2A> Anropa EndCriticalRegion när körningen återgår till en icke-kritiska region i koden.       Med den här metoden i kod som körs i SQL Server 2005 kräver koden som ska köras vid den högsta skyddsnivån för värden."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Meddelar en värd som förvaltad kod har avslutats instruktioner som är beroende av identiteten för den aktuella tråden fysiska operativsystem."
  remarks: "Vissa värdar i CLR, till exempel Microsoft SQL Server 2005, tillhandahålla sina egna tråd-hantering. En värd som tillhandahåller egna tråd hantering kan du flytta en aktivitet som körs från en fysisk operativsystemstråden till en annan när som helst. De flesta uppgifter påverkas inte av den här växlar. Dock vissa aktiviteter har trådtilldelning - som är de beroende av identiteten för en fysisk operativsystemet tråd. Dessa uppgifter måste informera värden när de kör kod som inte bör stängas.       Om exempelvis låsa dina program anrop en system-API att erhålla ett operativsystem som har trådtilldelning, till exempel en Win32-CRITICAL_SECTION måste du anropa <xref:System.Threading.Thread.BeginThreadAffinity%2A>innan införskaffa lock och EndThreadAffinity efter bort låset.</xref:System.Threading.Thread.BeginThreadAffinity%2A>       Med den här metoden i kod som körs i SQL Server 2005 kräver koden som ska köras vid den högsta skyddsnivån för värden."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar en <xref:System.Threading.ExecutionContext>objekt som innehåller information om olika kontexter för den aktuella tråden.</xref:System.Threading.ExecutionContext>"
  remarks: "Den <xref:System.Threading.ExecutionContext>klassen innehåller en enskild behållare för all information som är relevanta för en logisk tråd av körningen.</xref:System.Threading.ExecutionContext> Detta inkluderar säkerhetskontext, anrop kontext, synkroniseringskontext, lokalisering kontext och transaktionskontext."
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "En <xref:System.Threading.ExecutionContext>objekt som konsoliderar omständighetsinformation för den aktuella tråden.</xref:System.Threading.ExecutionContext>"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Säkerställer att frigörs resurser och andra rensningsåtgärder utförs när skräpinsamlingen återtar den <xref href=&quot;System.Threading.Thread&quot;> </xref> objekt."
  remarks: "Skräpinsamlingen anropar Finalize när det aktuella objektet är redo att slutföras."
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Tar bort associationen mellan ett namn och en plats för alla trådar i processen. För bättre prestanda använder fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut i stället.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut) och data kortplatser.</xref:System.ThreadStaticAttribute> Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll. Mer information om hur du använder TLS finns [tråd lokal lagring: tråden relativt statiska fält och Data fack](~/add/includes/ajax-current-ext-md.md).       När någon tråd anrop `FreeNamedDataSlot`, en tråd som anropar <xref:System.Threading.Thread.GetNamedDataSlot%2A>med samma namn kommer att allokera en ny plats som är associerade med namnet.</xref:System.Threading.Thread.GetNamedDataSlot%2A> Efterföljande anrop till `GetNamedDataSlot` av en tråd returneras den nya platsen. En tråd som fortfarande har dock en <xref:System.LocalDataStoreSlot?displayProperty=fullName>returnerades av ett tidigare anrop till `GetNamedDataSlot` kan fortsätta att använda den gamla platsen.</xref:System.LocalDataStoreSlot?displayProperty=fullName>       En plats som har associerats med ett namn som släpps endast när alla `LocalDataStoreSlot` som har hämtats innan anropet till `FreeNamedDataSlot` har släppts och skräpinsamlats.       Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data. Common language runtime allokerar en matris med flera fack data store på varje process när den skapas. Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla. Data platser är unikt för varje tråd. Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "Namnet på datautrymmet att frigöras."
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Returnerar en <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> värde som anger läget inneslutning."
  remarks: "Den här metoden tillsammans med den <xref:System.Threading.Thread.SetApartmentState%2A>metoden och <xref:System.Threading.Thread.TrySetApartmentState%2A>metod, ersätter den <xref:System.Threading.Thread.ApartmentState%2A>egenskapen.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A>"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "En av de <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> värden som anger inneslutningstillståndet för hanterade tråden. Standardvärdet är <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>."
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Returnerar en <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> objekt som kan användas för att avbilda stacken för den aktuella tråden."
  remarks: "Den här metoden stöds inte längre."
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "Ingen."
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "I samtliga fall."
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar värdet från den angivna platsen på den aktuella tråden i den aktuella trådens aktuella domänen. För bättre prestanda använder fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut i stället.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut) och data kortplatser.</xref:System.ThreadStaticAttribute> Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll. Mer information om hur du använder TLS finns [tråd lokal lagring: tråden relativt statiska fält och Data fack](~/add/includes/ajax-current-ext-md.md).       Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data. Common language runtime allokerar en matris med flera fack data store på varje process när den skapas. Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla. Data platser är unikt för varje tråd. Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.      > [!NOTE] > GetData är en `Shared` metod som gäller för tråden körs alltid även om du anropar den med hjälp av en variabel som refererar till en annan tråd. För att undvika förvirring använder klassnamnet vid anrop av `Shared` metoder: `Dim test As Object = Thread.GetData(testSlot)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "Den <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> som du vill hämta värdet från."
    return:
      type: System.Object
      description: "Det hämtade värdet."
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Returnerar den aktuella domänen som den aktuella tråden körs."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "En <xref href=&quot;System.AppDomain&quot;> </xref> som representerar den aktuella programdomänen för tråden körs."
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Returnerar en unik identifierare för domänen."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "En 32-bitars heltal unikt identifierar programdomänen."
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Returnerar ett hash-koden för den aktuella tråden."
  remarks: "Hash-koden är inte säkert att vara unika. Använd den <xref:System.Threading.Thread.ManagedThreadId%2A>egenskapen om du behöver en unik identifierare för en hanterad tråd.</xref:System.Threading.Thread.ManagedThreadId%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Ett hash-kod heltal."
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Slår upp en namngiven datautrymmet. För bättre prestanda använder fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut i stället.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut) och data kortplatser.</xref:System.ThreadStaticAttribute> Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll. Mer information om hur du använder TLS finns [tråd lokal lagring: tråden relativt statiska fält och Data fack](~/add/includes/ajax-current-ext-md.md).       Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data. Common language runtime allokerar en matris med flera fack data store på varje process när den skapas. Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning när tråden upphör att gälla. Data platser är unikt för varje tråd. Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.       Om den namngivna platsen inte finns, allokeras en ny plats. Namngivna data fack är offentlig och kan ändras av någon."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "Namnet på den lokala datautrymmet."
    return:
      type: System.LocalDataStoreSlot
      description: "En <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> allokerats för den här tråden."
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Avbryter en tråd som den <xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;> </xref> tråd tillstånd."
  remarks: "Om den här tråden inte är blockerad i vänta, viloläge och anslutningstillståndet, avbryts den när den börjar nästa blockera.       <xref:System.Threading.ThreadInterruptedException>genereras i den avbrutna tråden, men inte förrän tråd-block.</xref:System.Threading.ThreadInterruptedException> Om tråden blockerar aldrig, den undantag aldrig och därmed tråden kan slutföras utan att någonsin avbryts."
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte rätt <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar ett värde som anger status för körningen av den aktuella tråden."
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den här tråden har startat och har inte avslutats normalt eller avbrutits; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar eller anger ett värde som anger huruvida en tråd är en bakgrundstråd."
  remarks: "En tråd är en bakgrundstråd eller en tråd i förgrunden. Bakgrundstrådar är identiska med förgrunden trådar, förutom att bakgrundstrådar inte förhindrar att en process avslutas. När alla förgrunden trådar som hör till en process har avslutats, avslutas CLR processen. Alla återstående bakgrundstrådar har stoppats och att slutföra inte.       Som standard följande trådarna körs i förgrunden (det vill säga deras IsBackground egenskapen returnerar `false`):-primära tråden (eller programmets tråd).      -Alla trådar som skapas genom att anropa en <xref:System.Threading.Thread>klasskonstruktor.</xref:System.Threading.Thread>       Som standard följande trådar som körs i bakgrunden (det vill säga deras IsBackground egenskapen returnerar `true`):-tråd pool trådar, som är en pool av trådar som underhålls av körningsmiljön. Du kan konfigurera tråd pool och schema arbete på tråd pool trådar med hjälp av <xref:System.Threading.ThreadPool>klassen.</xref:System.Threading.ThreadPool>          > [!NOTE] > Uppgiftsbaserade asynkrona åtgärder kör automatiskt på tråd pool trådar.      -Alla trådar som anger den hantera körningsmiljön från ohanterad kod."
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den här tråden är eller ska bli en bakgrundstråd; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden är död."
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar ett värde som anger huruvida en tråd som tillhör hanterade trådpoolen."
  remarks: "Mer information finns i [i hanterad tråd grupp](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den här tråden som tillhör hanterade trådpoolen; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Blockerar den anropande tråden tills den tråd som representeras av den här instansen avslutas, medan du utför vanliga COM och <xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;> </xref> pumpa."
  remarks: "Koppling är en synkroniseringsmetod som blockerar den anropande tråden (det vill säga tråden som anropar metoden) tills tråden vars koppling anropas metoden har slutförts. Använd den här metoden för att säkerställa att en tråd har avslutats. Anroparen blockeras utan tidsbegränsning om tråden inte avslutas. I följande exempel visas den `Thread1` tråden som anropar metoden Join i `Thread2`, som orsakar `Thread1` att blockera tills `Thread2` har slutförts.       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ] om tråden har redan avslutats när <xref:System.Threading.Thread.Join%2A>anropas metoden returnerar omedelbart.</xref:System.Threading.Thread.Join%2A>        > [!WARNING] > Du bör aldrig anropa metoden koppling för den <xref:System.Threading.Thread>objekt som representerar den aktuella tråden från den aktuella tråden.</xref:System.Threading.Thread> Detta gör att din app låser sig eftersom den aktuella tråden väntar på själva på obestämd tid den här metoden ändras tillståndet för den anropande tråden att inkludera <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> Du kan inte anropa `Join` på en tråd som finns i den <xref:System.Threading.ThreadState?displayProperty=fullName>tillstånd.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Anroparen försökte ansluta till en tråd som den <xref href=&quot;System.Threading.ThreadState&quot;> </xref> tillstånd."
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "Tråden avbryts väntan."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Den anropande tråden tills den tråd som representeras av den här instansen slutar eller den angivna tiden går ut medan du utför vanliga COM och SendMessage pumpa block."
  remarks: "Anslutning till är en synkroniseringsmetod som blockerar den anropande tråden (det vill säga tråden som anropar metoden) tills antingen tråden vars <xref:System.Threading.Thread.Join%2A>anropas metoden har slutförts eller timeout-intervall har förflutit.</xref:System.Threading.Thread.Join%2A> I följande exempel visas den `Thread1` tråd anrop i <xref:System.Threading.Thread.Join>metod för `Thread2`, som orsakar `Thread1` att blockera antingen tills `Thread2` har slutförts eller 2 sekunder har förflutit.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ] om <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>har angetts för den `millisecondsTimeout` parameter för den här metoden fungerar identiskt till det <xref:System.Threading.Thread.Join>metodöverlagringen förutom returvärdet.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Om tråden har redan avslutats när <xref:System.Threading.Thread.Join%2A>anropas metoden returnerar omedelbart.</xref:System.Threading.Thread.Join%2A>       Den här metoden ändrar status för den anropande tråden att inkludera <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> Du kan inte anropa `Join` på en tråd som finns i den <xref:System.Threading.ThreadState?displayProperty=fullName>tillstånd.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Antal millisekunder att vänta på att avsluta tråden."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>om tråden har avslutats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om tråden inte har avslutats efter den tid som anges av den <code> millisecondsTimeout </code> parametern har gått ut."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Värdet för <code> millisecondsTimeout </code> är negativt och är inte lika med &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; i millisekunder."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden har inte startats."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Den anropande tråden tills den tråd som representeras av den här instansen slutar eller den angivna tiden går ut medan du utför vanliga COM och SendMessage pumpa block."
  remarks: "Anslutning till är en synkroniseringsmetod som blockerar den anropande tråden (det vill säga tråden som anropar metoden) tills antingen tråden vars <xref:System.Threading.Thread.Join%2A>anropas metoden har slutförts eller timeout-intervall har förflutit.</xref:System.Threading.Thread.Join%2A> I följande exempel visas den `Thread1` tråd anrop i <xref:System.Threading.Thread.Join>metod för `Thread2`, som orsakar `Thread1` att blockera antingen tills `Thread2` har slutförts eller 2 sekunder har förflutit.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ] om <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>har angetts för `timeout`, den här metoden fungerar identiskt till det <xref:System.Threading.Thread.Join>metodöverlagringen förutom returvärdet.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Om tråden har redan avslutats när <xref:System.Threading.Thread.Join%2A>anropas metoden returnerar omedelbart.</xref:System.Threading.Thread.Join%2A>       Den här metoden ändrar status för den aktuella tråden kan inkludera <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Du kan inte anropa `Join` på en tråd som finns i den <xref:System.Threading.ThreadState?displayProperty=fullName>tillstånd.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "En <xref:System.TimeSpan>är inställda som hur lång tid att vänta på att tråden ska upphöra.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>om tråden som avslutades; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om tråden inte har avslutats efter den tid som anges av den <code> timeout </code> parametern har gått ut."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Värdet för <code> timeout </code> är negativt och är inte lika med &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; i millisekunder, eller är större än &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; millisekunder."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Anroparen försökte ansluta till en tråd som den <xref href=&quot;System.Threading.ThreadState&quot;> </xref> tillstånd."
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar en unik identifierare för den aktuella hantera tråden."
  remarks: "En tråd ManagedThreadId egenskapens värde används för att unikt identifiera tråden i dess process.       Värdet på egenskapen ManagedThreadId varierar inte över tiden, även om ohanterad kod som är värd för common language runtime implementerar tråd som ett fiber."
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "Ett heltal som representerar en unik identifierare för den här hanterade tråden."
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: 'Synkroniserar minnesåtkomst på följande sätt: processorn köra den aktuella tråden kan inte ändra ordning instruktioner i ett sådant sätt att minne kommer åt innan anropet till MemoryBarrier köra efter minne åtkomster som följer anropet till MemoryBarrier.'
  remarks: "MemoryBarrier krävs endast på datorer med flera processorer med svag minne ordning (till exempel ett system med flera processorer med Intel Itanium).       För de flesta ändamål är C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen eller <xref:System.Threading.Monitor>klassen tillhandahåller enklare sätt att synkronisera data.</xref:System.Threading.Monitor>"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar eller anger namnet på tråden."
  remarks: "Den här egenskapen är write-när. Eftersom standardvärdet för en tråd namnegenskapen är `null`, kan du bestämma om ett namn har redan uttryckligen tilldelats tråden genom att jämföra med `null`.       Strängen som tilldelats egenskapen namn kan innehålla valfritt Unicode-tecken."
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "En sträng som innehåller namnet på tråden eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om inget namn angavs."
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "En set-åtgärd begärdes men <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> egenskapen har redan angetts."
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar eller anger ett värde som anger schemaläggning prioriteten för en tråd."
  remarks: "En tråd kan tilldelas någon av följande prioritet <xref:System.Threading.ThreadPriority>värden:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest` operativsystem krävs inte för att respektera prioriteten för en tråd.</xref:System.Threading.ThreadPriority>"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "En av de <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> värden. Standardvärdet är <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>."
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden har uppnått ett sluttillstånd som <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Det angivna värdet för en set-åtgärd inte är ett giltigt <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> värde."
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Avbryter en <xref:System.Threading.Thread.Abort*>krävs för den aktuella tråden.</xref:System.Threading.Thread.Abort*>"
  remarks: "Den här metoden kan endast anropas av kod med rätt behörighet.       När ett anrop görs till `Abort` för att avsluta en tråd, genererar systemet <xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`är ett undantag som kan fångas upp av programkod men igen i slutet av catch-blocket om `ResetAbort` anropas. `ResetAbort`Avbryter begäran om att avbryta, och förhindrar att den `ThreadAbortException` avbryter tråden.       Se <xref:System.Threading.ThreadAbortException>ett exempel som visar anropar den `ResetAbort` metoden.</xref:System.Threading.ThreadAbortException>"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>anropades inte i den aktuella tråden."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörighet för den aktuella tråden."
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Återupptar en tråd som har pausats."
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden har inte startats, svarar inte eller är inte i inaktiverat tillstånd."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte rätt <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Anger en tråd-inneslutningstillståndet innan den startas."
  remarks: "Nya trådar har initierats som <xref:System.Threading.ApartmentState?displayProperty=fullName>om deras inneslutningstillståndet inte har angetts innan de startas.</xref:System.Threading.ApartmentState?displayProperty=fullName> Inneslutningstillståndet måste anges innan en tråd har startats.      > [!NOTE] > Programmets tråden har initierats till <xref:System.Threading.ApartmentState?displayProperty=fullName>som standard.</xref:System.Threading.ApartmentState?displayProperty=fullName> Det enda sättet att ange inneslutningstillståndet för programmets tråden till <xref:System.Threading.ApartmentState?displayProperty=fullName>är att använda den <xref:System.STAThreadAttribute>attribut till metoden.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       Metoden SetApartmentState tillsammans med den <xref:System.Threading.Thread.GetApartmentState%2A>metoden och <xref:System.Threading.Thread.TrySetApartmentState%2A>metod, ersätter den <xref:System.Threading.Thread.ApartmentState%2A>egenskapen.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "Läget inneslutning."
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>är inte en giltig inneslutningstillståndet."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden har redan startats."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Läget inneslutning har redan initierats."
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Tillämpar en avbildade <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> till den aktuella tråden."
  remarks: "Den här metoden stöds inte längre."
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "Den <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> objekt som ska tillämpas på den aktuella tråden."
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "I samtliga fall."
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Anger data i den angivna platsen i den pågående tråden för trådens aktuella domänen. För bättre prestanda använder fält som har markerats med den <xref:System.ThreadStaticAttribute>attribut i stället.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework innehåller två mekanismer för att använda tråd lokal lagring (TLS): tråd relativt statiska fält (det vill säga de fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut) och data kortplatser.</xref:System.ThreadStaticAttribute> Tråden relativt statiska fält mycket bättre prestanda än data kortplatser, och aktivera kompileringen typkontroll. Mer information om hur du använder TLS finns [tråd lokal lagring: tråden relativt statiska fält och Data fack](~/add/includes/ajax-current-ext-md.md).       Trådar använda ett lokalt Arkiv minne mekanism för att lagra tråd-specifika data. Common language runtime allokerar en matris med flera fack data store på varje process när den skapas. Tråden kan tilldela en plats för data i datalagret, lagra och hämta data värdet på plats och ledigt fack för återanvändning efter tråd proceduren avslutas och <xref:System.Threading.Thread>objekt har återställts vid en skräpinsamling.</xref:System.Threading.Thread> Data platser är unikt för varje tråd. Ingen annan tråd (inte ens underordnade tråd) kan hämta dessa data.      > [!NOTE] > SetData är en `Shared` metod som gäller för tråden körs alltid även om du anropar den med hjälp av en variabel som refererar till en annan tråd. För att undvika förvirring använder klassnamnet vid anrop av `Shared` metoder: `Thread.SetData(testSlot, &quot;test data&quot;)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "Den <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> att ange värdet."
    - id: data
      type: System.Object
      description: "Värdet som anges."
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Stoppar den aktuella tråden för det angivna antalet millisekunder."
  remarks: "Tråden kommer inte schemaläggas för körning av operativsystemet för den angivna tiden. Den här metoden ändrar status för tråden att inkludera <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>       Du kan ange <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>för den `millisecondsTimeout` parametern pausa tråden under obestämd tid.</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> Vi rekommenderar dock att du använder andra <xref:System.Threading?displayProperty=fullName>klasser som <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, eller <xref:System.Threading.Semaphore>i stället till sychronize trådar eller hantera resurser.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Systemets klocka tick med ett specifikt intervall kallas klockan lösning. Den faktiska tidsgränsen kanske inte exakt den angivna tidsgränsen eftersom den angivna tidsgränsen ska justeras med att klockan skalstreck. Mer information om klockan upplösning och väntetiden finns i [vila funktionen](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) avsnittet. Den här metoden anropar den [vila funktionen](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) från Windows-systemet API: er.       Den här metoden utför inte standard COM och SendMessage pumpa.      > [!NOTE] > Om du behöver vila på en tråd som har <xref:System.STAThreadAttribute>, men du vill utföra standard COM och SendMessage pumpa bör du överväga att använda någon av överlagringar av den <xref:System.Threading.Thread.Join%2A>metod som anger ett timeout-intervall.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Antalet millisekunder som tråden har pausats. Om värdet för den `millisecondsTimeout` argumentet är noll, tråden avsäger resten av dess tidsintervallet till varje tråd i samma prioritet som är redo att köras. Om det finns ingen annan tråd i samma prioritet som är redo att köras, körningen av den aktuella tråden inte har inaktiverats."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Timeout-värdet är negativt och är inte lika med <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Stoppar den aktuella tråden för angiven tidsperiod."
  remarks: "Tråden kommer inte schemaläggas för körning av operativsystemet för den angivna tiden. Den här metoden ändrar status för tråden att inkludera <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>       Du kan ange <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>för den `timeout` parametern pausa tråden under obestämd tid.</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> Vi rekommenderar dock att du använder andra <xref:System.Threading?displayProperty=fullName>klasser som <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, eller <xref:System.Threading.Semaphore>i stället till sychronize trådar eller hantera resurser.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Den här överlagring för <xref:System.Threading.Thread.Sleep%2A>använder det totala antalet hela millisekunder i `timeout`.</xref:System.Threading.Thread.Sleep%2A> Bråkdelar millisekunder ignoreras.       Den här metoden utför inte standard COM och SendMessage pumpa.      > [!NOTE] > Om du behöver vila på en tråd som har <xref:System.STAThreadAttribute>, men du vill utföra standard COM och SendMessage pumpa bör du överväga att använda någon av överlagringar av den <xref:System.Threading.Thread.Join%2A>metod som anger ett timeout-intervall.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Hur lång tid som tråden har pausats. Om värdet för den `millisecondsTimeout` argumentet är &lt;xref:System.TimeSpan?displayProperty=fullName&gt;, tråden avsäger resten av dess tidsintervallet till varje tråd i samma prioritet som är redo att köras. Om det finns ingen annan tråd i samma prioritet som är redo att köras, körningen av den aktuella tråden inte har inaktiverats."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Värdet för <code> timeout </code> är negativt och är inte lika med &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; i millisekunder, eller är större än &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; millisekunder."
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gör att en tråd vänta antalet gånger som definieras av den <code> iterations </code> parameter."
  remarks: "SpinWait-metoden är användbar för att implementera Lås. Klasser i .NET Framework, som <xref:System.Threading.Monitor>och <xref:System.Threading.ReaderWriterLock>, använder den här metoden internt.</xref:System.Threading.ReaderWriterLock> </xref:System.Threading.Monitor> SpinWait i stort sett placerar processorn i en mycket tät loop med antalet loop som anges av den `iterations` parameter. Varaktighet för väntetid därför beror på processorns hastighet.       Jämför detta med den <xref:System.Threading.Thread.Sleep%2A>metoden.</xref:System.Threading.Thread.Sleep%2A> En tråd som anropar <xref:System.Threading.Thread.Sleep%2A>ger resten av dess aktuellt segment processortid, även om det angivna intervallet är noll.</xref:System.Threading.Thread.Sleep%2A> Ange ett noll-intervall för <xref:System.Threading.Thread.Sleep%2A>tar bort tråden från behandling med Schemaläggaren i tråden tills intervall har förflutit.</xref:System.Threading.Thread.Sleep%2A>       SpinWait är inte brukar vara användbara för vanliga program. I de flesta fall bör du använda synkronisering-klasser som tillhandahålls av .NET Framework. till exempel anropa <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>eller en instruktion som omsluter <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock` i C# eller `SyncLock` i Visual Basic).</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      > [!CAUTION] > I de sällsynta fall där är det fördelaktigt för att undvika att en kontext växel, till exempel när du vet att en tillståndsändring är nära förestående, gör ett anrop till metoden SpinWait din loop. Koden SpinWait kör är utformat för att förhindra problem som kan uppstå på datorer med flera processorer. På datorer med flera Intel-processorer med flertrådsteknik förhindrar till exempel SpinWait processor svält i vissa situationer."
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "En 32-bitars heltal som anger hur länge en tråd är vänta."
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gör att ändra tillståndet för den aktuella instansen till <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  remarks: "När en tråd är i den <xref:System.Threading.ThreadState?displayProperty=fullName>tillstånd, operativsystemet kan schemalägga för körning.</xref:System.Threading.ThreadState?displayProperty=fullName> Tråden påbörjas vid den första raden i metoden som representeras av det <xref:System.Threading.ThreadStart>eller <xref:System.Threading.ParameterizedThreadStart>delegat som skickades till konstruktorn tråd.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Observera att anropet till Start inte blockerar den anropande tråden.      > [!NOTE] > Om denna överlagring används med en tråd som skapats med en <xref:System.Threading.ParameterizedThreadStart>Delegera, `null` har överförts till metoden körs tråden.</xref:System.Threading.ParameterizedThreadStart>       När tråden avslutas, det går inte att starta om med ett annat anrop till `Start`."
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden har redan startats."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Det finns inte tillräckligt med minne för att starta den här tråden."
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gör att ändra tillståndet för den aktuella instansen till <xref href=&quot;System.Threading.ThreadState&quot;> </xref>, och du kan också tillhandahåller ett objekt som innehåller data som ska användas av metoden tråden körs."
  remarks: "När en tråd är i den <xref:System.Threading.ThreadState?displayProperty=fullName>tillstånd, operativsystemet kan schemalägga för körning.</xref:System.Threading.ThreadState?displayProperty=fullName> Tråden påbörjas vid den första raden i metoden som representeras av det <xref:System.Threading.ThreadStart>eller <xref:System.Threading.ParameterizedThreadStart>delegat som skickades till konstruktorn tråd.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Observera att anropet till Start inte blockerar den anropande tråden.       När tråden avslutas, det går inte att starta om med ett annat anrop till `Start`.       Den här överlagring och <xref:System.Threading.ParameterizedThreadStart>ombud gör det enkelt att skicka data till en tråd procedur, men tekniken är inte säker typ eftersom ett objekt kan skickas till den här överlagring.</xref:System.Threading.ParameterizedThreadStart> Stabilare sätt att skicka data till en tråd procedur är att placera datafälten och tråd-proceduren i en worker-objektet. Mer information finns i [trådar för att skapa och skicka Data vid Start](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "Ett objekt som innehåller data som ska användas av metoden tråden körs."
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden har redan startats."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Det finns inte tillräckligt med minne för att starta den här tråden."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den här tråden skapades med en <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegera i stället för en <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> delegera."
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pausar tråden, eller om tråden har redan pausats, har ingen effekt."
  remarks: "Om tråden har redan pausats, har den här metoden ingen effekt.      > [!CAUTION] > Inte använder inaktiverings och <xref:System.Threading.Thread.Resume%2A>metoder för att synkronisera aktiviteter trådar.</xref:System.Threading.Thread.Resume%2A> Det finns inget sätt att veta vilken kod en tråd körs när du avbryter den. Om du avbryter en tråd medan den innehåller Lås under en utvärdering av säkerhet behörighet, andra trådar i den <xref:System.AppDomain>blockeras.</xref:System.AppDomain> Om du avbryter en tråd medan det körs en klasskonstruktor, andra trådar i den <xref:System.AppDomain>som försöker använda att klassen är blockerade.</xref:System.AppDomain> Deadlocks kan uppstå väldigt enkelt."
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden har inte startats eller svarar inte."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte rätt <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Matchar en uppsättning namn med en motsvarande uppsättning dispatch-identifierare."
  remarks: "Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod. Mer information om `IDispatch::GetIDsOfNames`, finns i MSDN Library."
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Reserverat för framtida användning. Måste vara IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "Skickades i matris med namn som ska mappas."
    - id: cNames
      type: System.UInt32
      description: "Antal namnen mappas."
    - id: lcid
      type: System.UInt32
      description: "Språkvariant-kontext att tolka namnen."
    - id: rgDispId
      type: System.IntPtr
      description: "Anroparen allokerade matris som tar emot de ID: N som motsvarar namnen."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Sent bundna åtkomst med hjälp av COM `IDispatch` gränssnittet stöds inte."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar typinformation för ett objekt som kan användas för att hämta typinformation för ett gränssnitt."
  remarks: "Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod. Mer information om `IDispatch::GetTypeInfo`, finns i MSDN Library."
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "Informationen att returnera."
    - id: lcid
      type: System.UInt32
      description: "Språkvariant-ID för informationen."
    - id: ppTInfo
      type: System.IntPtr
      description: "Tar emot en pekare till informationsobjektet för den begärda typen."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Sent bundna åtkomst med hjälp av COM `IDispatch` gränssnittet stöds inte."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar antalet typen information gränssnitt att ett objekt tillhandahåller (0 eller 1)."
  remarks: "Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod. Mer information om `IDispatch::GetTypeInfoCount`, finns i MSDN Library."
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Pekar på en plats som tar emot antalet skriver information gränssnitt som tillhandahålls av objektet."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Sent bundna åtkomst med hjälp av COM `IDispatch` gränssnittet stöds inte."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Tillhandahåller åtkomst till egenskaper och metoder som visas av ett objekt."
  remarks: "Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod. Mer information om `IDispatch::Invoke`, finns i MSDN Library."
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identifierar medlemmen."
    - id: riid
      type: System.Guid
      description: "Reserverat för framtida användning. Måste vara IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "Språkvariant-kontext att tolka argument."
    - id: wFlags
      type: System.Int16
      description: "Flaggor som beskriver kontexten för anropet."
    - id: pDispParams
      type: System.IntPtr
      description: "Pekare till en struktur som innehåller en matris med argument, en matris med argumentet DISPID för namngivna argument och antal för antalet element i matriser."
    - id: pVarResult
      type: System.IntPtr
      description: "Pekar till den plats där resultatet ska lagras."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Pekare till en struktur som innehåller undantagsinformation om."
    - id: puArgErr
      type: System.IntPtr
      description: "Indexet för det första argumentet som har ett fel."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Sent bundna åtkomst med hjälp av COM `IDispatch` gränssnittet stöds inte."
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar ett värde som innehåller tillstånd för den aktuella tråden."
  remarks: "Egenskapen ThreadState ger mer specifik information än den <xref:System.Threading.Thread.IsAlive%2A>egenskapen.</xref:System.Threading.Thread.IsAlive%2A>      > [!IMPORTANT] > Trådtillstånd är av intresse för felsökning av scenarier. Koden ska aldrig använda Trådtillstånd för att synkronisera aktiviteter trådar."
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "En av de <xref href=&quot;System.Threading.ThreadState&quot;> </xref> värden som anger tillståndet för den aktuella tråden. Det första värdet är <xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Anger en tråd-inneslutningstillståndet innan den startas."
  remarks: "Nya trådar har initierats som <xref:System.Threading.ApartmentState?displayProperty=fullName>om deras inneslutningstillståndet inte har angetts innan de startas.</xref:System.Threading.ApartmentState?displayProperty=fullName> Inneslutningstillståndet måste anges innan en tråd har startats.      > [!NOTE] > Programmets tråden har initierats till <xref:System.Threading.ApartmentState?displayProperty=fullName>som standard.</xref:System.Threading.ApartmentState?displayProperty=fullName> Det enda sättet att ange inneslutningstillståndet för programmets tråden till <xref:System.Threading.ApartmentState?displayProperty=fullName>är att använda den <xref:System.STAThreadAttribute>attribut till metoden.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       Metoden TrySetApartmentState tillsammans med den <xref:System.Threading.Thread.GetApartmentState%2A>metoden och <xref:System.Threading.Thread.SetApartmentState%2A>metod, ersätter den <xref:System.Threading.Thread.ApartmentState%2A>egenskapen.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "Läget inneslutning."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om läget inneslutning anges; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>är inte en giltig inneslutningstillståndet."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Tråden har redan startats."
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "VolatileRead och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer hämtar VolatileRead det senaste värdet skrivs till en minnesplats med en processor. Detta kan kräva lokaliseraren processor cacheminnen.       Även om en processor datorn kan VolatileRead och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda VolatileRead eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder VolatileRead eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "Fältet som ska läsas."
    return:
      type: System.Byte
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "Fältet som ska läsas."
    return:
      type: System.Double
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "Fältet som ska läsas."
    return:
      type: System.Int16
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "Fältet som ska läsas."
    return:
      type: System.Int32
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "Fältet som ska läsas."
    return:
      type: System.Int64
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "Fältet som ska läsas."
    return:
      type: System.IntPtr
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "Fältet som ska läsas."
    return:
      type: System.Object
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "Fältet som ska läsas."
    return:
      type: System.SByte
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "Fältet som ska läsas."
    return:
      type: System.Single
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "Fältet som ska läsas."
    return:
      type: System.UInt16
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "Fältet som ska läsas."
    return:
      type: System.UInt32
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "Fältet som ska läsas."
    return:
      type: System.UInt64
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Läser värdet för ett fält. Värdet är den senaste skrivits med en processor i en dator, oavsett antalet processorer eller tillståndet för processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileRead%2A>hämtar det senaste värdet skrivs till en minnesplats med en processor.</xref:System.Threading.Thread.VolatileRead%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "Fältet som ska läsas."
    return:
      type: System.UIntPtr
      description: "Det senaste värdet som skrivs till fältet med en processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och VolatileWrite är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer garanterar VolatileWrite att ett värde som skrivs till en minnesplats omedelbart synliga för alla processorer. Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och VolatileWrite Kontrollera att ett värde läsa eller skriva till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att ge effektiva synkronisering för ett fält måste all åtkomst till fältet måste använda <xref:System.Threading.Thread.VolatileRead%2A>eller VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.Byte
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.Double
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.Int16
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.Int32
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.Int64
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.IntPtr
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.Object
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.SByte
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.Single
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.UInt16
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.UInt32
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.UInt64
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Skriver ett värde till ett fält omedelbart, så att värdet är synliga för alla processorer i datorn."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>är specialfall av synkronisering.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Under normala omständigheter, C# `lock` instruktionen, Visual Basic `SyncLock` -instruktionen och <xref:System.Threading.Monitor>klass är enklare alternativ.</xref:System.Threading.Monitor>       På ett system med flera processorer, <xref:System.Threading.Thread.VolatileWrite%2A>garanterar att ett värde som skrivs till en minnesplats är omedelbart synliga för alla processorer.</xref:System.Threading.Thread.VolatileWrite%2A> Detta kan kräva lokaliseraren processor cacheminnen.       Även på ett system med en processor, <xref:System.Threading.Thread.VolatileRead%2A>och <xref:System.Threading.Thread.VolatileWrite%2A>Se till att ett värde läsa eller skrivs till minne och inte cachelagras (till exempel i en processor register).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Du kan därför använda dem för att synkronisera åtkomst till ett fält som kan uppdateras av en annan tråd eller av maskinvara.       Den här metoden anropas påverkar en enstaka minnesåtkomst. För att tillhandahålla effektiva synkronisering för ett fält måste all åtkomst till fältet använda <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > I C# med hjälp av den `volatile` modifierare i ett fält som garanterar att all åtkomst till fältet använder <xref:System.Threading.Thread.VolatileRead%2A>eller <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "Det fält som är värdet som ska skrivas."
    - id: value
      type: System.UIntPtr
      description: "Värdet som ska skrivas."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gör den anropande tråden kan ge körningen till en annan tråd är redo att köra på den aktuella processorn. Operativsystemet väljer tråd kan ge dig till."
  remarks: "Om den här metoden lyckas gav resten av trådens aktuella tidsintervallet. Operativsystemet schemalägger den anropande tråden för en annan tidsintervallet enligt dess prioritet och status för andra trådar kan köras.       Framställning är begränsad till processorn som den anropande tråden körs. Operativsystemet växlar inte körning till en annan processor, även om processorn är inaktiv eller kör en tråd av lägre prioritet. Om det finns ingen annan tråd är redo att köras på den aktuella processorn operativsystemet ger inte körning och den här metoden returnerar `false`.       Den här metoden motsvarar med platform anropa för att anropa intern Win32 `SwitchToThread` funktion. Du bör kontakta avkastningen metoden i stället för med platform anropa eftersom plattformen anropa kringgår eventuella anpassade trådade beteende som värden har begärt."
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om systemet växlade körningen till en annan tråd. Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
