### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkContentElement
  id: FrameworkContentElement
  children:
  - System.Windows.FrameworkContentElement.#ctor
  - System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.BeginInit
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkContentElement.BindingGroup
  - System.Windows.FrameworkContentElement.BindingGroupProperty
  - System.Windows.FrameworkContentElement.BringIntoView
  - System.Windows.FrameworkContentElement.ContextMenu
  - System.Windows.FrameworkContentElement.ContextMenuClosing
  - System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  - System.Windows.FrameworkContentElement.ContextMenuOpening
  - System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkContentElement.ContextMenuProperty
  - System.Windows.FrameworkContentElement.Cursor
  - System.Windows.FrameworkContentElement.CursorProperty
  - System.Windows.FrameworkContentElement.DataContext
  - System.Windows.FrameworkContentElement.DataContextChanged
  - System.Windows.FrameworkContentElement.DataContextProperty
  - System.Windows.FrameworkContentElement.DefaultStyleKey
  - System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkContentElement.EndInit
  - System.Windows.FrameworkContentElement.FindName(System.String)
  - System.Windows.FrameworkContentElement.FindResource(System.Object)
  - System.Windows.FrameworkContentElement.FocusVisualStyle
  - System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  - System.Windows.FrameworkContentElement.ForceCursor
  - System.Windows.FrameworkContentElement.ForceCursorProperty
  - System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkContentElement.GetUIParentCore
  - System.Windows.FrameworkContentElement.Initialized
  - System.Windows.FrameworkContentElement.InputScope
  - System.Windows.FrameworkContentElement.InputScopeProperty
  - System.Windows.FrameworkContentElement.IsInitialized
  - System.Windows.FrameworkContentElement.IsLoaded
  - System.Windows.FrameworkContentElement.Language
  - System.Windows.FrameworkContentElement.LanguageProperty
  - System.Windows.FrameworkContentElement.Loaded
  - System.Windows.FrameworkContentElement.LoadedEvent
  - System.Windows.FrameworkContentElement.LogicalChildren
  - System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkContentElement.Name
  - System.Windows.FrameworkContentElement.NameProperty
  - System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OverridesDefaultStyle
  - System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkContentElement.Parent
  - System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.Resources
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkContentElement.ShouldSerializeResources
  - System.Windows.FrameworkContentElement.ShouldSerializeStyle
  - System.Windows.FrameworkContentElement.SourceUpdated
  - System.Windows.FrameworkContentElement.Style
  - System.Windows.FrameworkContentElement.StyleProperty
  - System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkContentElement.Tag
  - System.Windows.FrameworkContentElement.TagProperty
  - System.Windows.FrameworkContentElement.TargetUpdated
  - System.Windows.FrameworkContentElement.TemplatedParent
  - System.Windows.FrameworkContentElement.ToolTip
  - System.Windows.FrameworkContentElement.ToolTipClosing
  - System.Windows.FrameworkContentElement.ToolTipClosingEvent
  - System.Windows.FrameworkContentElement.ToolTipOpening
  - System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  - System.Windows.FrameworkContentElement.ToolTipProperty
  - System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  - System.Windows.FrameworkContentElement.Unloaded
  - System.Windows.FrameworkContentElement.UnloadedEvent
  - System.Windows.FrameworkContentElement.UnregisterName(System.String)
  - System.Windows.FrameworkContentElement.UpdateDefaultStyle
  langs:
  - csharp
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement
  fullName: System.Windows.FrameworkContentElement
  type: Class
  summary: "FrameworkContentElement är WPF framework nivå implementering och utbyggnad av den <xref href=&quot;System.Windows.ContentElement&quot;> </xref> basklassen. FrameworkContentElement lägger till stöd för ytterligare indata [!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)] (inklusive knappbeskrivningar och kontext menyer), storyboards, datakontexten för databindning, formatmallar stöd och logiska trädet helper [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]."
  remarks: "FrameworkContentElement ännu definiera inte egna återgivning beteende; en instans skapades av en verklig FrameworkContentElement klassinstans i koden eller markeringar går men visar ingenting i en [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] programmet [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]. Återge logik måste tillhandahållas av klasser som ta FrameworkContentElement underordnade element som en del av deras innehållsmodellen eller härledda klasser i FrameworkContentElement.       FrameworkContentElement parallels avsiktligt många av samma [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] som <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> Observera att vissa [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] hittades på <xref:System.Windows.FrameworkElement>inte har en motsvarighet på FrameworkContentElement.</xref:System.Windows.FrameworkElement> Flera av de <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] gäller funktioner såsom geometri återgivning eller layout, vilket inte är relevanta för ett FrameworkContentElement.</xref:System.Windows.FrameworkElement>       Merparten av befintliga FrameworkContentElement härledda klasser kommer att hittas i den <xref:System.Windows.Documents>namnområde.</xref:System.Windows.Documents> Många av dessa härledda klasser implementera element för Dataflödesmodell för dokumentet. Vissa härledda klasser som <xref:System.Windows.Documents.Hyperlink>har vissa kontroll-liknande funktioner, men härleds från FrameworkContentElement så att kontroll-liknande element kan dock delta i dokumentet Dataflödesmodell.</xref:System.Windows.Documents.Hyperlink>"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.ContentElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.AllowDrop
  - System.Windows.ContentElement.AllowDropProperty
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.AreAnyTouchesCaptured
  - System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.ContentElement.AreAnyTouchesOver
  - System.Windows.ContentElement.AreAnyTouchesOverProperty
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.CaptureMouse
  - System.Windows.ContentElement.CaptureStylus
  - System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.CommandBindings
  - System.Windows.ContentElement.DragEnter
  - System.Windows.ContentElement.DragEnterEvent
  - System.Windows.ContentElement.DragLeave
  - System.Windows.ContentElement.DragLeaveEvent
  - System.Windows.ContentElement.DragOver
  - System.Windows.ContentElement.DragOverEvent
  - System.Windows.ContentElement.Drop
  - System.Windows.ContentElement.DropEvent
  - System.Windows.ContentElement.Focus
  - System.Windows.ContentElement.Focusable
  - System.Windows.ContentElement.FocusableChanged
  - System.Windows.ContentElement.FocusableProperty
  - System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.ContentElement.GiveFeedback
  - System.Windows.ContentElement.GiveFeedbackEvent
  - System.Windows.ContentElement.GotFocus
  - System.Windows.ContentElement.GotFocusEvent
  - System.Windows.ContentElement.GotKeyboardFocus
  - System.Windows.ContentElement.GotKeyboardFocusEvent
  - System.Windows.ContentElement.GotMouseCapture
  - System.Windows.ContentElement.GotMouseCaptureEvent
  - System.Windows.ContentElement.GotStylusCapture
  - System.Windows.ContentElement.GotStylusCaptureEvent
  - System.Windows.ContentElement.GotTouchCapture
  - System.Windows.ContentElement.GotTouchCaptureEvent
  - System.Windows.ContentElement.HasAnimatedProperties
  - System.Windows.ContentElement.InputBindings
  - System.Windows.ContentElement.IsEnabled
  - System.Windows.ContentElement.IsEnabledChanged
  - System.Windows.ContentElement.IsEnabledCore
  - System.Windows.ContentElement.IsEnabledProperty
  - System.Windows.ContentElement.IsFocused
  - System.Windows.ContentElement.IsFocusedProperty
  - System.Windows.ContentElement.IsInputMethodEnabled
  - System.Windows.ContentElement.IsKeyboardFocused
  - System.Windows.ContentElement.IsKeyboardFocusedChanged
  - System.Windows.ContentElement.IsKeyboardFocusedProperty
  - System.Windows.ContentElement.IsKeyboardFocusWithin
  - System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  - System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  - System.Windows.ContentElement.IsMouseCaptured
  - System.Windows.ContentElement.IsMouseCapturedChanged
  - System.Windows.ContentElement.IsMouseCapturedProperty
  - System.Windows.ContentElement.IsMouseCaptureWithin
  - System.Windows.ContentElement.IsMouseCaptureWithinChanged
  - System.Windows.ContentElement.IsMouseCaptureWithinProperty
  - System.Windows.ContentElement.IsMouseDirectlyOver
  - System.Windows.ContentElement.IsMouseDirectlyOverChanged
  - System.Windows.ContentElement.IsMouseDirectlyOverProperty
  - System.Windows.ContentElement.IsMouseOver
  - System.Windows.ContentElement.IsMouseOverProperty
  - System.Windows.ContentElement.IsStylusCaptured
  - System.Windows.ContentElement.IsStylusCapturedChanged
  - System.Windows.ContentElement.IsStylusCapturedProperty
  - System.Windows.ContentElement.IsStylusCaptureWithin
  - System.Windows.ContentElement.IsStylusCaptureWithinChanged
  - System.Windows.ContentElement.IsStylusCaptureWithinProperty
  - System.Windows.ContentElement.IsStylusDirectlyOver
  - System.Windows.ContentElement.IsStylusDirectlyOverChanged
  - System.Windows.ContentElement.IsStylusDirectlyOverProperty
  - System.Windows.ContentElement.IsStylusOver
  - System.Windows.ContentElement.IsStylusOverProperty
  - System.Windows.ContentElement.KeyDown
  - System.Windows.ContentElement.KeyDownEvent
  - System.Windows.ContentElement.KeyUp
  - System.Windows.ContentElement.KeyUpEvent
  - System.Windows.ContentElement.LostFocus
  - System.Windows.ContentElement.LostFocusEvent
  - System.Windows.ContentElement.LostKeyboardFocus
  - System.Windows.ContentElement.LostKeyboardFocusEvent
  - System.Windows.ContentElement.LostMouseCapture
  - System.Windows.ContentElement.LostMouseCaptureEvent
  - System.Windows.ContentElement.LostStylusCapture
  - System.Windows.ContentElement.LostStylusCaptureEvent
  - System.Windows.ContentElement.LostTouchCapture
  - System.Windows.ContentElement.LostTouchCaptureEvent
  - System.Windows.ContentElement.MouseDown
  - System.Windows.ContentElement.MouseDownEvent
  - System.Windows.ContentElement.MouseEnter
  - System.Windows.ContentElement.MouseEnterEvent
  - System.Windows.ContentElement.MouseLeave
  - System.Windows.ContentElement.MouseLeaveEvent
  - System.Windows.ContentElement.MouseLeftButtonDown
  - System.Windows.ContentElement.MouseLeftButtonDownEvent
  - System.Windows.ContentElement.MouseLeftButtonUp
  - System.Windows.ContentElement.MouseLeftButtonUpEvent
  - System.Windows.ContentElement.MouseMove
  - System.Windows.ContentElement.MouseMoveEvent
  - System.Windows.ContentElement.MouseRightButtonDown
  - System.Windows.ContentElement.MouseRightButtonDownEvent
  - System.Windows.ContentElement.MouseRightButtonUp
  - System.Windows.ContentElement.MouseRightButtonUpEvent
  - System.Windows.ContentElement.MouseUp
  - System.Windows.ContentElement.MouseUpEvent
  - System.Windows.ContentElement.MouseWheel
  - System.Windows.ContentElement.MouseWheelEvent
  - System.Windows.ContentElement.OnCreateAutomationPeer
  - System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.PreviewDragEnter
  - System.Windows.ContentElement.PreviewDragEnterEvent
  - System.Windows.ContentElement.PreviewDragLeave
  - System.Windows.ContentElement.PreviewDragLeaveEvent
  - System.Windows.ContentElement.PreviewDragOver
  - System.Windows.ContentElement.PreviewDragOverEvent
  - System.Windows.ContentElement.PreviewDrop
  - System.Windows.ContentElement.PreviewDropEvent
  - System.Windows.ContentElement.PreviewGiveFeedback
  - System.Windows.ContentElement.PreviewGiveFeedbackEvent
  - System.Windows.ContentElement.PreviewGotKeyboardFocus
  - System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewKeyDown
  - System.Windows.ContentElement.PreviewKeyDownEvent
  - System.Windows.ContentElement.PreviewKeyUp
  - System.Windows.ContentElement.PreviewKeyUpEvent
  - System.Windows.ContentElement.PreviewLostKeyboardFocus
  - System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewMouseDown
  - System.Windows.ContentElement.PreviewMouseDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonDown
  - System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonUp
  - System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseMove
  - System.Windows.ContentElement.PreviewMouseMoveEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonDown
  - System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonUp
  - System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseUp
  - System.Windows.ContentElement.PreviewMouseUpEvent
  - System.Windows.ContentElement.PreviewMouseWheel
  - System.Windows.ContentElement.PreviewMouseWheelEvent
  - System.Windows.ContentElement.PreviewQueryContinueDrag
  - System.Windows.ContentElement.PreviewQueryContinueDragEvent
  - System.Windows.ContentElement.PreviewStylusButtonDown
  - System.Windows.ContentElement.PreviewStylusButtonDownEvent
  - System.Windows.ContentElement.PreviewStylusButtonUp
  - System.Windows.ContentElement.PreviewStylusButtonUpEvent
  - System.Windows.ContentElement.PreviewStylusDown
  - System.Windows.ContentElement.PreviewStylusDownEvent
  - System.Windows.ContentElement.PreviewStylusInAirMove
  - System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  - System.Windows.ContentElement.PreviewStylusInRange
  - System.Windows.ContentElement.PreviewStylusInRangeEvent
  - System.Windows.ContentElement.PreviewStylusMove
  - System.Windows.ContentElement.PreviewStylusMoveEvent
  - System.Windows.ContentElement.PreviewStylusOutOfRange
  - System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  - System.Windows.ContentElement.PreviewStylusSystemGesture
  - System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  - System.Windows.ContentElement.PreviewStylusUp
  - System.Windows.ContentElement.PreviewStylusUpEvent
  - System.Windows.ContentElement.PreviewTextInput
  - System.Windows.ContentElement.PreviewTextInputEvent
  - System.Windows.ContentElement.PreviewTouchDown
  - System.Windows.ContentElement.PreviewTouchDownEvent
  - System.Windows.ContentElement.PreviewTouchMove
  - System.Windows.ContentElement.PreviewTouchMoveEvent
  - System.Windows.ContentElement.PreviewTouchUp
  - System.Windows.ContentElement.PreviewTouchUpEvent
  - System.Windows.ContentElement.QueryContinueDrag
  - System.Windows.ContentElement.QueryContinueDragEvent
  - System.Windows.ContentElement.QueryCursor
  - System.Windows.ContentElement.QueryCursorEvent
  - System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.ReleaseAllTouchCaptures
  - System.Windows.ContentElement.ReleaseMouseCapture
  - System.Windows.ContentElement.ReleaseStylusCapture
  - System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.ShouldSerializeCommandBindings
  - System.Windows.ContentElement.ShouldSerializeInputBindings
  - System.Windows.ContentElement.StylusButtonDown
  - System.Windows.ContentElement.StylusButtonDownEvent
  - System.Windows.ContentElement.StylusButtonUp
  - System.Windows.ContentElement.StylusButtonUpEvent
  - System.Windows.ContentElement.StylusDown
  - System.Windows.ContentElement.StylusDownEvent
  - System.Windows.ContentElement.StylusEnter
  - System.Windows.ContentElement.StylusEnterEvent
  - System.Windows.ContentElement.StylusInAirMove
  - System.Windows.ContentElement.StylusInAirMoveEvent
  - System.Windows.ContentElement.StylusInRange
  - System.Windows.ContentElement.StylusInRangeEvent
  - System.Windows.ContentElement.StylusLeave
  - System.Windows.ContentElement.StylusLeaveEvent
  - System.Windows.ContentElement.StylusMove
  - System.Windows.ContentElement.StylusMoveEvent
  - System.Windows.ContentElement.StylusOutOfRange
  - System.Windows.ContentElement.StylusOutOfRangeEvent
  - System.Windows.ContentElement.StylusSystemGesture
  - System.Windows.ContentElement.StylusSystemGestureEvent
  - System.Windows.ContentElement.StylusUp
  - System.Windows.ContentElement.StylusUpEvent
  - System.Windows.ContentElement.TextInput
  - System.Windows.ContentElement.TextInputEvent
  - System.Windows.ContentElement.TouchDown
  - System.Windows.ContentElement.TouchDownEvent
  - System.Windows.ContentElement.TouchEnter
  - System.Windows.ContentElement.TouchEnterEvent
  - System.Windows.ContentElement.TouchesCaptured
  - System.Windows.ContentElement.TouchesCapturedWithin
  - System.Windows.ContentElement.TouchesDirectlyOver
  - System.Windows.ContentElement.TouchesOver
  - System.Windows.ContentElement.TouchLeave
  - System.Windows.ContentElement.TouchLeaveEvent
  - System.Windows.ContentElement.TouchMove
  - System.Windows.ContentElement.TouchMoveEvent
  - System.Windows.ContentElement.TouchUp
  - System.Windows.ContentElement.TouchUpEvent
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Initierar en ny instans av den <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> klass."
  syntax:
    content: public FrameworkContentElement ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Lägger till elementet som underordnad till det här elementet."
  remarks: "Den här metoden kan utlösa ett undantag om den anropas samtidigt när det logiska trädet är att hävdade av en annan process.       De flesta <xref:System.Windows.FrameworkContentElement>härledda klasser exponera dedikerad samlingar som är ansvarig för inneslutning (till exempel <xref:System.Windows.Documents.Span.Inlines%2A>på <xref:System.Windows.Documents.Span>-klassen. <xref:System.Windows.Documents.Section.Blocks%2A>på den <xref:System.Windows.Documents.Section>klassen).</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> Vanligtvis kan du undvika något behov av att ändra det logiska trädet direkt om du härledd från dessa klasser i stället. Arbeta med det logiska trädet för innehållselement är ett avancerat scenario som kan kräva särskilda parsern eller ett speciellt <xref:System.Windows.FrameworkElement>som fungerar som det överordnade återgivning elementet (innehållsvärden).</xref:System.Windows.FrameworkElement>       Mer information om hur du använder <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>och AddLogicalChild, se [träd i WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Det underordnade elementet som ska läggas till."
  overload: System.Windows.FrameworkContentElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anropas innan ett element har initierats."
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Börjar sekvens med åtgärder som finns i den angivna storyboard."
  remarks: "Signaturer som inte använder den `isControllable`, parametern eller när den här parametern anges `false`, Klockorna på tidslinjen som är associerade med animeringen tas bort när den når &quot;slutperiod&quot;. Animeringen kan därför inte startas om efter att köras en gång. Observera att styra en animering även kräver att storyboard namngiven eller tillgänglig som en instans i kod."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Storyboard ska börja."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Börjar sekvens med åtgärder som finns i den angivna storyboard med alternativ som har angetts för vad som ska hända om egenskapen är redan animerad."
  remarks: "Signaturer som inte använder den `isControllable`, parametern eller när den här parametern anges `false`, Klockorna på tidslinjen som är associerade med animeringen tas bort när den når &quot;slutperiod&quot;. Animeringen kan därför inte startas om efter att köras en gång. Observera att styra en animering även kräver att storyboard namngiven eller tillgänglig som en instans i kod.      ## Med den utgöra HandoffBehavior när du använder en <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, eller <xref:System.Windows.Media.Animation.AnimationClock>till en egenskap med hjälp av den <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, eventuella <xref:System.Windows.Media.Animation.Clock>objekt som tidigare har associerats med den egenskapen som fortsätter att använda systemresurser; tidsinställning systemet tar inte bort klockor automatiskt.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Att undvika prestandaproblem när du använder ett stort antal klockor med <xref:System.Windows.Media.Animation.HandoffBehavior>, bör du ta bort programstrukturen klockor från egenskapen animerade när den är klar.</xref:System.Windows.Media.Animation.HandoffBehavior> Det finns flera sätt att ta bort en klocka: – Om du vill ta bort alla klockor från en egenskap, använder den <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>eller <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>metoden i det animerade objektet.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Anger den egenskap som animeras som den första parametern och `null` som andra. Detta tar bort alla animering klockor från egenskapen.      -Om du vill ta bort en specifik <xref:System.Windows.Media.Animation.AnimationClock>från en lista över klockor, använder du <xref:System.Windows.Media.Animation.Clock.Controller%2A>egenskapen för <xref:System.Windows.Media.Animation.AnimationClock>att hämta en <xref:System.Windows.Media.Animation.ClockController>anropa <xref:System.Windows.Media.Animation.ClockController.Remove%2A>metoden i <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Detta görs vanligtvis den <xref:System.Windows.Media.Animation.Clock.Completed>händelsehanteraren för en clock.</xref:System.Windows.Media.Animation.Clock.Completed> Observera att endast roten klockor kan styras efter en <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>-egenskapen för en underordnad klocka returnerar `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Observera också att det <xref:System.Windows.Media.Animation.Clock.Completed>händelse utlöses inte om effektiva tidslängd klockan är alltid.</xref:System.Windows.Media.Animation.Clock.Completed>  I så fall måste användaren bestämma när anropet <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       Detta är i första hand ett problem för animeringar för objekt som har en lång livstid.  När ett objekt har skräpinsamlats, dess klockor kopplas också och skräpinsamlats.       Läs mer om klockan objekt [animering och tidsinställning Systemöversikt](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Storyboard ska börja."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Ett värde för uppräkning som beskriver problemet ska användas om en egenskap som beskrivs i storyboard aktiv redan."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Börjar sekvens med åtgärder som finns i den angivna storyboard med angivet tillstånd för kontroll av animeringen när den har startats."
  remarks: "Signaturer som inte använder den `isControllable`, parametern eller när den här parametern anges `false`, Klockorna på tidslinjen som är associerade med animeringen tas bort när den når &quot;slutperiod&quot;. Animeringen kan därför inte startas om efter att köras en gång. Observera att styra en animering även kräver att storyboard namngiven eller tillgänglig som en instans i kod.      ## Med den utgöra HandoffBehavior när du använder en <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, eller <xref:System.Windows.Media.Animation.AnimationClock>till en egenskap med hjälp av den <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, eventuella <xref:System.Windows.Media.Animation.Clock>objekt som tidigare har associerats med den egenskapen som fortsätter att använda systemresurser; tidsinställning systemet tar inte bort klockorna automatiskt.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Att undvika prestandaproblem när du använder ett stort antal klockor med <xref:System.Windows.Media.Animation.HandoffBehavior>, bör du ta bort programstrukturen klockor från egenskapen animerade när den är klar.</xref:System.Windows.Media.Animation.HandoffBehavior> Det finns flera sätt att ta bort en klocka: – Om du vill ta bort alla klockor från en egenskap, använder den <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>eller <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>metoden i det animerade objektet.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Anger den egenskap som animeras som den första parametern och `null` som andra. Detta tar bort alla animering klockor från egenskapen.      -Om du vill ta bort en specifik <xref:System.Windows.Media.Animation.AnimationClock>från en lista över klockor, använder du <xref:System.Windows.Media.Animation.Clock.Controller%2A>egenskapen för <xref:System.Windows.Media.Animation.AnimationClock>att hämta en <xref:System.Windows.Media.Animation.ClockController>anropa <xref:System.Windows.Media.Animation.ClockController.Remove%2A>metoden i <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Detta görs vanligtvis den <xref:System.Windows.Media.Animation.Clock.Completed>händelsehanteraren för en clock.</xref:System.Windows.Media.Animation.Clock.Completed> Observera att endast roten klockor kan styras efter en <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>-egenskapen för en underordnad klocka returnerar `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Observera också att det <xref:System.Windows.Media.Animation.Clock.Completed>händelse utlöses inte om effektiva tidslängd klockan är alltid.</xref:System.Windows.Media.Animation.Clock.Completed>  I så fall måste användaren bestämma när anropet <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       Detta är i första hand ett problem för animeringar för objekt som har en lång livstid.  När ett objekt har skräpinsamlats, dess klockor kopplas också och skräpinsamlats.       Läs mer om klockan objekt [animering och tidsinställning Systemöversikt](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Storyboard ska börja."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Ett värde för uppräkning som beskriver problemet ska användas om en egenskap som beskrivs i storyboard aktiv redan."
    - id: isControllable
      type: System.Boolean
      description: "Deklarerar om animeringen är kan kontrolleras (kan pausas) när den har startats."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger den <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> som används för elementet."
  remarks: "En <xref:System.Windows.Data.BindingGroup>kan användas för att verifiera värdena för flera egenskaper för ett objekt.</xref:System.Windows.Data.BindingGroup> Anta att ett program som uppmanar användaren att ange en adress och fyller i ett objekt av typen `Address`, som innehåller egenskaperna `Street`, `City`, `ZipCode`, och `Country`, med de värden som användaren angav. Programmet har en panel som innehåller fyra <xref:System.Windows.Controls.TextBox>kontroller, som är bunden till en av objektets egenskaper.</xref:System.Windows.Controls.TextBox> Du kan använda en <xref:System.Windows.Controls.ValidationRule>i en <xref:System.Windows.Data.BindingGroup>att verifiera den `Address` objekt.</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> Till exempel den <xref:System.Windows.Controls.ValidationRule>kan se till att zip-koden är giltig för land i adressen.</xref:System.Windows.Controls.ValidationRule>       Underordnade element ärver den <xref:System.Windows.Data.BindingGroup>från sina överordnade element, precis som med alla andra egenskaper som kan ärvas.</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|   | Metadata egenskaperna **SANT**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.BindingGroupProperty>"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "Den <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> som används för elementet."
  overload: System.Windows.FrameworkContentElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.BindingGroup*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Försök att göra det här elementet visas inom några rullningsbara regioner finns i."
  remarks: "Genom att anropa den här metoden du effektivt ska ringa <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>på alla överordnade rullningsbara området som innehåller elementet (överordnat mycket bra kan vara en <xref:System.Windows.FrameworkElement>, inte en <xref:System.Windows.FrameworkContentElement>).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> Om det här elementet inte finns i en rullningsbara området, händelsen visas fortfarande, men det finns inte någon effekt."
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger kontexten menyn elementet som ska visas när snabbmenyn begärs [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] från inom det här elementet."
  remarks: "<a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|   | Metadata egenskaperna `true`| Ingen |</xref:System.Windows.FrameworkContentElement.ContextMenuProperty>"
  example:
  - "The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#ContextMenu](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#contextmenu)]"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "Snabbmenyn som använder det här elementet."
  overload: System.Windows.FrameworkContentElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar innan alla snabbmenyn för elementet är stängd."
  remarks: "Om du vill ignorera avslutande ska snabbmenyer, hanterare för händelsen markeras som hanteras.       Att använda den här händelsen som en <xref:System.Windows.EventTrigger>i en style måste du referera till den underliggande tjänsten Händelseidentifieraren: [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (detta är nödvändigt eftersom händelse-implementering i <xref:System.Windows.FrameworkContentElement>som visar den underliggande tjänst händelsen inte korrekt mappas ContextMenuClosing identifierare för användning i utlöser).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a>## Dirigeras händelseinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|   | Routningsstrategi | Genomströmning |   | Delegaten | <xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>"
  example:
  - "The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown). The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> [dirigerade händelser översikt](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Händelse-ID-objekt skapas när dirigerade händelser är registrerade (se <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) och kan sedan användas för att lägga till klasshanterare (se <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objekt innehåller ett namn, typ, hanterartypen, routningsstrategi och en verktyget metod för att lägga till ägare för händelsen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar när en snabbmeny på elementet öppnas."
  remarks: "Om du vill öppna snabbmenyer manuellt bör hanterare av händelser Markera den relevanta händelsen som hanteras. Annars kan det befintliga värdet för den <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>egenskapen används för att automatiskt öppna en snabbmeny.</xref:System.Windows.FrameworkContentElement.ContextMenu%2A> Markera händelsen hanteras avbryts effektivt standardåtgärden och kan vara en möjlighet att återställa värdet för <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>egenskapen och öppna sedan den nya <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkContentElement.ContextMenu%2A> Det finns dock en tidsfel som du bör känna till. För att ersätta snabbmenyn via en ContextMenuOpening hanterare, vara inledande snabbmenyn inte null / tomt. Du kan också behöva händelsen och öppna ett nytt snabbmenyn manuellt. Mer information finns i [så här: hanterar händelsen ContextMenuOpening](~/add/includes/ajax-current-ext-md.md).       Att använda den här händelsen som en <xref:System.Windows.EventTrigger>i en style måste du referera till den underliggande tjänsten Händelseidentifieraren: [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (detta är nödvändigt eftersom händelse-implementering i <xref:System.Windows.FrameworkContentElement>som visar den underliggande tjänst händelsen inte korrekt mappas ContextMenuOpening identifierare för användning i utlöser).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a>## Dirigeras händelseinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|   | Routningsstrategi | Genomströmning |   | Delegaten | <xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> [dirigerade händelser översikt](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Händelse-ID-objekt skapas när dirigerade händelser är registrerade (se <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) och kan sedan användas för att lägga till klasshanterare (se <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objekt innehåller ett namn, typ, hanterartypen, routningsstrategi och en verktyget metod för att lägga till ägare för händelsen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.ContextMenu*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger den markör som visas när muspekaren är över det här elementet."
  remarks: "När den här egenskapen [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processor förlitar sig på typkonvertering för den <xref:System.Windows.Input.Cursor>klassen för att utvärdera strängen.</xref:System.Windows.Input.Cursor> Den angivna strängen ska utvärderas till ett <xref:System.Windows.Input.CursorType>värde.</xref:System.Windows.Input.CursorType> Se <xref:System.Windows.Input.Cursor>Mer information.</xref:System.Windows.Input.Cursor>       Om markören i enlighet med den här egenskapen ska eller inte visas när muspekaren hålls över det här elementet är också beroende på värdet för den <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>egenskapen.</xref:System.Windows.FrameworkContentElement.ForceCursor%2A> Händelse-relaterade överväganden, till exempel en aktiv dra, musinfångningen, textredigering lägen i kontroller och så vidare, påverkas också också markören med högre prioritet än värdet som du anger i den här egenskapen.       Om du vill återställa beteendet för den här egenskapen till eventuell standard anger `null` igen.       Den `null` standard verkligen innebär att bestämning av praktiska markören värdet skjuts här och ska hämtas från någon annanstans. Om inga programmässiga värden från en källa standardmarkören över en [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] programmet kommer att vara en pil.       Varje flytta musen över en [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] program aktiverar en <xref:System.Windows.ContentElement.QueryCursor>händelse.</xref:System.Windows.ContentElement.QueryCursor> Händelse-bubblor och element längs vägen har du möjlighet att hantera händelsen och ange värdet för markören via argument för den här händelsen. Om det sker så att händelsen hanteras och har ett värde som ändrade i argumenten företräde framför värdet för egenskapen Cursor när som helst om <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>har angetts.</xref:System.Windows.FrameworkContentElement.ForceCursor%2A>       Om du inte vill skapa en anpassad markör vanligtvis anger du egenskapen till statisk egenskapsvärdet <xref:System.Windows.Input.Cursors>klass.</xref:System.Windows.Input.Cursors>       Ange den <xref:System.Windows.Input.Cursor>till ett anpassat värde är inte aktiverat i partiellt förtroende.</xref:System.Windows.Input.Cursor> Mer information om anpassade markörer finns [indata översikt](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.CursorProperty>|   | Metadata egenskaperna `true`| Ingen |</xref:System.Windows.FrameworkContentElement.CursorProperty>"
  example:
  - "The following example sets the cursor to a custom value.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "Markören ska visas. Standardvärdet är definierad som <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> per denna beroendeegenskap. Dock kommer standardvärdet praktiska vid körning från en mängd olika faktorer."
  overload: System.Windows.FrameworkContentElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.Cursor*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger datakontexten för ett element när det ingår i databindning."
  remarks: "*Datakontexten* är ett begrepp som gör att elementen ska ärva information från sina överordnade element om källan för bindning som används för bindning, samt andra egenskaper för bindning till exempel sökvägen.       Datakontexten kan anges direkt till en [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] objekt med bindningar som utvärderar till egenskaperna för objektet. Du kan också ange datakontexten till en <xref:System.Windows.Data.DataSourceProvider>objektet.</xref:System.Windows.Data.DataSourceProvider>       Den här beroendeegenskap ärver egenskapsvärden. Om det finns underordnade element utan värde för DataContext som upprättats via lokala värden eller format, ska egenskapen systemet värdet ska vara DataContext värdet för det närmaste överordnade elementet med det här värdet som tilldelas.       Du kan också använda en av följande egenskaper för den <xref:System.Windows.Data.Binding>klassen för att ange bindning källan explicit: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, eller <xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> Mer information finns i [så här: Ange källa bindning](~/add/includes/ajax-current-ext-md.md).       I [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], DataContext anges vanligtvis till som en <xref:System.Windows.Data.Binding>deklaration.</xref:System.Windows.Data.Binding> Du kan använda egenskapselementsyntax eller attributsyntax. Attributsyntax visas i exemplet på den här sidan. Du kan också ange DataContext i kod.      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a>## XAML egenskapen Elementsyntax ```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> ## XAML attributsyntax ```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> ## XAML värden *dataContextObject* ett direkt inbäddade objekt som fungerar som datakontexten för alla bindningar i det överordnade elementet.             Det här objektet är vanligtvis en <xref:System.Windows.Data.Binding>eller en annan <xref:System.Windows.Data.BindingBase>underklass.</xref:System.Windows.Data.BindingBase> </xref:System.Windows.Data.Binding> Du kan också rådata för någon [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] objekttypen är avsedda för bindning kan placeras här, med de faktiska bindningarna anges senare.       *bindingUsage* användning av en bindning som resulterar i en lämplig datakontext. Mer information finns i [bindning Markeringstillägg](~/add/includes/ajax-current-ext-md.md).       *resourceExtension* något av följande: `StaticResource`, eller `DynamicResource`. Denna användning används när du refererar till rådata som har definierats som ett objekt i resurser. Se [XAML resurser](~/add/includes/ajax-current-ext-md.md).       *contextResourceKey* nyckelidentifierare för objektet som begärs från i <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.DataContextProperty>|   | Metadata egenskaperna `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.DataContextProperty>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as DataContext, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "Objektet som ska användas som datakontext."
  overload: System.Windows.FrameworkContentElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar när det här elementet datakontexten ändras."
  remarks: "En förklaring av datakontexter och databindning finns [översikt över bindning](~/add/includes/ajax-current-ext-md.md).      > [!IMPORTANT] > När ett element <xref:System.Windows.FrameworkContentElement.DataContext%2A>ändringar, alla databundna egenskaper för det här elementet påverkas potentiellt.</xref:System.Windows.FrameworkContentElement.DataContext%2A> Detta gäller för alla element som är underordnade element i det aktuella elementet som ärver datakontexten och det aktuella elementet i sig själv. Alla bindningar nytt tolka den nya <xref:System.Windows.FrameworkContentElement.DataContext%2A>att återspegla det nya värdet i Bindningar.</xref:System.Windows.FrameworkContentElement.DataContext%2A> Det finns inga garantier om ändringarna i förhållande till Utlösning av händelsen DataContextChanged ordning.  Ändringarna kan ske innan händelsen, efter händelsen eller i en blandning av."
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.DataContext*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger nyckeln som ska användas för att hitta stilmallen för den här kontrollen i teman."
  remarks: "Den här egenskapen anges normalt inte via någon av dess direkta setter. I stället kan åsidosätta du typspecifika metadata för den här beroendeegenskap varje gång du skapar en ny underklass. När du underklass, anropet den <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>metoden mot den <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>identifierare inom statisk konstruktor för kontrollen underklass.</xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       Till exempel en infogad klass som <xref:System.Windows.Documents.Bold>verkligen har mycket lite implementering utöver åsidosätter DefaultStyleKey metadata i dess statisk konstruktor och exponera flera instansen konstruktorer.</xref:System.Windows.Documents.Bold> Det faktum att element omges av den <xref:System.Windows.Documents.Bold>tagga få en <xref:System.Windows.Documents.TextElement.FontWeight%2A>-egenskapen för <xref:System.Windows.FontWeights.Bold%2A>implementeras i formatmallen tema som refereras till genom att ange standardvärdet för DefaultStyleKey till `typeof(Bold)`.</xref:System.Windows.FontWeights.Bold%2A> </xref:System.Windows.Documents.TextElement.FontWeight%2A> </xref:System.Windows.Documents.Bold>       Om du vill att din element eller kontrollen att avsiktligt inte använda temaformat anger den <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>egenskapen `true`.</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|   | Metadata egenskaperna `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "Style-nyckel. För att fungera som en del av tema format sökning, det här värdet förväntas vara den <xref:System.Type>för det element som är formaterad.</xref:System.Type> <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>är ett tillåtet värde för vissa fall. se anmärkning."
  overload: System.Windows.FrameworkContentElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anropas omedelbart efter att ett element har initierats."
  remarks: "Implementera den här metoden för att ge särskild hantering som ska utföras när elementet har initierats under elementet processen för inläsning.       Din implementering ska anropa den grundläggande implementeringen eftersom implementeringen base (standard) anger några interna flaggor att hålla reda på initiering.       Om <xref:System.Windows.FrameworkContentElement.BeginInit%2A>kallades tidigare, basen implementering höjer den <xref:System.Windows.FrameworkContentElement.Initialized>händelse.</xref:System.Windows.FrameworkContentElement.Initialized> </xref:System.Windows.FrameworkContentElement.BeginInit%2A> Annars, om <xref:System.Windows.FrameworkContentElement.BeginInit%2A>anropades inte eller kunde inte fastställa om <xref:System.Windows.FrameworkContentElement.BeginInit%2A>var anropas händelsen inte visas.</xref:System.Windows.FrameworkContentElement.BeginInit%2A> </xref:System.Windows.FrameworkContentElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Söker efter ett element som har det angivna Identifierarnamnet."
  remarks: "Om det här elementet har underordnade element, är alla eftersökt rekursivt för den begärda med namnet element i dessa underordnade element."
  example:
  - "The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindName](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findname)]\n [!code-vb[ContentElementsSmorgasbord#FindName](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findname)]"
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Namnet på det element du vill söka efter."
    return:
      type: System.Object
      description: "Begärt element. Kan vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om inga matchande element hittades."
  overload: System.Windows.FrameworkContentElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Söker efter en resurs med den angivna nyckeln och kan utlösa ett undantag om det gick inte att hitta den begärda resursen."
  remarks: "> [!IMPORTANT]> Om du anropar den här metoden för en nyckel som inte finns genereras ett undantag. Om du inte vill hantera undantag för det här fallet bör du istället anropa <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A> <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>Returnerar `null` när någon resurs har hittats och inget undantag genereras.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A>       Om resursen inte finns i elementet anropa, trädet överordnade genomsöks med hjälp av det logiska trädet, på samma sätt som i trädet ska eftersökt om en resurs begärdes av nyckel vid körning.       Du skulle vanligtvis omedelbart omvandla det returnera värdet för egenskapen som du försökte returnerade resurs-värde."
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findresource)]\n [!code-vb[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findresource)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Nyckelidentifierare av resursen ska hittas."
    return:
      type: System.Object
      description: "Resursen hittades eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om ingen matchande resurs hittades (men även utlöser ett undantag om <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>)."
  overload: System.Windows.FrameworkContentElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "Den begärda Resursnyckeln hittades inte."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger ett objekt för anpassning av utseende, effekter och andra format egenskaper som gäller för det här elementet när den samlar in tangentbordsfokus."
  remarks: "När den här egenskapen [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]formatmallar nästan alltid har definierats som en resurs i stället för på infogad som ett element och den här resursen refereras vanligtvis som en <xref:System.Windows.StaticResourceExtension>.</xref:System.Windows.StaticResourceExtension>       Observera att den här egenskapen påverkar utseende, men inte rapporterar det i metadata. Detta beror på att utseendet ändringen är händelsedriven och kan inte tillämpas vid alla tidpunkter och därför bör inte vanligtvis rapportera visual eller layout information i metadata.       Begreppsmässigt ska visual beteendet för fokus som tillämpas på en kontroll vara sammanhängande från element till elementet. Det mest sensible sättet att tillse enhetlighet är att bara ändra det visuella formatet fokus om du skriver ett hela tema. Den här egenskapen på enskilda format och inte som en del av ett tema är inte avsedda användning av den här egenskapen eftersom det kan leda till en förvirrande användarupplevelse om tangentbordsfokus. Om du har för avsikt element-specifika sätt som avsiktligt inte är konsekvent över ett tema, mycket är det bättre att använda utlösare i format för enskilda inkommande tillståndet egenskaper som <xref:System.Windows.UIElement.IsFocused%2A>eller <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, och för att göra det på ett sätt som visuellt inte stör några befintliga fokus visuella formatet.</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> Mer information om design avsikt FocusVisualStyle och alternativa fokus egenskaper finns [formatering för fokus i kontroller och FocusVisualStyle](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a>## XAML attributsyntax ```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> ## XAML egenskapen Elementsyntax <a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> ## XAML värden *resourceExtension* något av följande:, eller.       Se [XAML resurser](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* den nyckel som identifierar det format som begärs. Nyckeln som refererar till en befintlig resurs i <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Egenskapselementsyntax är tekniskt möjligt, men inte rekommenderas. Se [infogade format och mallar](~/add/includes/ajax-current-ext-md.md).  En bindning referens med eller <xref:System.Windows.Data.Binding>är också möjligt, men ovanliga.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|   | Metadata egenskaperna `true`| Ingen |</xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "Det önskade formatet som tillämpas på fokus. Standardvärdet som har deklarerats i beroendegenskapen är en tom static <xref href=&quot;System.Windows.Style&quot;> </xref>. Det effektiva värdet vid körning är dock ofta (men inte alltid) ett format som tillhandahålls av stöd för teman för kontroller."
  overload: System.Windows.FrameworkContentElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger ett värde som anger om detta <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> ska tvinga den [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] att återge markören som deklareras av den här instansen <xref:System.Windows.FrameworkContentElement.Cursor*>egenskap.</xref:System.Windows.FrameworkContentElement.Cursor*>"
  remarks: "Den här egenskapen `true` ska åsidosätta inställningarna för markören som upprättas av underordnade element. Göra så i allmänhet program [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] kan vara förvirrande för användaren, särskilt om underordnade element försöker ange markörer. Ange <xref:System.Windows.FrameworkElement.ForceCursor%2A>är mer lämpliga i scenarier för kontroll av skapa underklasser eller sammansättning.</xref:System.Windows.FrameworkElement.ForceCursor%2A>      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|   | Metadata egenskaperna `true`| Ingen |</xref:System.Windows.FrameworkContentElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor while over the element.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om du vill tvinga markören presentation medan över det här elementet för att använda den här instansen inställningen för markören (inklusive på alla underordnade element). Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardvärdet är <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.ForceCursor*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar den <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> för den angivna egenskapen bindning."
  remarks: ''
  example:
  - "The following example retrieves a binding by querying a property.  \n  \n [!code-cs[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#getbindingexpression)]\n [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#getbindingexpression)]"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Målet <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> från vilken du kan hämta bindningen."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Returnerar en <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> om målet är databunden; annars <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Returnerar ett alternativt logisk överordnad för det här elementet om det finns ingen visuell överordnad. I det här fallet en <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> överordnade är alltid samma värde som den <xref:System.Windows.FrameworkContentElement.Parent*>egenskapen.</xref:System.Windows.FrameworkContentElement.Parent*>"
  remarks: "Standardimplementering returnerar förväntade enda visuell överordnad. Anpassade implementeringar kan returnera alternativa överordnade relationer."
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "Returnerar något annat än <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> när en WPF framework nivå implementering av den här metoden har en icke-visuell överordnad anslutning."
  overload: System.Windows.FrameworkContentElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar när detta <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> har initierats. Detta sammanfaller med fall där värdet för den <xref:System.Windows.FrameworkContentElement.IsInitialized*>-egenskapen ändras från <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (eller odefinierad) till <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "Den här händelsen kommer att aktiveras när den <xref:System.Windows.FrameworkContentElement.EndInit%2A>eller <xref:System.Windows.FrameworkContentElement.OnInitialized%2A>metoder kallas.</xref:System.Windows.FrameworkContentElement.OnInitialized%2A> </xref:System.Windows.FrameworkContentElement.EndInit%2A> Anrop till dessa metoder kan har gjorts av avsiktlig kod eller av den [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] processen för inläsning."
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger kontext för indata som används av det här <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>."
  remarks: "Den här beroendeegenskap ärver egenskapsvärden. Om det finns underordnade element utan värde för <xref:System.Windows.FrameworkElement.InputScope%2A>upprätta via lokala värden eller formatmallar systemets egenskapen anger värdet så att den <xref:System.Windows.FrameworkElement.InputScope%2A>värdet för det närmaste överordnade elementet med det här värdet som tilldelas.</xref:System.Windows.FrameworkElement.InputScope%2A> </xref:System.Windows.FrameworkElement.InputScope%2A>       Även om en [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax användning visas och syntaktiskt tillåts, den här egenskapen [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] är inte vanligt.      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.InputScopeProperty>|   | Metadata egenskaperna `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "Indatatyp, som ändrar hur indata från alternativa inmatningsmetoder tolkas. Standardvärdet är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (vilket resulterar i en standard-hantering av kommandon)."
  overload: System.Windows.FrameworkContentElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.InputScope*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar ett värde som anger om det här elementet har initierats, antingen av läses som [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)], eller genom att explicit med dess <xref:System.Windows.FrameworkContentElement.EndInit*>anropade metoden.</xref:System.Windows.FrameworkContentElement.EndInit*>"
  remarks: "Den här egenskapen kan också vara `true` om det här elementet har flyttats i trädet elementet så att den har ett nytt överordnat element och därför blir läsas in igen igen."
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om elementet är initierad per ovannämnda inläsning eller metoden anrop; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar ett värde som anger om det här elementet har lästs in för presentation."
  remarks: "Från en nyligen konstruerade instansen egenskapen börjar `false`, och förblir `true` när den är inställd på `true`, även om därefter tas bort med kod."
  example:
  - "The following example code uses IsLoaded as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler. That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.  \n  \n [!code-cs[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#isloaded)]\n [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#isloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om det aktuella elementet är kopplat till ett element-träd och har gjorts; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om elementet aldrig har kopplats till ett inläst elementet träd."
  overload: System.Windows.FrameworkContentElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Language
  id: Language
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger lokalisering/globalisering språkinformation som gäller för ett enskilt element."
  remarks: "Strängformat följer RFC 3066 standard. Till exempel USA Engelska är &quot;sv-se&quot;. Se <xref:System.Windows.Markup.XmlLanguage>för mer information om värden och format.</xref:System.Windows.Markup.XmlLanguage>       Den här beroendeegenskap ärver egenskapsvärden. Om det finns underordnade element utan värde för <xref:System.Windows.FrameworkElement.Language%2A>upprätta via lokala värden eller formatmallar systemets egenskapen anger värdet så att den <xref:System.Windows.FrameworkElement.Language%2A>värdet för det närmaste överordnade elementet med det här värdet som tilldelas.</xref:System.Windows.FrameworkElement.Language%2A> </xref:System.Windows.FrameworkElement.Language%2A>      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.LanguageProperty>|   | Metadata egenskaperna `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "Kultur-information för det här elementet. Standardvärdet är en <xref href=&quot;System.Windows.Markup.XmlLanguage&quot;> </xref> instans med dess <xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>värdet till strängen &quot;sv-se&quot;.</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkContentElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.Language*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar när elementet är placerade, renderade och redo för interaktion."
  remarks: "Direkt dirigerade händelser efter inte en väg, hanteras endast inom samma element som de aktiveras. Dirigera dirigerade händelser har stöd för andra routade händelse beteende: de stöder en tillgänglig hanterare samling och kan användas som en <xref:System.Windows.EventTrigger>i en style.</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Loaded&quot;></a>## Dirigeras händelseinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.LoadedEvent>|   | Routningsstrategi | Direkt |   | Delegaten | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref href=&quot;System.Windows.FrameworkContentElement.Loaded&quot;> </xref> [dirigerade händelser översikt](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Händelse-ID-objekt skapas när dirigerade händelser är registrerade (se <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) och kan sedan användas för att lägga till klasshanterare (se <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objekt innehåller ett namn, typ, hanterartypen, routningsstrategi och en verktyget metod för att lägga till ägare för händelsen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar en uppräknare för den logiska underordnat element i det här elementet."
  remarks: "Mer information om hur du använder LogicalChildren och <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, se [träd i WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "En uppräknare för logiska underordnade element för det här elementet."
  overload: System.Windows.FrameworkContentElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Flyttar tangentbordsfokus från det här elementet till ett annat element."
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "Den riktning som fokus flyttas som ett värde för uppräkningen."
    return:
      type: System.Boolean
      description: "Returnerar <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> om fokus flyttas har; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om målelementet i riktning som angetts inte finns."
  overload: System.Windows.FrameworkContentElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Name
  id: Name
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger det identifierande namnet för elementet. Namnet på ger en instansreferens så att programmässiga bakomliggande kod, till exempel händelsekod hanterare, kan referera till ett element när den har skapats under tolkning av [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  remarks: "Den vanligaste användningen av den här egenskapen är när du anger en [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elementnamn i markering.       Den här egenskapen anger i princip en WPF framework nivå bekvämlighet egenskap för att ange den [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [x: Name direktiv](~/add/includes/ajax-current-ext-md.md).       Hämta ett namn från kod är inte vanligt, eftersom om du redan har referenserna i koden kan du bara anropa metoder och egenskaper för elementet referera och inte normalt måste namnet. Ett undantag är om strängen har vissa överbelastad vilket innebär att, till exempel om det är praktiskt att visa det här namnet i [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]. Ett namn från kod om det ursprungliga namnet angavs markering också rekommenderas inte och ändra egenskapen ändrar inte objektreferensen. Sådana objektreferenser skapas bara när de underliggande namescopes uttryckligen har skapats under [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] lästes in.       Mer specifikt måste du anropa <xref:System.Windows.FrameworkContentElement.RegisterName%2A>att göra en effektiv ändring Name-egenskapen för ett redan lästs in element.</xref:System.Windows.FrameworkContentElement.RegisterName%2A>       Ett viktiga fall där inställningsnamn från kod är viktig är för namngivning av element som storyboards ska köras mot. Innan du kan registrera ett namn, kan behöva skapa en instans av och tilldela en <xref:System.Windows.NameScope>instans.</xref:System.Windows.NameScope> Se avsnittet exempel eller [Storyboards översikt](~/add/includes/ajax-current-ext-md.md).       Inställningsnamn från kod har begränsad program, men slå upp ett element med namnet är vanligare, särskilt om du använder en navigering modell där sidor läsa in i programmet och körning koden är inte nödvändigtvis bakomliggande kod för respektive sidan. Metoden verktyget <xref:System.Windows.FrameworkContentElement.FindName%2A>, som är tillgängliga från någon <xref:System.Windows.FrameworkContentElement>, hittar element efter namn i den elementet logiska trädet rekursivt.</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkContentElement.FindName%2A> Du kan också använda den <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>statisk metod för <xref:System.Windows.LogicalTreeHelper>, som tar också namnsträngen som ett argument.</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       Vanliga rotelement (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>till exempel) implementerar gränssnittet <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Controls.Page> </xref:System.Windows.Window> Implementeringar av det här gränssnittet förväntas att genomdriva att namnen entydigt inom deras omfång.      <a name=&quot;dependencyPropertyInfo_Name&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.NameProperty>|   | Metadata egenskaperna `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkContentElement.NameProperty>"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "Namnet på elementet."
  overload: System.Windows.FrameworkContentElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.Name*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anropas när den <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> routade händelsen når den här klassen i vägen. Implementera den här metoden för att lägga till klassen som hanterar för den här händelsen."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers. Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Innehåller information om händelsen."
  overload: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anropas när den <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> routade händelsen når den här klassen i vägen. Implementera den här metoden för att lägga till klassen som hanterar för den här händelsen."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Händelsedata för händelsen."
  overload: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Klassen hanterare för den <xref href=&quot;System.Windows.ContentElement.GotFocus&quot;> </xref> händelse."
  remarks: "Den här klassen hanteraren anger rätt fokus beteende för det här elementet om händelsen skapades från det här elementet. Om den händelsekälla har ett annat element i trädet, ingenting hanteraren.       Åsidosätta den här metoden för att kunna ändra standard gäller elementet beteende."
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "Händelsedata för händelsen."
  overload: System.Windows.FrameworkContentElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Genererar den <xref href=&quot;System.Windows.FrameworkContentElement.Initialized&quot;> </xref> händelse. Den här metoden anropas när <xref:System.Windows.FrameworkContentElement.IsInitialized*>är inställd på <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "Standardimplementering av den här virtuella metoden genererar händelsen som beskrivits tidigare i det här avsnittet. Åsidosättningar ska anropa base() om du vill behålla det här beteendet.       Observera att den <xref:System.Windows.FrameworkContentElement.IsInitialized%2A>egenskapen är skrivskyddad.</xref:System.Windows.FrameworkContentElement.IsInitialized%2A> Därför kan du ange den att tvinga initiering av beteende på så sätt. Initieringsinställningen är avsedd att göra endast av den [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "Händelsedata för händelsen."
  overload: System.Windows.FrameworkContentElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anropas när det giltiga värdet för en beroendeegenskap på den här <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> har uppdaterats. Den specifika beroendegenskapen som ändrats rapporteras i parametern argument. Åsidosätter <xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*>"
  remarks: "Den här metoden är inte avsedd att identifiera ändrade egenskaper eller invalidations normalt. Den är i stället avsedd för ändringar av allmänna ogiltigförklarade mönstret om viss information är känt om wide klassificering av egenskaper.       Den här metoden anropas potentiellt många gånger under ett objekt. Därför kan du få bättre prestanda om du åsidosätter metadata för specifika egenskaper och sedan koppla <xref:System.Windows.CoerceValueCallback>eller <xref:System.Windows.PropertyChangedCallback>funktioner för enskilda egenskaper.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> Du kan använda den här metoden om en <xref:System.Windows.FrameworkContentElement>innehåller ett stort antal-värdet ihop dependency properties, eller om den innehåller logik som återges beteende som måste köras igen för flera relaterade fall av egenskapen invalidations.</xref:System.Windows.FrameworkContentElement>       Observera att det finns ett identiskt namngivna `OnPropertyChanged` metod med en annan signatur (parametertypen är <xref:System.ComponentModel.PropertyChangedEventArgs>) som kan visas på ett antal klasser.</xref:System.ComponentModel.PropertyChangedEventArgs> Att `OnPropertyChanged` används för data objektet meddelanden och är en del av kontraktet för <xref:System.ComponentModel.INotifyPropertyChanged>.</xref:System.ComponentModel.INotifyPropertyChanged>"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "De händelsedata som beskriver den egenskap som ändras, inklusive gamla och nya värden."
  overload: System.Windows.FrameworkContentElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anropas när formatet som används på det här elementet ändringar."
  remarks: "Den här metoden har en standardimplementering som anger en intern flagga påpekas villkoret format ändras."
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "Det gamla formatet."
    - id: newStyle
      type: System.Windows.Style
      description: "Det nya formatet."
  overload: System.Windows.FrameworkContentElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anropas när den <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> routade händelsen når den här klassen i vägen. Implementera den här metoden för att lägga till klassen som hanterar för den här händelsen."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Innehåller information om händelsen."
  overload: System.Windows.FrameworkContentElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anropas när den <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> routade händelsen når den här klassen i vägen. Implementera den här metoden för att lägga till klassen som hanterar för den här händelsen."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Innehåller information om händelsen."
  overload: System.Windows.FrameworkContentElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger ett värde som anger om det här elementet innehåller formategenskaper från temaformat."
  remarks: "Den vanligaste användningen av den här egenskapen är en indirekt användning i Set för ett format som tillhandahåller ett tema format.      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|   | Metadata egenskaperna `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om det här elementet inte använder tema formatmallsegenskaper; alla egenskaper i stil med ursprung komma från lokala program format och tema formatmallsegenskaper gäller inte. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Om programmet som gäller först och sedan temaformat använder för egenskaper som inte uttryckligen angetts i program-format."
  overload: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Parent
  id: Parent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar överordnat i det logiska trädet för det här elementet."
  remarks: "Observera att den logiska överordnat för ett element kan ändra beroende på din programfunktionen och behålla värden för den här egenskapen inte återspeglar den ändringen. Du bör oftast hämta värdet omedelbart innan du behöver den.       Se [träd i WPF](~/add/includes/ajax-current-ext-md.md) mer information om att gå igenom logiskt träd och scenarier där med den här metoden för identifiering av element är lämpligt.       Egenskapen system kommer potentiellt omberäkna alla egenskapsvärden för ett element när det är en ny överordnad, eftersom vissa egenskaper ärver värdena till det logiska trädet. Den <xref:System.Windows.FrameworkContentElement.DataContext%2A>som gäller för bindningar kan också ändra när element är en ny överordnad.</xref:System.Windows.FrameworkContentElement.DataContext%2A>       Ändra ett elements överordnade endast görs vanligtvis genom att ändra samlingar, med hjälp av särskilda lägga till eller ta bort metoderna, eller genom att innehåll egenskaper för element.       Det vanligaste scenariot för att använda den överordnade egenskapen är att hämta en referens och sedan hämta olika <xref:System.Windows.FrameworkContentElement>egenskapsvärden från överordnat.</xref:System.Windows.FrameworkContentElement> För mallar, överordnad mall så småningom kommer att `null`. För att komma förbi den här punkten och utöka till det logiska trädet där mallen faktiskt tillämpas, använder du <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>"
  example:
  - "The following example checks to see whether the Parent of a <xref:System.Windows.Documents.TextPointer> is of a particular type.  \n  \n [!code-cs[TextPointer_snippets#FCEParent](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#fceparent)]\n [!code-vb[TextPointer_snippets#FCEParent](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#fceparent)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Den logiska överordnat för det här elementet."
  overload: System.Windows.FrameworkContentElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Anger nästa element som ska få fokus i förhållande till det här elementet angivna fokus flytt riktningen, men inte att flytta fokus. Den här metoden är förseglat och kan inte åsidosättas."
  remarks: "<xref:System.Windows.FrameworkContentElement.MoveFocus%2A>är relaterad metod som faktiskt flyttar fokus.</xref:System.Windows.FrameworkContentElement.MoveFocus%2A>"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "Riktningen som en potentiell fokus ändring ska fastställas."
    return:
      type: System.Windows.DependencyObject
      description: "Nästa element som fokuserar vill flytta till om fokus faktiskt har slut. Kan returnera <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om inte går att flytta fokus i förhållande till det här elementet för den angivna riktningen."
  overload: System.Windows.FrameworkContentElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. De här anvisningarna är inte tillåten för PredictFocus (men de är giltiga för <xref:System.Windows.FrameworkContentElement.MoveFocus*>).</xref:System.Windows.FrameworkContentElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ger en accessor som förenklar åtkomsten till den <xref:System.Windows.NameScope>registreringsmetod.</xref:System.Windows.NameScope>"
  remarks: "Detta är en bekvämlighet-metoden för att anropa <xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A> Implementeringen kontrollerar efterföljande överordnade element tills den hittar tillämpliga <xref:System.Windows.NameScope>-implementering som hittas genom att söka efter ett element som implementerar <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.NameScope> Läs mer om namescopes [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md).       Anropar RegisterName krävs för att korrekt koppla upp animeringens storyboards för program när du skapade i koden. Detta beror på att en av storyboard egenskaper, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, använder en körning namnsökning i stället för att kunna ta en referens till ett målelement.</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> Detta gäller även om elementet är tillgänglig som referens från koden. Mer information om varför du behöver registrera namn för storyboard mål finns [Storyboards översikt](~/add/includes/ajax-current-ext-md.md). Animeringar för innehållselement är mindre vanliga än animeringar på kontroller, den [Storyboards översikt](../Topic/Storyboards%20Overview.md) fokuserar på programkontroll-scenarier."
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "Namn för den angivna namnet objektmappningen."
    - id: scopedElement
      type: System.Object
      description: "Objekt för mappningen."
  overload: System.Windows.FrameworkContentElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Tar bort det angivna elementet från det logiska trädet för det här elementet."
  remarks: "Detta [!INCLUDE[TLA#tla_api](~/add/includes/tlasharptla-api-md.md)] är främst relevant för klassen härleds scenarier, när du lägger till stöd för underordnade mängder.       De flesta <xref:System.Windows.FrameworkContentElement>härledda klasser exponera dedikerad samlingar som är ansvarig för inneslutning (till exempel <xref:System.Windows.Documents.Span.Inlines%2A>på <xref:System.Windows.Documents.Span>-klassen. <xref:System.Windows.Documents.Section.Blocks%2A>på den <xref:System.Windows.Documents.Section>klassen).</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> Vanligtvis härleds från dessa klasser kan undvika något behov av att ändra det logiska trädet direkt."
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Elementet ska tas bort."
  overload: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Resources
  id: Resources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger aktuellt lokalt definierade resurs ordlistan."
  remarks: "Resursordlistor som kan definieras helt eller delvis i [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] skapas vanligtvis som ett Egenskapselement och ligger vanligtvis i rotelementet för en enskild sida eller för programmet. Placera ordlistan resurs på den här nivån gör det lättare att hitta från enskilda underordnade element på sidan (eller från valfri om programmet). I de flesta scenarier med programmet rekommenderar vi att formatmallar definieras som objektet element i en resurs-ordlista eller definieras som externa resurser så att hela stilen resursen kan vara fristående (den här metoden hjälper separata designer ansvarsområden från utvecklare ansvarsområden genom att avgränsa de fysiska filer som måste redigeras).       Observera att den här egenskapen returnerar resurs ordlistan deklarerats direkt i elementet. Detta skiljer sig faktiska resurs sökning process där ett underordnat element kan komma åt någon av de resurser som definierats i varje överordnade element söker rekursivt uppåt.       Resurser kan också refereras av kod i samlingen, men tänk på att resurser skapas i [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definitivt inte tillgängliga förrän efter <xref:System.Windows.FrameworkContentElement.Loaded>utlöses av elementet som deklarerar ordlistan.</xref:System.Windows.FrameworkContentElement.Loaded> I själva verket resurser parsas asynkront, och inte ens den <xref:System.Windows.FrameworkContentElement.Loaded>händelsen är en försäkran om att du kan referera till en [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definierats resurs.</xref:System.Windows.FrameworkContentElement.Loaded> Därför du bör vanligtvis bara komma åt [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] definierat resurser som en del av kod eller via andra [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] tekniker, till exempel formatmallar eller resurstilläggets referenser för attributvärden. När du kommer åt resurser via kod den motsvarar i princip en referens från [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)].       Den underliggande <xref:System.Windows.ResourceDictionary>stöder metoder som krävs för att lägga till, ta bort eller fråga resurser i samlingen med hjälp av koden.</xref:System.Windows.ResourceDictionary> Egenskapen resurser går att ange för att stödja scenariot för att helt ersätta resurssamlingen för ett element ska vara en ny eller annan <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       Observera att den [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax visas inte innehåller ett element för <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> Detta är ett exempel på implicit samling syntax; en tagg som representerar samlingselementet kan utelämnas. Element som läggs till som objekt i samlingen anges i stället. Mer information om implicit samlingar och [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], se [XAML Syntax i detalj](~/add/includes/ajax-current-ext-md.md). Ett fall där en <xref:System.Windows.ResourceDictionary>fortfarande har angetts explicit som ett element är om du introducerar en sammanslagna ordlistan i vilket fall det inte finns vanligtvis inga underordnade element för att <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary> Mer information finns i [samman Resursordlistor](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a>## XAML egenskapen Elementsyntax ```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> ## XAML värden *oneOrMoreResourceElements* ett eller flera objekt element, som definierar en resurs.       Varje resurs Egenskapselement inom varje <xref:System.Windows.ResourceDictionary>måste ha ett unikt värde för den [x: nyckeln direktiv](~/add/includes/ajax-current-ext-md.md), som fungerar som en unik nyckel när värden hämtas från <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary>"
  example:
  - "The following example establishes a Resources collection on a <xref:System.Windows.Documents.FlowDocument> root element. <xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "Aktuellt lokalt definierade resurserna. Det här är en dictionary med resurser, där resurser i ordlistan kan nås av nyckeln."
  overload: System.Windows.FrameworkContentElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Bifogar en bindning till det här elementet baserat på angivna källa egenskapsnamnet som en sökväg kriteriet till datakällan."
  remarks: "Den här metoden är en bekvämlighet metod för att anropa <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, där passerar den aktuella instansen som den <xref:System.Windows.DependencyObject>, och skapar en ny <xref:System.Windows.Data.Binding>baserat på angiven `path` parameter.</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> Signaturen är det mer praktiskt om du vill upprätta en enkel standard-bindning. Om du behöver ange några egenskaper för bindning villkor som inte är standard eller vill använda en <xref:System.Windows.Data.MultiBinding>eller <xref:System.Windows.Data.PriorityBinding>, bör du använda den <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>signatur.</xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identifierar egenskapen bundna."
    - id: path
      type: System.String
      description: "Namnet på käll-egenskapen eller sökvägen till egenskapen som används för bindning."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Registrerar villkoren i bindningen. Värdet kan vara användbart för felkontroll av."
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Bifogar en bindning till det här elementet baserat på angivna binding-objektet."
  remarks: "Detta är en bekvämlighet-metoden för att anropa <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, där passerar den aktuella instansen som <xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.  \n  \n [!code-cs[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#setbinding)]\n [!code-vb[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#setbinding)]"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identifierar egenskapen bundna."
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "Representerar en databindning."
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "Registrerar villkoren i bindningen. Värdet kan vara användbart för felkontroll av."
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Söker efter en resurs med det angivna namnet och ställer in en resurs referens till den angivna egenskapen."
  remarks: "En Resursreferensen liknar användning av en [DynamicResource Markeringstillägg](~/add/includes/ajax-current-ext-md.md) i markering. Resursreferensen skapar ett internt uttryck som ger värdet för den angivna egenskapen för uppskjuten körning. Uttrycket nytt utvärderas när resursen ordlistan anger ändrade värdet via interna händelser, eller när det aktuella elementet är en ny överordnad (en överordnad ändring skulle ändra ordlista sökning sökvägen)."
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Egenskapen som är bunden till resursen."
    - id: name
      type: System.Object
      description: "Namnet på resursen."
  overload: System.Windows.FrameworkContentElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Returnerar om serialisering processer ska ordna innehållet för <xref:System.Windows.FrameworkContentElement.Resources*>egenskapen på instanser av den här klassen.</xref:System.Windows.FrameworkContentElement.Resources*>"
  remarks: "Detta returnerar `true` så länge det finns minst en nycklad resurs i lokalt <xref:System.Windows.FrameworkContentElement.Resources%2A>.</xref:System.Windows.FrameworkContentElement.Resources%2A>"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den <xref:System.Windows.FrameworkContentElement.Resources*>egenskapsvärdet måste vara serialiserade, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.Resources*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Returnerar om serialisering processer ska ordna innehållet för <xref:System.Windows.FrameworkContentElement.Style*>egenskapen på instanser av den här klassen.</xref:System.Windows.FrameworkContentElement.Style*>"
  remarks: "Detta returnerar `true` om den <xref:System.Windows.Style>anges lokalt.</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den <xref:System.Windows.FrameworkContentElement.Style*>egenskapsvärdet måste vara serialiserade, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.Style*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar när den associerade datakällan som deltar i en bindning på det här elementet ändringar."
  remarks: "Den här händelsen hämtar den <xref:System.Windows.Data.Binding.SourceUpdated>händelse som aktiveras av någon <xref:System.Windows.Data.Binding>som är associerade med det här elementet.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a>## XAML attributsyntax```   <object SourceUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Style
  id: Style
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger formatet som ska användas av det här elementet."
  remarks: "Det aktuella formatet som ofta standardformatet från teman och vanligtvis tillämpas på objekt av den typen av resurser på sidan- eller programnivå (en implicit formatmall)-format. Den här egenskapen har inte angetts eller returnera standardvärdet (temaformat), men den returnerar implicit formatmall eller ett explicit format. När det gäller implicit eller explicit format, spelar det ingen roll om stilen åtkomst till en resurs eller definieras lokalt.       Ange formaten har vissa begränsningar. Du kan återställa hela Style-egenskapen till en ny <xref:System.Windows.Style>när som helst som tvingar en layout recomposition.</xref:System.Windows.Style> Men så fort formatmallen placeras används av ett element som lästs in i <xref:System.Windows.Style>bör övervägas förseglade.</xref:System.Windows.Style> Försök att göra en ändring till en enskild egenskap av ett format som används (till exempel något i samlingen med <xref:System.Windows.Style.Setters%2A>) medför ett undantagsfel.</xref:System.Windows.Style.Setters%2A> En stil som definieras i markup betraktas som används när den har lästs in från en resurs (för resurser) eller läsa in sidan finns i (för infogade format).       Formatmallen är en beroendeegenskap med särskilda prioritet. Lokalt ange format fungerar vanligtvis på högst prioritet i egenskapen systemet. Om formatet är null nu under inläsning av egenskapen kontrollerar systemet för implicit formatmallar som definierade resurser som anger den typ. Om formatet är fortfarande null efter det här steget, sedan formatet som kommer från standardformatet (tema), men det standardformat som ska returneras inte i Style egenskapens värde. Se [beroende egenskapen värdet prioritet](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_Style&quot;></a>## XAML attributsyntax ```   <object Style=&quot;{resourceExtension StyleResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_Style&quot;> </a> ## XAML värden *resourceExtension* något av följande:, eller.       Se [XAML resurser](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* den nyckel som identifierar det format som begärs. Nyckeln som refererar till en befintlig resurs i <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Egenskapselementsyntax är tekniskt möjligt, men inte rekommenderas. Se [infogade format och mallar](~/add/includes/ajax-current-ext-md.md).  En bindning referens med eller <xref:System.Windows.Data.Binding>är också möjligt, men ovanliga.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.StyleProperty>|   | Metadata egenskaperna `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.StyleProperty>"
  example:
  - "The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "Det använda, icke-formatet för elementet, om den finns. Annars <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>. Standardvärdet för en standard-konstrueras <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.Style*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "En beskrivning av den här medlemmen, finns det <xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>metod.</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "Den här medlemmen är en implementering för medlem av explicit gränssnitt. Det kan användas endast när den <xref:System.Windows.FrameworkContentElement>instans omvandlas till ett <xref:System.Windows.Markup.IQueryAmbient>gränssnitt.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkContentElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "Namnet på den begärda ambient egenskapen."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om <code> propertyName </code> är tillgänglig, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Tag
  id: Tag
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger ett värde för objekt som kan användas för att lagra anpassad information om det här elementet."
  remarks: "Den här egenskapen är detsamma som Taggegenskaper i andra [!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)] programmeringsmodeller, till exempel [!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)] eller [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]. Den är avsedd att ge en befintlig plats att lagra grundläggande anpassad information om varje element utan att tvinga fram programutvecklare att underklass.      <a name=&quot;xamlValues_Tag&quot;></a>## XAML värden eftersom den här egenskapen tar ett objekt, måste du använda elementsyntax egenskapen för att ange egenskapen tagg i [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] till något annat än ett objekt med en känd och inbyggda typkonverterare, till exempel en sträng. Objekt som används i det här sättet finns vanligtvis inte inom standarden [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] namnområden och därför kan kräva namnområdesmappning till externa namnområdet för att kunna vara introduceras som [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] element.      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.TagProperty>|   | Metadata egenskaperna `true`| Ingen |</xref:System.Windows.FrameworkContentElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "Det avsedda värdet. Den här egenskapen har inget standardvärde."
  overload: System.Windows.FrameworkContentElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.Tag*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar när egenskapen target deltar i en bindning på det här elementet ändringar med alla associerade."
  remarks: "Den här händelsen hämtar den <xref:System.Windows.Data.Binding.TargetUpdated>händelse som aktiveras av någon <xref:System.Windows.Data.Binding>som är associerade med det här elementet.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> Detta innebär vanligen att bindningen i fråga är en dubbelriktad bindning och att den bundna beroendeegenskapen bekräftas en ogiltigförklaring av föregående egenskapsvärdet per alla verifiering eller cachelagring schemat som har stöd för egenskapen.       Händelseargument av den här händelsen informerar du bundna egenskap har ändrats.      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a>## XAML attributsyntax```   <object TargetUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar en referens till överordnat mallen för det här elementet. Den här egenskapen är inte relevant om elementet inte har skapats via en mall."
  remarks: "Mallar är faktiskt delade objekt, där innehållet i mallen skapas bara en gång. Om du hämtar en objektreferens till ett element som kommer från en mall kan det vara sig tydligt logiska träd inte når rot-sidan. För att kunna ansluta mallen hänvisningen till sidans logiska trädet ska du hämta TemplatedParent värdet och fortsätta att navigera trädet element som du vill.       TemplatedParent blir ofta `null` för vanliga objekt eftersom om du har fått en objektreferens utanför en sida i ditt program via vanliga sätt, elementet förmodligen inte har skapats från en mall. Fall där TemplatedParent inte kanske `null` omfattar åtgärder som till exempel träffar-testning, händelse hantering för vissa låg nivå inkommande händelser eller arbeta med uppräknare som kan ha returnerat element som kom från mallar."
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Elementet vars <xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>orsakade det här elementet som ska skapas.</xref:System.Windows.FrameworkTemplate.VisualTree*> Det här värdet är ofta <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; finns kommentarer."
  overload: System.Windows.FrameworkContentElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hämtar eller anger knappbeskrivningen objekt som visas för det här elementet i den [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]."
  remarks: "Om värdet för den här egenskapen är av typen <xref:System.Windows.Controls.ToolTip>, som är knappbeskrivningen som ska användas i den [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Controls.ToolTip>  Om värdet är av någon annan typ och värde som ska användas som den *innehåll* för en <xref:System.Windows.Controls.ToolTip>tillhandahålls (konstrueras) av systemet.</xref:System.Windows.Controls.ToolTip> Mer information finns i <xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> Tjänstklassen ger bifogade egenskaper som kan användas för att ytterligare anpassa en knappbeskrivning.      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a>## XAML attributsyntax ```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> ## XAML egenskapen Elementsyntax ```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> ## XAML värden *toolTipContent* en sträng som blir texten som visas för ToolTip.                   *toolTipObjectContent* vissa objekt, som anges i objektet elementet formulär som ska användas som innehållet för <xref:System.Windows.FrameworkContentElement>.</xref:System.Windows.FrameworkContentElement> Vanligtvis detta skulle vara en <xref:System.Windows.FrameworkElement>eller andra element som skapar layout sammansättning för knappbeskrivning slutligen som innehåller text innehåll inom sammansättningen.</xref:System.Windows.FrameworkElement> I denna användning av <xref:System.Windows.Controls.ToolTip>element har skapats implicit från den parsade [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], och *toolTipObjectContent* innehåll har angetts som dess <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>egenskap.</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a>## Beroendeegenskapsinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.ToolTipProperty>|   | Metadata egenskaperna `true`| Ingen |</xref:System.Windows.FrameworkContentElement.ToolTipProperty>"
  example:
  - "The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.  \n  \n [!code-cs[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/csharp/TableSnippets2/Window1.xaml.cs#_table_rowgroups_maniprows)]\n [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/visualbasic/tablesnippets2/window1.xaml.vb#_table_rowgroups_maniprows)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "Tooltip-objekt. Se anmärkning nedan för information om varför den här parametern är inte starkt typbestämd."
  overload: System.Windows.FrameworkContentElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar precis innan en knappbeskrivning på elementet är stängd."
  remarks: "Om du inte stänger knappbeskrivningen, ska hanterare för händelsen markeras som hanteras.       Den här händelsen kan inte vara en <xref:System.Windows.EventTrigger>i en style.</xref:System.Windows.EventTrigger> Det beror på att fältet ID för den här händelsen återanvänder en implementering från en tjänst som inte exponerar lägga till/ta bort metoderna för händelsen.      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a>## Dirigeras händelseinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|   | Routningsstrategi | Direkt |   | Delegaten | <xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> [dirigerade händelser översikt](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Händelse-ID-objekt skapas när dirigerade händelser är registrerade (se <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) och kan sedan användas för att lägga till klasshanterare (se <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objekt innehåller ett namn, typ, hanterartypen, routningsstrategi och en verktyget metod för att lägga till ägare för händelsen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar när en knappbeskrivning på elementet öppnas."
  remarks: "Om du vill öppna knappbeskrivningar manuellt bör hanterare av händelser Markera den relevanta händelsen som hanteras. I annat fall värdet för den <xref:System.Windows.FrameworkContentElement.ToolTip%2A>egenskapen används för att automatiskt öppna en snabbmeny.</xref:System.Windows.FrameworkContentElement.ToolTip%2A> Markera händelsen hanteras avbryts effektivt standardåtgärden och kan vara en möjlighet att återställa värdet för <xref:System.Windows.FrameworkContentElement.ToolTip%2A>egenskapen och öppna sedan den nya <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkContentElement.ToolTip%2A> Observera att den här händelsen inte aktiveras om <xref:System.Windows.FrameworkContentElement.ToolTip%2A>är en null-referens eller på annat sätt att.</xref:System.Windows.FrameworkContentElement.ToolTip%2A>       Den här händelsen kan inte vara en <xref:System.Windows.EventTrigger>i en style.</xref:System.Windows.EventTrigger> Det beror på att fältet ID för den här händelsen återanvänder en implementering från en tjänst som inte exponerar lägga till/ta bort metoderna för händelsen.      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a>## Dirigeras händelseinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|   | Routningsstrategi | Direkt |   | Delegaten | <xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> [dirigerade händelser översikt](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Händelse-ID-objekt skapas när dirigerade händelser är registrerade (se <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) och kan sedan användas för att lägga till klasshanterare (se <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objekt innehåller ett namn, typ, hanterartypen, routningsstrategi och en verktyget metod för att lägga till ägare för händelsen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref:System.Windows.FrameworkContentElement.ToolTip*>beroendeegenskap.</xref:System.Windows.FrameworkContentElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Söker efter en resurs med angiven nyckel och returnerar den här resursen om hittades."
  remarks: "Om resursen inte finns i elementet anropa, trädet överordnade genomsöks med hjälp av det logiska trädet på samma sätt som i trädet ska sökas igenom om en dynamisk Resursreferensen begärdes av nyckel vid körning.       Du skulle vanligtvis omedelbart omvandla det returnera värdet för egenskapen som du försökte returnerade resurs-värde.       Den <xref:System.Windows.FrameworkContentElement.FindResource%2A>metoden har liknande beteende, förutom att det genereras ett undantagsfel när det gäller inte att hitta en resurs med den angivna nyckeln.</xref:System.Windows.FrameworkContentElement.FindResource%2A>"
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#tryfindresource)]\n [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#tryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Nyckelidentifierare av resursen ska hittas."
    return:
      type: System.Object
      description: "Resursen hittades. Om ingen resurs hittades <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> returneras."
  overload: System.Windows.FrameworkContentElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inträffar när elementet tas bort från ett element-träd av inläst elementen."
  remarks: "Direkt dirigerade händelser efter inte en väg, hanteras endast inom samma element som de aktiveras. Dirigera dirigerade händelser har stöd för andra routade händelse beteende: de stöder en tillgänglig hanterare samling och kan användas som en <xref:System.Windows.EventTrigger>i en style.</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Unloaded&quot;></a>## Dirigeras händelseinformation |||   |-|-|   | ID-fältet | <xref:System.Windows.FrameworkContentElement.UnloadedEvent>|   | Routningsstrategi | Direkt |   | Delegaten | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identifierar den <xref href=&quot;System.Windows.FrameworkContentElement.Unloaded&quot;> </xref> [dirigerade händelser översikt](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Händelse-ID-objekt skapas när dirigerade händelser är registrerade (se <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) och kan sedan användas för att lägga till klasshanterare (se <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objekt innehåller ett namn, typ, hanterartypen, routningsstrategi och en verktyget metod för att lägga till ägare för händelsen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Förenklar åtkomsten till den <xref:System.Windows.NameScope>inaktiveringen registrering metoden.</xref:System.Windows.NameScope>"
  remarks: "Du behöver bara avregistrera namn om du vill registrera ett annat element med det här namnet."
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Namnet på paret namn-objekt att ta bort från den aktuella omfattningen."
  overload: System.Windows.FrameworkContentElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Återställer standardformat för aktuellt <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>."
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.ContentElement
  isExternal: false
  name: System.Windows.ContentElement
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkContentElement.#ctor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkContentElement.BeginInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkContentElement.BindingGroup
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkContentElement.BringIntoView
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
- uid: System.Windows.FrameworkContentElement.ContextMenu
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
- uid: System.Windows.FrameworkContentElement.Cursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkContentElement.CursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
- uid: System.Windows.FrameworkContentElement.DataContext
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkContentElement.EndInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkContentElement.ForceCursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkContentElement.Initialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkContentElement.InputScope
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
- uid: System.Windows.FrameworkContentElement.IsInitialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
- uid: System.Windows.FrameworkContentElement.Loaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkContentElement.Name
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.NameProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkContentElement.Parent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkContentElement.Resources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkContentElement.Style
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.StyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkContentElement.Tag
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TagProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
- uid: System.Windows.FrameworkContentElement.Unloaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkContentElement.#ctor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement.FrameworkContentElement
- uid: System.Windows.FrameworkContentElement.AddLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkContentElement.AddLogicalChild
- uid: System.Windows.FrameworkContentElement.BeginInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkContentElement.BeginInit
- uid: System.Windows.FrameworkContentElement.BeginStoryboard*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkContentElement.BeginStoryboard
- uid: System.Windows.FrameworkContentElement.BindingGroup*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
- uid: System.Windows.FrameworkContentElement.BringIntoView*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkContentElement.BringIntoView
- uid: System.Windows.FrameworkContentElement.ContextMenu*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
- uid: System.Windows.FrameworkContentElement.Cursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
- uid: System.Windows.FrameworkContentElement.DataContext*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.EndInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkContentElement.EndInit
- uid: System.Windows.FrameworkContentElement.FindName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkContentElement.FindName
- uid: System.Windows.FrameworkContentElement.FindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkContentElement.FindResource
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.FrameworkContentElement.ForceCursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.GetBindingExpression*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkContentElement.GetBindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkContentElement.GetUIParentCore
- uid: System.Windows.FrameworkContentElement.InputScope*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
- uid: System.Windows.FrameworkContentElement.IsInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
- uid: System.Windows.FrameworkContentElement.LogicalChildren*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
- uid: System.Windows.FrameworkContentElement.MoveFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkContentElement.MoveFocus
- uid: System.Windows.FrameworkContentElement.Name*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkContentElement.OnContextMenuClosing
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkContentElement.OnContextMenuOpening
- uid: System.Windows.FrameworkContentElement.OnGotFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkContentElement.OnGotFocus
- uid: System.Windows.FrameworkContentElement.OnInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkContentElement.OnInitialized
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkContentElement.OnPropertyChanged
- uid: System.Windows.FrameworkContentElement.OnStyleChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkContentElement.OnStyleChanged
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkContentElement.OnToolTipClosing
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkContentElement.OnToolTipOpening
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.Parent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkContentElement.PredictFocus
- uid: System.Windows.FrameworkContentElement.RegisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkContentElement.RegisterName
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkContentElement.RemoveLogicalChild
- uid: System.Windows.FrameworkContentElement.Resources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
- uid: System.Windows.FrameworkContentElement.SetBinding*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkContentElement.SetBinding
- uid: System.Windows.FrameworkContentElement.SetResourceReference*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkContentElement.SetResourceReference
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkContentElement.ShouldSerializeResources
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkContentElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkContentElement.Style*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkContentElement.Tag*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TemplatedParent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.TryFindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkContentElement.TryFindResource
- uid: System.Windows.FrameworkContentElement.UnregisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkContentElement.UnregisterName
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkContentElement.UpdateDefaultStyle
