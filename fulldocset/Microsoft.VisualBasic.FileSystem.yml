### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "Den <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> modulen innehåller procedurer som används för att utföra åtgärder i filen, katalogen eller mappen och system. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än att använda den <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> modul. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den här modulen stöder nyckelord i Visual Basic och körningsbibliotek medlemmar som har åtkomst till filer och mappar."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Ändrar den aktuella katalogen eller mappen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än den <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;> </xref>funktion. Mer information finns i <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "Den `ChDir` funktionen ändrar standardkatalogen, men inte standardenheten. Till exempel om Standardenheten är C, ändrar följande sats standardkatalogen på enhet D, men C förblir standardenheten: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ] du relativa katalogändringar är genom att skriva två punkter på följande sätt: [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] > den `ChDir` funktionen kräver ohanterad Kodbehörighet, vilket kan påverka körningen i partiellt förtroende situationer. Mer information finns i <xref:System.Security.Permissions.SecurityPermission>och.</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obligatoriskt. En <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> uttryck som identifierar vilken katalog eller mapp blir den nya standardkatalogen eller mappen. `Path`enheten kan innehålla. Om ingen enhet anges <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref> ändras standardkatalogen eller mapp på den aktuella enheten."
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>är tom."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Ogiltig enhet har angetts eller enheten är inte tillgänglig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Ändrar den aktuella enheten."
  remarks: "Den `ChDrive` funktionen kräver ohanterad kod behörighet, vilket kan påverka körningen i partiellt förtroende situationer. Mer information finns i <xref:System.Security.Permissions.SecurityPermission>och [kod åtkomstbehörigheter](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Obligatoriskt. Stränguttryck som anger en befintlig enhet. Om du anger en tom sträng (&quot;&quot;), ändras inte den aktuella enheten. Om den `Drive` argumentet är en sträng med flera tecken, <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> använder bara den första bokstaven."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ogiltig enhet har angetts eller enheten är inte tillgänglig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Ändrar den aktuella enheten."
  remarks: "Den `ChDrive` funktionen kräver ohanterad kod behörighet, vilket kan påverka körningen i partiellt förtroende situationer. Mer information finns i <xref:System.Security.Permissions.SecurityPermission>och [kod åtkomstbehörigheter](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "Obligatoriskt. Stränguttryck som anger en befintlig enhet. Om du anger en tom sträng (&quot;&quot;), ändras inte den aktuella enheten. Om den `Drive` argumentet är en sträng med flera tecken, <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> använder bara den första bokstaven."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ogiltig enhet har angetts eller enheten är inte tillgänglig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en sträng som representerar den aktuella sökvägen. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "En sträng som representerar den aktuella sökvägen."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en sträng som representerar den aktuella sökvägen. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Valfritt. <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>uttryck som anger en befintlig enhet. Om ingen enhet anges, eller om `Drive` är en tom sträng (&quot;&quot;), <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref> returnerar sökvägen för den aktuella enheten."
    return:
      type: System.String
      description: "En sträng som representerar den aktuella sökvägen."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en sträng som representerar namnet på en fil, en katalog eller en mapp som matchar ett specifikt mönster eller filattribut eller volymetiketten för en enhet. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ger bättre produktivitet och prestanda i i/o-filåtgärder än den <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> funktion. Se <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>för mer information.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "Den `Dir` funktionen har stöd för flera tecken (`*`) och tecken (`?`) jokertecken för att ange flera filer.       `VbVolume`Returnerar volymetiketten för enheten i stället för ett specifikt filnamn.       Du måste ange en `PathName` första gången du anropar den `Dir` funktion. Om du vill hämta nästa objekt du efterföljande anrop till den `Dir` funktionen utan parametrar.      > [!IMPORTANT] > Ska kunna köras korrekt, den `Dir` funktionen kräver den <xref:System.Security.Permissions.FileIOPermissionAccess>och <xref:System.Security.Permissions.FileIOPermissionAccess>flaggor för <xref:System.Security.Permissions.FileIOPermission>som ska tilldelas kör kod.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Mer information finns i <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, och [kod åtkomstbehörigheter](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       Den `Attributes` argumentet uppräkningsvärden är följande: |||   |-|-|-|   | Värdet | Konstanten | Beskrivning |   | `Normal`|`vbnormal`| Som standard. Anger att filer utan attribut. |   | `ReadOnly`|`vbReadOnly`| Anger skrivskyddade filer och filer utan attribut. |   | `Hidden`|`vbHidden`| Anger dolda filer och filer utan attribut. |   | `System`|`vbSystem`| Anger systemfiler och filer utan attribut. |   | `Volume`|`vbVolume`| Anger volymetiketten; Om andra attribut anges `vbVolume` ignoreras. |   | `Directory`|`vbDirectory`| Anger kataloger och mappar och filer även utan attribut. |   | `Archive`|`vbArchive`| Filen har ändrats sedan den senaste säkerhetskopieringen. |   | `Alias`|`vbAlias`| Filen har ett annat namn. |      > [!NOTE] > Dessa uppräkningar definieras med språket Visual Basic och kan användas i koden i stället för de faktiska värdena."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "En sträng som representerar namnet på en fil, en katalog eller en mapp som matchar ett specifikt mönster eller filattribut eller volymetiketten för en enhet."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en sträng som representerar namnet på en fil, en katalog eller en mapp som matchar ett specifikt mönster eller filattribut eller volymetiketten för en enhet. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ger bättre produktivitet och prestanda i i/o-filåtgärder än den <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> funktion. Se <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>för mer information.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "Den `Dir` funktionen har stöd för flera tecken (`*`) och tecken (`?`) jokertecken för att ange flera filer.       `VbVolume`Returnerar volymetiketten för enheten i stället för ett specifikt filnamn.       Du måste ange en `PathName` första gången du anropar den `Dir` funktion. Om du vill hämta nästa objekt du efterföljande anrop till den `Dir` funktion utan parametrar.      > [!IMPORTANT] > Ska kunna köras korrekt, den `Dir` funktionen kräver den <xref:System.Security.Permissions.FileIOPermissionAccess>och <xref:System.Security.Permissions.FileIOPermissionAccess>flaggor för <xref:System.Security.Permissions.FileIOPermission>som ska tilldelas kör kod.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Mer information finns i <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, och [kod åtkomstbehörigheter](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       Den `Attributes` argumentet uppräkningsvärden är följande: |||   |-|-|-|   | Värdet | Konstanten | Beskrivning |   | `Normal`|`vbnormal`| Som standard. Anger att filer som har inga attribut. |   | `ReadOnly`|`vbReadOnly`| Anger skrivskyddade filer och filer som har inga attribut. |   | `Hidden`|`vbHidden`| Anger dolda filer och filer som har inga attribut. |   | `System`|`vbSystem`| Anger systemfiler, förutom filer som har inga attribut. |   | `Volume`|`vbVolume`| Anger volymetiketten; Om andra attribut anges `vbVolume` ignoreras. |   | `Directory`|`vbDirectory`| Anger kataloger och mappar, förutom att filer som har inga attribut. |   | `Archive`|`vbArchive`| Filen har ändrats sedan den senaste säkerhetskopieringen. |   | `Alias`|`vbAlias`| Filen har ett annat namn. |      > [!NOTE] > Dessa uppräkningar definieras med språket Visual Basic och kan användas i koden i stället för de faktiska värdena."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "Valfritt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger ett filnamn, katalog-eller mappnamn eller volymetiketten för enheten. En tom sträng (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) returneras om `PathName` hittas inte."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Valfritt. Uppräkning eller ett numeriskt uttryck vars värde Anger filattribut. Om det utelämnas används <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> returnerar filer som matchar `PathName` men har inga attribut."
    return:
      type: System.String
      description: "En sträng som representerar namnet på en fil, en katalog eller en mapp som matchar ett specifikt mönster eller filattribut eller volymetiketten för en enhet."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar ett booleskt värde <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> när slutet av filen öppnas för <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> eller sekventiella <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> har uppnåtts."
  remarks: "Använd `EOF` att undvika fel som uppstår försöker läsa efter slutet av en fil.       Den `EOF` fungerar returnerar `False` förrän du har nått slutet av filen. Filen har öppnats för `Random` eller `Binary` åtkomst, `EOF` returnerar `False` tills ett `FileGet` funktion går inte att läsa en hel post.       Filen har öppnats för `Binary` komma åt ett försök att läsa igenom filen med den `Input` fungera tills `EOF` returnerar `True` genererar ett fel. Använd den `LOF` och `Loc` fungerar i stället för `EOF` när du läser binära filer med `Input`, eller Använd `Get` när du använder den `EOF` funktion. Filen har öppnats för `Output`, `EOF` returnerar alltid `True`."
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> som innehåller ett giltigt filnummer."
    return:
      type: System.Boolean
      description: "Returnerar ett booleskt värde <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> när slutet av filen öppnas för <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> eller sekventiella <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> har uppnåtts."
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en uppräkning som representerar filläget för filer som öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ger bättre produktivitet och prestanda i i/o-filåtgärder än den <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;> </xref>funktion. Se <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>för mer information.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Den här funktionen returnerar en uppräkning som representerar filläget för filer som öppnas med hjälp av den `FileOpen` funktion."
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. Ett giltigt filnummer."
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "Följande uppräkningsvärdena anger åtkomstläge för filen:       <table><tbody><tr><td> Värde       </td><td> Läge       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Avslutar indata/utdata (I/O) till en fil med det <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>får du bättre produktivitet och prestanda i / o-åtgärder. Se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> för mer information."
  remarks: "Den `FileClose` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns [så: läsa Text från filer med en StreamReader](~/add/includes/ajax-current-ext-md.md),[så här: skriva Text till filer med en StreamWriter](~/add/includes/ajax-current-ext-md.md), och [genomgång: hantera filer och kataloger i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Om du utelämnar `FileNumbers`, alla aktiva filer öppnas av den `FileOpen` funktionen stängs.       När du stänger filer som har öppnats för `Output` eller `Append`, slutgiltig buffert på utdata skrivs till operativsystemet bufferten för den filen. Alla buffertutrymme som är kopplade till den stängda filen släpps.       När den `FileClose` funktion körs, associering av en fil med dess fil number avslutas."
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "Valfritt. Parametermatris 0 eller fler kanaler som ska stängas."
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>finns inte."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kopierar en fil. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>. Se <xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>för mer information.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "Om du försöker använda den `FileCopy` fungerar på en öppen fil på ett fel uppstår.       `FileCopy`kräver fullständigt förtroende ska fungera på den lokala enheten."
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger namnet på filen som ska kopieras. `Source`kan omfatta katalog eller mapp och enheten på källfilen."
    - id: Destination
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger målfilens namn. `Destination`kan omfatta katalog eller mapp och enhet för målfilen."
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>eller <code>Destination</code> är ogiltig eller har inte angetts."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen är redan öppen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Filen finns inte."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref> -värde som anger det datum och tidpunkt som en fil har skrivits till. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>. Mer information finns i<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger ett filnamn. `PathName`kan omfatta katalogen eller mappen och enheten."
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>värde som anger datumet och tid för en fil skapades eller senast ändrades."
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>är ogiltigt eller innehåller jokertecken."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Målfilen finns inte."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Boolean
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Byte
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Char
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.DateTime
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Decimal
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Double
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int16
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int32
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int64
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Single
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.ValueType
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.String
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Valfritt. Gäller endast när du skriver en sträng. Anger om du vill skriva en beskrivning för strängen som beskriver längden som inte två byte. Standardvärdet är <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Array
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Valfritt. Gäller endast när du skriver en matris. Anger om matrisen är behandlas som dynamiska och om en matris beskrivning som beskriver storlek och gränserna för matrisen är nödvändiga."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Valfritt. Gäller endast när du skriver en sträng. Anger om du vill skriva en beskrivning för strängen som beskriver längden som inte två byte. Standardvärdet är <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser in data från en öppen fil i en variabel.  Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Object
      description: "Obligatoriskt. Giltigt variabelnamn som data läses."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilken läsning startar."
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> värde som anger längden på en fil i byte. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Om den angivna filen är öppen när den `FileLen` funktionen anropas, det värde som representerar storleken på filen när den har öppnats.      > [!NOTE] > Så här skaffar du den aktuella längden på en öppen fil på `LOF` funktion."
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger en fil. `PathName`kan omfatta katalogen eller mappen och enheten."
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>värde som anger längden på en fil i byte."
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Filen finns inte."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Öppnar en fil för indata eller utdata. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `FileOpen` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Du måste öppna en fil innan alla i/o-åtgärder kan utföras på den. `FileOpen`allokerar en buffert för i/o till filen och anger läget för åtkomst till bufferten.      > [!IMPORTANT] > Vid skrivning till en fil, ett program kan behöva skapa en fil om filen som ska skriva inte finns. Om du vill göra det behöver behörighet för katalogen där filen kommer att skapas. Men om fil som anges av `FileName` finns, tillämpningsprogrammet måste `Write` behörighet att endast själva filen. Om det är möjligt, för att förbättra säkerheten, skapa filen under distributionen och bevilja `Write` behörigheten till filen endast, i stället för till hela mappen. För att förbättra säkerheten, skriva data till användarkataloger i stället för till rotkatalogen eller katalogen Program.       Öppna kanalen kan hittas med hjälp av den `FreeFile()` funktion.      > [!IMPORTANT] > Den `FileOpen` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkning, vilket kan påverka körningen i partiellt förtroende situationer. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer. Använd den <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> funktion för att hämta nästa tillgängliga nummer."
    - id: FileName
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger ett filnamn, kan innehålla en katalog eller mapp, och enheten."
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: 'Obligatoriskt. Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> .'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: 'Valfritt. Uppräkning som anger åtgärderna som är tillåtna för den öppna filen: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>, eller <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Som standard <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> .'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: 'Valfritt. Uppräkning som anger de åtgärder som är inte tillåten i den öppna filen av andra processer: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>, och <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Som standard <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> .'
    - id: RecordLength
      type: System.Int32
      description: "Valfritt. Antal mindre än eller lika med 32 767 (byte). Det här värdet är Postlängden för filer som har öppnats för direktåtkomst. För sekventiella filer är det här värdet antalet tecken som buffras."
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Registrera längden är negativt (och inte lika med-1)."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>redan är öppen eller <code>FileName</code> är ogiltig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen`funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Boolean
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Byte
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Char
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.DateTime
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Decimal
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Double
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den`VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int16
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int32
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int64
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen`funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Single
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den`RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.ValueType
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Object
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Object
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.String
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Valfritt. Gäller endast när du skriver en sträng. Anger om du vill skriva till filen i en beskrivning som två byte sträng längd för strängen. Standardvärdet är <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePut` vanligtvis läsa från en fil med hjälp av `FileGet`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, nästa post eller byte efter senast `FileGet` eller `FilePut` fungera eller anges av senaste `Seek` funktionen skrivs.       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePut`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePut`, du behöver göra samma med `FileGet`, och du måste kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePut` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas med alla säkerhet, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      – Om variabeln skrivs är en sträng, `FilePut` skriver du en beskrivning som två byte som innehåller stränglängden och skriver data som går åt till variabeln. Därför postlängd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePut` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePut` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePut` skriver en två byte beskrivning som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris, har du en fråga om att skriva en beskrivning av storlek och dimensioner i matrisen eller inte. Visual Basic 6.0 och tidigare versioner skriva filbeskrivningen för en dynamisk matris men inte för en array med fast storlek. Visual Basic 2005 som standard skriver inte beskrivningen. Om du vill skriva beskrivningen, ange den `ArrayIsDynamic` parameter till `True`. När du skriver matrisen behöver du så kommer att läsas matrisen; Om det kommer att läsas med beskrivningen som måste du skriva beskrivningen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions). Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Till exempel följande matris-deklaration krävs 218 byte när matrisen skrivs till disk.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] - om variabeln skrivs är en annan typ av variabeln (inte en variabel sträng eller ett objekt), `FilePut` skriver variabla data. Registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med längden på de data som skrivs.      - `FilePut` skriver element i strukturer som om var och en skrevs individuellt, förutom att det finns inget utrymme mellan objekt. Den `VBFixedString` attribut kan tillämpas på strängfält i strukturer att ange storleken på strängen när skrivs till disk.          > [!NOTE] > String fält som har fler byte än vad som anges av den `VBFixedString` attributet trunkeras när skrivs till disk, ## binära läge för filer som öppnas i `Binary` läge, de flesta av de `Random` regler tillämpas med vissa undantag. Följande regler för filer som öppnas i `Binary` läge skiljer sig från reglerna för `Random` läge: – `RecordLength` -sats i den `FileOpen` funktionen har ingen effekt. `FilePut`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster.      – För en matris än en matris i en struktur `FilePut` skriver bara data. Ingen beskrivning skrivs.      - `FilePut` skriver strängar med variabel längd som inte är element i strukturer utan två byte lång beskrivning. Antalet skrivna byte är lika med antalet tecken i strängen. Till exempel följande påståenden skriva 11 byte i filen nummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] - skrivning till en fil med hjälp av den `FilePut` funktionen kräver `Write` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Array
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Valfritt. Gäller endast när du skriver en matris. Anger om matrisen är ska behandlas som dynamiska och om du vill skriva en matris beskrivningen för den sträng som beskriver längd."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Valfritt. Gäller endast när du skriver en sträng. Anger om du vill skriva till filen i en beskrivning som två byte sträng längd för strängen. Standardvärdet är <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 och inte lika med-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data från en variabel till en diskfil.  Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `FilePutObject` funktionen används i stället för `FilePut` att undvika tvetydigheter vid kompileringen om typen `Object` skickas i stället för en annan typ, till exempel `Integer`, `Long`, `Short`osv.       `FilePutObject`skriver och läser beskrivningar som beskriver objektet. Om du vill skriva ut den `Variant` typ, `FilePutObject` krävs. När osäkra, om du använder ett objekt för den andra parametern, rekommenderar vi att du alltid använder `FilePutObject` och `FileGetObject`.       `FilePutObject`är endast giltig i `Random` och `Binary` läge.       Data som skrivs med `FilePutObject` vanligtvis läsa från en fil med hjälp av `FileGetObject`.       Den första posten eller byte i en fil är vid position 1 är den andra posten eller byte vid position 2 och så vidare. Om du utelämnar `RecordNumber`, `FilePutObject` skriver nästa post eller byte efter senast `FileGetObject` eller `FilePutObject` funktionen (eller post eller byte som pekar på sist `Seek` funktionen).       Den `StringIsFixedLength` argumentet styr om funktionen tolkar strängar som variabel eller fast längd. `FilePutObject`Beskrivning för längd kan inte skriva om argumentet är `True`. Om du använder `StringIsFixedLength`  =  `True` med `FilePutObject`, du behöver göra samma med `FileGetObject`, och du måste också kontrollera att strängen har initierats med längden förväntades.      ## Slumpmässigt läge för filer som öppnas i `Random` läge följande regler gäller: – om längden på de data som skrivs är mindre än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, `FilePutObject` skriver efterföljande poster på post-length-gränser. Avståndet mellan slutet av en post och starten av nästa post fylls ut med det befintliga innehållet i filen bufferten. Eftersom mängden utfyllnad data inte kan fastställas exakt, är du normalt ha postlängd matchar längden på de data som skrivs. Om längden på de data som skrivs är större än längden som anges i den `RecordLength` -satsen i den `FileOpen` funktion, ett undantag.      -Om variabeln skrivs är ett objekt som innehåller en numerisk typ `FilePutObject` skriver två byte som identifierar den `VarType` för objektet och skriver sedan variabeln. Till exempel när du skriver ett objekt som innehåller ett heltal, `FilePutObject` skriver sex byte: två byte som identifierar objekt som `VarType(`3`)` (`Integer`) och fyra byte som innehåller data. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än det faktiska antalet byte som krävs för att lagra variabeln minst två byte.      -Om variabeln skrivs är ett objekt som innehåller en sträng, `FilePutObject` skriver du en beskrivning av två byte som identifierar den `VarType(`8`)` för objektet, en beskrivning som inte två byte som anger längden på strängen och skrivningar datatypen string. Registrera längd anges av den `RecordLength` parametern i den `FileOpen` funktionen måste vara större än den faktiska längden på strängen minst fyra byte. Om du vill publicera en sträng utan beskrivningen, överför du `True` till den `StringIsFixedLength` parametern och strängen läsa in ska vara rätt längd.      -Om variabeln skrivs är en matris och sedan registrera längd anges av den `RecordLength` -sats i den `FileOpen` funktionen måste vara större än eller lika med summan av alla byte som krävs för att skriva matrisdata och beskrivning för matrisen. Beskrivningen anger prioriteten för matrisen, storlek och nedre gränserna för varje rang. Dess längd är lika med 2 plus 8 gånger antalet dimensioner: (2 + 8 * NumberOfDimensions).      ## Binära läge för filer som öppnas i `Binary` läge, alla den `Random` regler tillämpas, utom: – `RecordLength` -satsen i den `FileOpen` funktionen har ingen effekt. `FilePutObject`skriver alla variabler till disk kontinuerligt, det vill säga utan utfyllnaden mellan poster."
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Object
      description: "Obligatoriskt. Giltigt variabelnamn som innehåller data som skrivs till disk."
    - id: RecordNumber
      type: System.Int64
      description: "Valfritt. Anteckna numret (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> läge filer) eller byte (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge filer) på vilka skrivning startar."
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Tilldelar en linjebredd för utdata till en fil som har öppnats med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion."
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: RecordWidth
      type: System.Int32
      description: "Obligatoriskt. Numeriska uttryck inom intervallet 0 – med 255, som anger hur många tecken som visas på en rad innan en ny rad har startats. Om `RecordWidth` är lika med 0, det finns ingen gräns för längden på en rad. Standardvärdet för `RecordWidth` är 0."
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> värde som representerar nästa filnummer tillgängliga för användning av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion."
  remarks: "Använd `FreeFile` att ange ett filnummer som inte redan används."
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "Returnerar en <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> värde som representerar nästa filnummer tillgängliga för användning av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion."
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Fler än 255 filer används."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref> värde som representerar attribut för en fil, en katalog eller en mapp. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Använd för att fastställa vilka attribut som har angetts i `And` operatorn för att göra en bitvis jämförelse av värdet som returneras av den `GetAttr` funktionen och värdet för attributet enskilda fil som du vill använda. Om resultatet inte är noll har attributet angetts för den namngivna filen. Till exempel returvärdet för följande `And` uttrycket är noll om den `Archive` attributet inte är angett: ```vb#   Result = GetAttr(FName) And vbArchive   ``` noll returneras om den `Archive` -attributet är inställt."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger ett namn för filen, katalogen eller mappen. `PathName`kan innehålla katalogen eller mappen och enheten."
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "Värdet som returneras av <xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;> </xref> är summan av följande uppräkningsvärdena:       <table><tbody><tr><td> Värde       </td><td> Konstant beskrivning       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>Normal.       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>Skrivskyddad.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>Dolda.       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>Systemfil.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>Katalog eller mapp.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>Filen har ändrats sedan den senaste säkerhetskopieringen.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>Filen har ett annat namn.       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Dessa uppräkningar definieras av språket Visual Basic. De kan användas var som helst i koden i stället för de faktiska värdena.      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>är ogiltigt eller innehåller jokertecken."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Målfilen finns inte."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Boolean
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Byte
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Char
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.DateTime
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Decimal
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Double
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int16
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int32
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Int64
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Object
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.Single
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser data från en öppen sekventiella fil och tilldelar variabler data."
  remarks: "Den `Input` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `Input` vanligtvis skrivs till en fil med hjälp av `Write`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en Visual Basic 2005 källfil.       När läsa tilldelas vanlig sträng eller numeriska data variabler utan modifiering. I följande tabell visas hur andra indata behandlas.      |||   |-|-|   | Data | Värdet som tilldelas variabeln |   | Avgränsar kommatecken eller en tom rad | Tom |   | NULL #| `DBNull`|   | #-TRUE eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Datum och tidpunkt som representeras av uttrycket |   |#ERROR `errornumber` #| `errornumber` (variabeln är ett objekt som är märkta som ett fel) |       Om du når slutet av filen medan du mata in ett dataobjekt indata har stoppats och ett fel uppstår.      > [!NOTE] > Den `Input` funktionen inte är lokaliserade. Till exempel i den tyska versionen returneras om du matar in 3,14159, bara 3, eftersom kommatecknet behandlas som en variabel avgränsare i stället för som ett decimaltecken.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `Input` funktionen kräver `Read` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Value
      type: System.String
      description: "Obligatoriskt. Variabeln som tilldelats värdena läsa från filen – får inte vara en matris eller ett objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> -värde som innehåller tecken från en fil som har öppnats i <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `InputString` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med den `InputString` funktion vanligtvis skrivs till en fil med hjälp av `Print` eller `FilePut`. Använd den här funktionen endast med filer som öppnas i `Input` eller `Binary` läge.       Till skillnad från den `Input` funktion, den `InputString` returneras alla tecken. Detta inkluderar kommatecken, vagnreturer, radmatning, citattecken och inledande blanksteg.       Filen har öppnats för `Binary` komma åt ett försök att läsa filen med hjälp av den `InputString` fungera tills `EOF` returnerar `True` genererar ett fel. Använd den `LOF` och `Loc` fungerar i stället för `EOF` när du läser binära filer med hjälp av `InputString`, eller Använd `FileGet` när du använder den `EOF` funktion.      > [!NOTE] > Vid läsning från filer, gör inte säkerhet beslut om innehållet i filen baserat på filnamnstillägg. Exempelvis kanske inte en fil med namnet Form1.vb en källfil i Visual Basic."
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: CharCount
      type: System.Int32
      description: "Obligatoriskt. Ett numeriskt uttryck som anger antalet tecken som ska läsas."
    return:
      type: System.String
      description: "Returnerar <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> -värde som innehåller tecken från en fil som har öppnats i <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> läge. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>finns inte."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Tar bort filer från en disk. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ."
  remarks: "`Kill`har stöd för flera tecken (`*`) och tecken (`?`) jokertecken för att ange flera filer.       **Säkerhetsmeddelande** för att kunna utföra, den `Kill` funktionen kräver `Read` och `PathDiscovery` flaggor för <xref:System.Security.Permissions.FileIOPermission>som ska tilldelas kör kod.</xref:System.Security.Permissions.FileIOPermission> Mer information finns i <xref:System.Security.SecurityException> [åtkomstbehörigheter för kod](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger en eller flera filnamnen som ska tas bort. `PathName`kan innehålla katalogen eller mappen och enheten."
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Mål-filerna öppna."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Rikta fil(er) som inte hittats."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Åtkomst nekas."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Läser en rad från en öppen sekventiella fil och tilldelar den till en <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variabeln."
  remarks: "Den `LineInput` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data läses med `LineInput` vanligtvis skrivs till en fil med hjälp av `Print`.      > [!IMPORTANT] > Vid läsning från filer inte fatta beslut om innehållet i en fil baserat på filnamnstillägg. Exempelvis kanske inte en fil som heter Form1.vb en källfil i Visual Basic.       Den `LineInput` funktionen läser från en fil ett tecken i taget tills den påträffar en radmatning (`Chr(`13`)`) eller transport RETUR eller linjens feed (`Chr(`13`)` + `Chr(`10`)`) sekvens. Vagnretur RETUR eller linjens feed sekvenser hoppas över i stället för läggs till strängen.      > [!IMPORTANT] > Läsning från en fil med hjälp av den `LineInput` funktionen kräver `Read` komma åt från den <xref:System.Security.Permissions.FileIOPermissionAccess>uppräkningen.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    return:
      type: System.String
      description: "Läser en rad från en öppen sekventiella fil och tilldelar den till en <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variabeln."
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Slutet på filen nåddes."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>finns inte."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> värde som anger den aktuella positionen för läsning och skrivning i en öppen fil."
  remarks: "Den `Loc` funktionen är nollbaserade; använder den för att hämta den första byten i en fil returneras 0.       Den `Loc` funktionen tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Nedan beskrivs returvärdet för varje fillägen: |||   |-|-|   | Läget | Returvärde |   | `Random`| Numret på den sista posten läses från eller skrivs till filen. |   | `Sequential`| Den aktuella positionen i dividerat med 128. Dock information som returneras av `Loc` för sekventiella filer är varken används eller behövs. |   | `Binary`| Positionen för den sista byten läsas eller skrivas. |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Alla giltiga <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> filen nummer."
    return:
      type: System.Int64
      description: "Returnerar en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> värde som anger den aktuella positionen för läsning och skrivning i en öppen fil."
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerar åtkomsten av andra processer att hela eller delar av en fil som har öppnats med hjälp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> och <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` och `Unlock` funktioner som används i miljöer där flera processer kanske behöver åtkomst till samma fil.       `Lock`och `Unlock` funktioner används alltid parvis. Argumenten för `Lock` och `Unlock` måste vara identiska.       Om `Record`, eller `FromRecord` och `ToRecord` har inte angetts blir låset för hela filen. Om `Record` enbart anges enskild post blir låst/upplåst.       Om filen har öppnats för sekventiella indata eller utdata, `Lock` och `Unlock` påverkar hela filen, oavsett det angivna intervallet `FromRecord` och`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerar åtkomsten av andra processer att hela eller delar av en fil som har öppnats med hjälp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> och <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` och `Unlock` funktioner som används i miljöer där flera processer kanske behöver åtkomst till samma fil.       `Lock`och `Unlock` funktioner används alltid parvis. Argumenten för `Lock` och `Unlock` måste vara identiska.       Om `Record`, eller `FromRecord` och `ToRecord` har inte angetts blir låset för hela filen. Om `Record` enbart anges enskild post blir låst/upplåst.       Om filen har öppnats för sekventiella indata eller utdata, `Lock` och `Unlock` påverkar hela filen, oavsett det angivna intervallet `FromRecord` och`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Record
      type: System.Int64
      description: "Valfritt. Antal den enda post eller byte att låsa eller låsa upp"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerar åtkomsten av andra processer att hela eller delar av en fil som har öppnats med hjälp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> och <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` och `Unlock` funktioner som används i miljöer där flera processer kanske behöver åtkomst till samma fil.       `Lock`och `Unlock` funktioner används alltid parvis. Argumenten för `Lock` och `Unlock` måste vara identiska.       Om `Record`, eller `FromRecord` och `ToRecord` har inte angetts blir låset för hela filen. Om `Record` enbart anges enskild post blir låst/upplåst.       Om filen har öppnats för sekventiella indata eller utdata, `Lock` och `Unlock` påverkar hela filen, oavsett det angivna intervallet `FromRecord` och`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: FromRecord
      type: System.Int64
      description: "Valfritt. Numret på den första posten eller byte att låsa eller låsa upp."
    - id: ToRecord
      type: System.Int64
      description: "Valfritt. Antal senaste post eller byte att låsa eller låsa upp."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> som representerar storlek i byte för en fil öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Använd den `FileLen` funktion för att hämta längden på en fil som inte är öppen."
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> som innehåller ett giltigt filnummer."
    return:
      type: System.Int64
      description: "Returnerar en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> som representerar storlek i byte för en fil öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skapar en ny katalog. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "Den här funktionen skapas en ny katalog."
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som identifierar katalogen som ska skapas. Den `Path` kan omfatta enheten. Om ingen enhet anges <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref> skapar den nya katalogen på den aktuella enheten."
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>har inte angetts eller är tom."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Åtkomst nekas."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Det finns redan en katalog."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skrivningar visa-formaterade data till en sekventiell fil."
  remarks: "Den `Print` och `PrintLine` funktioner som tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`innehåller inte en radmatning i slutet av en rad. dock `PrintLine` innehåller en radmatning.       Data som skrivs med `Print` vanligtvis läsa från en fil med hjälp av `LineInput` eller `Input`.       Om du utelämnar `Output` för `PrintLine`, en tom rad skrivs till filen, `Print`, inget är utdata. Flera uttryck avgränsade med kommatecken, justeras på fliken gränser, men blandningen kommatecken och `TAB` kan orsaka inkonsekventa resultat.       För `Boolean` data, antingen `True` eller `False` skrivs ut. Den `True` och `False` nyckelord är inte översätta oavsett språkinställningen.       Datumdata skrivs till filen med hjälp av standard kort datumformat identifieras av systemet. När datumet eller komponenten saknas eller noll, endast del förutsatt att skrivas till filen.       Inget skrivs till filen om `Output` data är tom. Men om `Output` är `DBNull`, `Null` skrivs till filen.       För `Error` data, visas utdata som `Error errorcode`. Den `Error` nyckelordet inte översätta oavsett språkinställningen.       Alla data som skrivs till filen med hjälp av `Print` internationellt känner; att informationen är korrekt formaterad med lämpliga decimaltecknet. Om användaren vill utdata för användning av flera språk `Write` ska användas.       Skrivning till en fil med hjälp av den `Print` eller `PrintLine` funktioner kräver `Write` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Output
      type: System.Object[]
      description: "Valfritt. Noll eller flera kommaavgränsad uttryck för att skriva till en fil.       Den `Output` argumentet inställningarna är: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: filläget är ogiltig.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` finns inte."
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skrivningar visa-formaterade data till en sekventiell fil."
  remarks: "Den `Print` och `PrintLine` funktioner som tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`innehåller inte en radmatning i slutet av en rad. dock`PrintLine` innehåller en radmatning.       Data som skrivs med `Print` vanligtvis läsa från en fil med hjälp av `LineInput` eller `Input`.       Om du utelämnar `Output` för `PrintLine`, en tom rad skrivs till filen, `Print`, inget är utdata. Flera uttryck avgränsade med kommatecken, justeras på fliken gränser, men blandningen kommatecken och `TAB` kan orsaka inkonsekventa resultat.       För `Boolean` data, antingen `True` eller `False` skrivs ut. Den `True` och `False` nyckelord är inte översätta oavsett språkinställningen.       Datumdata skrivs till filen med hjälp av standard kort datumformat okänt för systemet. När datumet eller komponenten saknas eller noll, endast del förutsatt att skrivas till filen.       Inget skrivs till filen om `Output` data är tom. Men om `Output` är `DBNull`, `Null` skrivs till filen.       För `Error` data, visas utdata som `Error errorcode`. Den `Error` nyckelordet inte översätta oavsett språkinställningen.       Alla data som skrivs till filen med hjälp av `Print` internationellt känner; att informationen är korrekt formaterad med lämpliga decimaltecknet. Om användaren vill utdata för användning av flera språk `Write` ska användas.       Skrivning till en fil med hjälp av den `Print` eller `PrintLine` funktioner kräver `Write` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Output
      type: System.Object[]
      description: "Valfritt. Noll eller flera kommaavgränsad uttryck för att skriva till en fil.       Den `Output` argumentet inställningarna är: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: filläget är ogiltig.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` finns inte."
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Byter namn på en fil eller katalog. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den`Rename` funktionen byter namn på en fil och flyttar det till en annan katalog om det behövs. Den `Rename` funktion kan flytta en fil för alla enheter, men den kan bara byta namn på en befintlig katalog när båda `NewPath` och `OldPath` finns på samma enhet. `Rename`Det går inte att skapa en ny fil eller katalog.       Med den `Rename` funktionen på en öppen fil genererar ett fel. Du måste stänga en öppen fil innan du byter namn på den. `Rename`argument får inte innehålla flera tecken (*) och jokertecken som enskilt tecken (?).      > [!IMPORTANT] > När du använder `Rename` för att kopiera en fil från en oskyddad plats till en skyddad plats, behåller filen mindre begränsade rättigheter. Kontrollera att du inte introducerar en säkerhetsrisk."
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger den befintliga filnamnet och platsen. `OldPath`kan omfatta katalog och enhet, i filen."
    - id: NewPath
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger den nya filnamnet och platsen. `NewPath`kan omfatta directory och enheten på målplatsen. Filnamnet som anges av `NewPath` får inte redan finnas."
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Sökvägen är ogiltig."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>filen finns inte."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Det går inte att byta namn på till annan enhet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Stänger alla disk filer som har öppnats med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Reset` funktionen stänger alla aktiva filer som öppnas av den `FileOpen` fungerar och har samma funktion som `FileClose()` utan några parametrar."
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Tar bort en befintlig katalog. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "Ett fel uppstår om du försöker använda `RmDir` på en katalog som innehåller filer. Använd den `Kill` funktionen för att ta bort alla filer innan du försöker ta bort en katalog."
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som identifierar katalog eller mapp som ska tas bort. `Path`enheten kan innehålla. Om ingen enhet anges <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref> tar bort katalog på den aktuella enheten."
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>har inte angetts eller är tom."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Målkatalogen innehåller filer."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Katalogen finns inte."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> anger aktuell position för läsning och skrivning i en fil öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion eller anger positionen för nästa läsning och skrivning-åtgärden i en fil öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Returnerar ett värde mellan 1 och 2 147 483 647 (motsvarar 2 ^ 31-1), inklusive.       Nedan beskrivs returvärden för olika fillägen: |||   |-|-|   | Läget | Returvärde |   | `Random`| Antal nästa post läsas eller skrivas |   | `Binary`, `Input`, `Output`, `Append`| Positionen där nästa åtgärd utförs. Den första byten i en fil vid position 1 är den andra byten vid position 2 och så vidare. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> som innehåller ett giltigt filnummer."
    return:
      type: System.Int64
      description: "Returnerar en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> anger aktuell position för läsning och skrivning i en fil öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion eller anger positionen för nästa läsning och skrivning-åtgärden i en fil öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerar en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> anger aktuell position för läsning och skrivning i en fil öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion eller anger positionen för nästa läsning och skrivning-åtgärden i en fil öppnas med hjälp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Returnerar ett värde mellan 1 och 2 147 483 647 (motsvarar 2 ^ 31-1), inklusive.       Nedan beskrivs returvärden för olika fillägen: |||   |-|-|   | Läget | Returvärde |   | `Random`| Antal nästa post läsas eller skrivas |   | `Binary`, `Input`, `Output`, `Append`| Positionen där nästa åtgärd utförs. Den första byten i en fil vid position 1 är den andra byten vid position 2 och så vidare. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> som innehåller ett giltigt filnummer."
    - id: Position
      type: System.Int64
      description: "Obligatoriskt. Nummer i intervallet 1 – 2 147 483 647, inklusive, som anger där nästa läsning och skrivning åtgärden ska ske."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Anger attributinformation för en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Ett fel uppstår vid försök att ange attribut i en öppen fil.       Den `Attributes` argumentet uppräkningsvärden är följande: |||   |-|-|-|   | Värdet | Konstanten | Beskrivning |   | `Normal`|`vbNormal`| Normal (standard). |   | `ReadOnly`|`vbReadOnly`| Skrivskyddad. |   | `Hidden`|`vbHidden`| Dolt. |   | `System`|`vbSystem`| Systemfilen. |   | `Volume`|`vbVolume`| Volymetiketten |   | `Directory`|`vbDirectory`| Katalog eller mapp. |   | `Archive`|`vbArchive`| Filen har ändrats sedan den senaste säkerhetskopieringen. |   | `Alias`|`vbAlias`| Filen har ett annat namn. |      > [!NOTE] > Dessa uppräkningar definieras med språket Visual Basic. De kan användas var som helst i koden i stället för de faktiska värdena."
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "Obligatoriskt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttryck som anger ett filnamn. `PathName`kan innehålla en katalog eller mapp, och enheten."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Obligatoriskt. Konstant eller ett numeriskt uttryck som anger filattribut."
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>typen är ogiltig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Används med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funktion för att placera utdata."
  remarks: "Om `Count` är mindre än utdata linjebredd, den nästa positionen omedelbart efter antalet blanksteg ut. Om`Count` är större än linjebredden utdata `SPC` beräknar den nästa positionen med följande formel: `currentprintposition`(+ (`Count``Mod``width`)) om den aktuella positionen är 24 linjebredden utdata är 80 och du anger till exempel `SPC(`90`)`, nästa utskrifts startar vid position 34 (aktuella positionen + resten av 90/80). Om skillnaden mellan den aktuella positionen och linjebredd utdata är mindre än `Count` (eller `Count` `Mod` *bredd*), `SPC` funktionen hoppar över till början av nästa rad och genererar lagringsutrymmen som är lika med `Count` – (*bredd* – *aktuell position*).      > [!NOTE] > Kontrollera tabular kolumnerna är tillräckligt bred för att möjliggöra breda tecken."
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "Obligatoriskt. Antalet blanksteg som ska infogas innan visas eller skriva ut nästa uttryck i en lista."
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "Används med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funktion för att placera utdata."
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Används med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funktioner att placera utdata."
  remarks: "Om den aktuella positionen på den aktuella raden är större än `Column`, `TAB` hoppar över att värdet i kolumnen motsvarar `Column` på nästa rad.. Om `Column` är mindre än 1 `TAB` flyttar positionen till kolumn 1. Om `Column` är större än linjebredden utdata `TAB` beräknar den nästa positionen med formeln: kolumnen Mod bredd till exempel om *bredd* är 80 och du anger `TAB(`90`)`, nästa utskrifts startar kolumn 10 (resten av 90/80). Om `Column` är mindre än den aktuella positionen utskrift startar på nästa rad på den beräknade positionen. Om den beräknade positionen är större än den aktuella positionen ut utskrift startar till den beräknade positionen på samma linje.       Längst till vänster positionen på en rad är alltid 1. När du använder den `Print` eller `PrintLine` funktioner för att skriva ut till filer, den sista positionen är aktuell kolumnbredd för för utdatafilen som du kan ange den `FileWidth` funktion.       Den `TAB` funktion kan även användas med den `WriteLine` funktion. Den kan inte användas med <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>eller <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Kontrollera tabular kolumnerna är tillräckligt bred för att innehålla wide bokstäver."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Används med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funktioner att placera utdata."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Används med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funktioner att placera utdata."
  remarks: "Om den aktuella positionen på den aktuella raden är större än `Column`, `TAB` hoppar över att värdet i kolumnen motsvarar `Column` på nästa rad.. Om `Column` är mindre än 1 `TAB` flyttar positionen till kolumn 1. Om `Column` är större än linjebredden utdata `TAB` beräknar den nästa positionen med formeln: kolumnen Mod bredd till exempel om *bredd* är 80 och du anger `TAB(`90`)`, nästa utskrifts startar kolumn 10 (resten av 90/80). Om `Column` är mindre än den aktuella positionen utskrift startar på nästa rad på den beräknade positionen. Om den beräknade positionen är större än den aktuella positionen ut utskrift startar till den beräknade positionen på samma linje.       Längst till vänster positionen på en rad är alltid 1. När du använder den `Print` eller `PrintLine` funktioner för att skriva ut till filer, den sista positionen är aktuell kolumnbredd för för utdatafilen som du kan ange den `FileWidth` funktion.       Den `TAB` funktion kan även användas med den `WriteLine` funktion. Den kan inte användas med <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>eller <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Kontrollera tabular kolumnerna är tillräckligt bred för att innehålla wide bokstäver."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "Valfritt. Kolumnnumret flyttas till innan visas eller skriva ut nästa uttryck i en lista. Om det utelämnas används <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref> flyttar insättningspunkten till början av nästa utskrift zonen."
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Används med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funktioner att placera utdata."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerar åtkomsten av andra processer att hela eller delar av en fil som har öppnats med hjälp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> och <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` och `Unlock` funktioner som används i miljöer där flera processer kanske behöver åtkomst till samma fil.       `Lock`och `Unlock` funktioner används alltid parvis. Argumenten för `Lock` och `Unlock` måste vara identiska.       Om `Record`, eller `FromRecord` och `ToRecord` har inte angetts blir låset för hela filen. Om `Record` enbart anges enskild post blir låst/upplåst.       Om filen har öppnats för sekventiella indata eller utdata, `Lock` och `Unlock` påverkar hela filen, oavsett det angivna intervallet `FromRecord` och`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerar åtkomsten av andra processer att hela eller delar av en fil som har öppnats med hjälp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> och <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` och `Unlock` funktioner som används i miljöer där flera processer kanske behöver åtkomst till samma fil.       `Lock`och `Unlock` funktioner används alltid parvis. Argumenten för `Lock` och `Unlock` måste vara identiska.       Om `Record`, eller `FromRecord` och `ToRecord` har inte angetts blir låset för hela filen. Om `Record` enbart anges enskild post blir låst/upplåst.       Om filen har öppnats för sekventiella indata eller utdata, `Lock` och `Unlock` påverkar hela filen, oavsett det angivna intervallet `FromRecord` och`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: Record
      type: System.Int64
      description: "Valfritt. Antal den enda post eller byte att låsa eller låsa upp"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerar åtkomsten av andra processer att hela eller delar av en fil som har öppnats med hjälp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funktion. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funktionen ger bättre produktivitet och prestanda i i/o-filåtgärder än <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> och <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Mer information finns i <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` och `Unlock` funktioner som används i miljöer där flera processer kanske behöver åtkomst till samma fil.       `Lock`och `Unlock` funktioner används alltid parvis. Argumenten för `Lock` och `Unlock` måste vara identiska.       Om `Record`, eller `FromRecord` och `ToRecord` har inte angetts blir låset för hela filen. Om `Record` enbart anges enskild post blir låst/upplåst.       Om filen har öppnats för sekventiella indata eller utdata, `Lock` och `Unlock` påverkar hela filen, oavsett det angivna intervallet `FromRecord` och`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. Ett giltigt filnummer."
    - id: FromRecord
      type: System.Int64
      description: "Valfritt. Numret på den första posten eller byte att låsa eller låsa upp."
    - id: ToRecord
      type: System.Int64
      description: "Valfritt. Antal senaste post eller byte att låsa eller låsa upp."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data till en sekventiell fil. Data som skrivs med <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> vanligtvis läsa från en fil med hjälp av <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "Den `Write` och `WriteLine` funktioner som tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Om du utelämnar `Output`, en tom rad skrivs till filen. Flera uttryck kan avgränsas med kommatecken.       Till skillnad från den `Print` funktion, den `Write` funktionen infogar kommatecken mellan objekt och strängar inom citattecken som de skrivs till filen. Du behöver inte placeras explicit avgränsare i listan. När `Write` används för att skriva data till en fil, enbart numeriskt `Boolean`, datum, null, och `Error` dataformat stöds. Följande universal antaganden följs så att data kan alltid läsa och tolkas på rätt sätt med hjälp av `Input`, oavsett språkinställning:-numeriska data skrivs alltid använder perioden som decimalavgränsaren.      -För `Boolean` data, antingen `#TRUE#` eller `#FALSE#` skrivs ut. Den `True` och `False` nyckelord är inte översätta oavsett språk.      -Datum data skrivs till filen med det universella datumformatet. När datumet eller komponenten saknas eller noll, endast del förutsatt att skrivas till filen.      -Ingenting skrivs till filen om `Output` data är tom. Men för null-data `#NULL#` skrivs.      -För `Error` data, visas utdata som `#ERROR errorcode#`. Den `Error` nyckelord är inte översätta oavsett språk.       `WriteLine`Infogar ett radmatningstecken (det vill säga en vagnretur radmatningstecken, eller `Chr(13) + Chr(10)`), när de skrivs det sista tecknet `Output` till filen.       Du kan bädda in citattecken i en sträng med hjälp av citattecken, eller &quot;&quot;. Till exempel [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ] returnerar en sträng med värdet för `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Skrivning till en fil med hjälp av den `Write` eller `WriteLine` funktioner kräver `Append` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> uttryck som innehåller ett giltigt filnummer."
    - id: Output
      type: System.Object[]
      description: "Valfritt. En eller flera kommaavgränsad uttryck för att skriva till en fil."
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filläget är ogiltigt."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data till en sekventiell fil. Data som skrivs med <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> vanligtvis läsa från en fil med hjälp av <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "Den `Write` och `WriteLine` funktioner som tillhandahålls för bakåtkompatibilitet och kan påverka prestanda. För icke-äldre program i `My.Computer.FileSystem` objektet ger bättre prestanda. Mer information finns i [åtkomst till filen i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Om du utelämnar `Output`, en tom rad skrivs till filen. Flera uttryck kan avgränsas med kommatecken.       Till skillnad från den `Print` funktion, den `Write` funktionen infogar kommatecken mellan objekt och strängar inom citattecken som de skrivs till filen. Du behöver inte placeras explicit avgränsare i listan. När `Write` används för att skriva data till en fil, enbart numeriskt `Boolean`, datum, null, och `Error` dataformat stöds. Följande universal antaganden följs så att data kan alltid läsa och tolkas på rätt sätt med hjälp av `Input`, oavsett språkinställning:-numeriska data skrivs alltid använder perioden som decimalavgränsaren.      -För `Boolean` data, antingen `#TRUE#` eller `#FALSE#` skrivs ut. Den `True` och `False` nyckelord är inte översätta oavsett språk.      -Datum data skrivs till filen med det universella datumformatet. När datumet eller komponenten saknas eller noll, endast del förutsatt att skrivas till filen.      -Ingenting skrivs till filen om `Output` data är tom. Men för null-data `#NULL#` skrivs.      -För `Error` data, visas utdata som `#ERROR errorcode#`. Den `Error` nyckelord är inte översätta oavsett språk.       `WriteLine`Infogar ett radmatningstecken (det vill säga en vagnretur radmatningstecken, eller `Chr(13) + Chr(10)`), när de skrivs det sista tecknet `Output` till filen.       Du kan bädda in citattecken i en sträng med hjälp av citattecken, eller &quot;&quot;. Till exempel [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ] returnerar en sträng med värdet för `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Skrivning till en fil med hjälp av den `Write` eller `WriteLine` funktioner kräver `Append` komma åt från den `FileIOPermissionAccess` uppräkningen. Mer information finns i <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Obligatoriskt. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> uttryck som innehåller ett giltigt filnummer."
    - id: Output
      type: System.Object[]
      description: "Valfritt. En eller flera kommaavgränsad uttryck för att skriva till en fil."
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
