### YamlMime:ManagedReference
items:
- uid: System.Security.SecurityManager
  id: SecurityManager
  children:
  - System.Security.SecurityManager.CheckExecutionRights
  - System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  - System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  - System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  - System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  - System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  - System.Security.SecurityManager.PolicyHierarchy
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  - System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.SavePolicy
  - System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  - System.Security.SecurityManager.SecurityEnabled
  langs:
  - csharp
  name: SecurityManager
  nameWithType: SecurityManager
  fullName: System.Security.SecurityManager
  type: Class
  summary: "Innehåller den huvudsakliga åtkomstpunkten för klasser som interagerar med systemets säkerhet. Den här klassen kan inte ärvas."
  remarks: "Säkerhet innehåller metoder för att komma åt och ändra principen säkerhetskonfiguration. Du kan inte skapa instanser av SecurityManager."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class SecurityManager
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.SecurityManager.CheckExecutionRights
  id: CheckExecutionRights
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
  fullName: System.Security.SecurityManager.CheckExecutionRights
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Hämtar eller anger ett värde som anger om kod måste ha <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref> för att kunna utföra."
  remarks: "Om den här egenskapen är `false`, även kod utan <xref:System.Security.Permissions.SecurityPermissionFlag>kan köra.</xref:System.Security.Permissions.SecurityPermissionFlag> Körningskontrollen är dyrt och kan eliminera fördelarna med lazy princip lösning. Den här egenskapen har angetts för att inaktivera körning kontrollerar vid behov.       En ändring av den här egenskapen sparas inte förrän <xref:System.Security.SecurityManager.SavePolicy%2A>kallas.</xref:System.Security.SecurityManager.SavePolicy%2A> Nya processer påverkas inte ändringen förrän den sparas i registret."
  syntax:
    content: public static bool CheckExecutionRights { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om koden måste ha <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref> för att kunna utföra; annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.CheckExecutionRights*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Den kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  id: CurrentThreadRequiresSecurityContextCapture
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: CurrentThreadRequiresSecurityContextCapture()
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  fullName: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Anger om den aktuella tråden kräver en säkerhet kontexten avbildning om säkerhetsstatusen måste återskapas vid en senare tidpunkt."
  remarks: "Du kan använda metoden CurrentThreadRequiresSecurityContextCapture innan du Cachelagra känsliga data som hämtas efter lyckad säkerhet krav.       Om den <xref:System.Security.CodeAccessPermission.Assert%2A>metoden har anropats högre på stacken, data ska inte cachelagras utan att samla in motsvarande säkerhetskontexten.</xref:System.Security.CodeAccessPermission.Assert%2A> Annars, känsliga data som hämtas under en <xref:System.Security.CodeAccessPermission.Assert%2A>kan bli tillgängliga för kod som inte längre körs med <xref:System.Security.CodeAccessPermission.Assert%2A>på plats.</xref:System.Security.CodeAccessPermission.Assert%2A> </xref:System.Security.CodeAccessPermission.Assert%2A>      > [!IMPORTANT] > Returvärdet är tillförlitlig endast när det är `false`, vilket innebär att tråden inte garanterat kräver en säkerhet kontexten avbildning. Metoden kan returnera true när en avbildning för säkerhet kontexten inte är nödvändigt för att undvika säkerhetsproblem.       CurrentThreadRequiresSecurityContextCapture är säkerhetskritiska eftersom används huvudsakligen är att undvika onödiga säkerhetskontext samlar in, vilket anger att koden använder den är känsliga och måste granskas."
  syntax:
    content: public static bool CurrentThreadRequiresSecurityContextCapture ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Om stacken innehåller inga delvis betrodd programdomäner, inga delvis betrodd sammansättningar och inga aktiva <> </> *> eller <> </> *> modifierare; <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> om CLR inte kan garantera att stacken innehåller inget av dessa."
  overload: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  id: GetStandardSandbox(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: GetStandardSandbox(Evidence)
  nameWithType: SecurityManager.GetStandardSandbox(Evidence)
  fullName: System.Security.SecurityManager.GetStandardSandbox(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Hämtar en behörighetsuppsättning som är säkert att ge till ett program som har den angivna bevisen."
  remarks: "> [!NOTE]> I den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], värden som har visats i `evidence` måste innehålla <xref:System.Security.Policy.Zone?displayProperty=fullName>bevis.</xref:System.Security.Policy.Zone?displayProperty=fullName>   >> I följande tabell visar de behörighetsuppsättningar som returneras för varje zon.      | Zonen | Behörighetsgruppen |   |----------|--------------------|   | <xref:System.Security.SecurityZone>| `FullTrust`|   | <xref:System.Security.SecurityZone>| `LocalIntranet`|   | <xref:System.Security.SecurityZone>| `Internet`|   | <xref:System.Security.SecurityZone>| `Internet`|   | <xref:System.Security.SecurityZone>| Ingen |   | <xref:System.Security.SecurityZone>| Ingen |       Andra bevis som <xref:System.Security.Policy.Url>eller <xref:System.Security.Policy.Site>, kan anses.</xref:System.Security.Policy.Site> </xref:System.Security.Policy.Url> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone>       Returnerade behörighetsgruppen kan användas av en sandbox för att köra programmet. Observera att den här metoden anger inte principen men hjälper en värd att avgöra om behörighetsgruppen som begärs av ett program är rimliga. Den här metoden kan användas för att mappa en zon till en sandbox."
  example:
  - "The following example shows how to use the GetStandardSandbox method to obtain the permission set for a sandboxed application. For more information about running an application in a sandbox, see [How to: Run Partially Trusted Code in a Sandbox](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[sandboxingApis#1](~/add/codesnippet/visualbasic/2aad9996-0182-4c3d-a405-_1.vb)]\n [!code-cs[sandboxingApis#1](~/add/codesnippet/csharp/2aad9996-0182-4c3d-a405-_1.cs)]"
  syntax:
    content: public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Värden bevis och matcha den mot en grupp."
    return:
      type: System.Security.PermissionSet
      description: "En grupp som kan användas som en tilldelningsgrupp för det program som har den angivna bevisen."
  overload: System.Security.SecurityManager.GetStandardSandbox*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>evidence</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  id: GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: GetZoneAndOrigin(ArrayList,ArrayList)
  nameWithType: SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  fullName: System.Security.SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Hämtar den beviljade zonen identitets- och behörighetsgrupper för URL: en identitet för den aktuella sammansättningen."
  remarks: "Det rekommenderade alternativet till den här metoden är att använda Webbadressen och zonen sammansättningsbevis för sammansättningen som körs för att anropa <xref:System.Security.SecurityManager.ResolvePolicy%2A>för varje typ av bevis.</xref:System.Security.SecurityManager.ResolvePolicy%2A> Behörighetsgrupper som returnerades från den <xref:System.Security.SecurityManager.ResolvePolicy%2A>anrop identifiera behörigheterna för sammansättningen som körs baserat på dess zon och URL: en för ursprung.</xref:System.Security.SecurityManager.ResolvePolicy%2A>      > [!NOTE] > Den här medlemmen är en länk behovet av ECMA offentlig nyckel, vilken inte är en giltig kryptografisk nyckel utan en pseudokolumner-nyckel. Länken behovet av nyckeln ECMA pseudokolumner konverteras automatiskt till en länkbegäran för den offentliga nyckeln för Microsoft i .NET Framework. Säkerhetsundantag baseras på den offentliga nyckeln för Microsoft, inte ECMA pseudokolumner nyckeln."
  syntax:
    content: public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);
    parameters:
    - id: zone
      type: System.Collections.ArrayList
      description: "En output-parameter som innehåller en <xref href=&quot;System.Collections.ArrayList&quot;> </xref> av beviljade <xref:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone*>objekt.</xref:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone*>"
    - id: origin
      type: System.Collections.ArrayList
      description: "En output-parameter som innehåller en <xref href=&quot;System.Collections.ArrayList&quot;> </xref> av beviljade <xref href=&quot;System.Security.Permissions.UrlIdentityPermission&quot;> </xref> objekt."
  overload: System.Security.SecurityManager.GetZoneAndOrigin*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Begäran om <xref href=&quot;System.Security.Permissions.StrongNameIdentityPermission&quot;> </xref> misslyckades."
  platform:
  - net462
- uid: System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  id: IsGranted(System.Security.IPermission)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: IsGranted(IPermission)
  nameWithType: SecurityManager.IsGranted(IPermission)
  fullName: System.Security.SecurityManager.IsGranted(IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Anger om en behörigheten anroparen."
  remarks: "Bevilja behörigheter bestäms av principen och skiljer sig från en begäran omfattas åsidosättningar, till exempel en assert. Dessutom testar IsGranted bara bevilja anropa kod sammansättningens, oberoende av andra anropare i stacken."
  syntax:
    content: public static bool IsGranted (System.Security.IPermission perm);
    parameters:
    - id: perm
      type: System.Security.IPermission
      description: "Behörighet att testa mot beviljande av anroparen."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om behörigheterna för anroparen inkludera behörigheten <code> perm </code>, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.IsGranted*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  id: LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: LoadPolicyLevelFromFile(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Belastningar en <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> från den angivna filen."
  syntax:
    content: public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);
    parameters:
    - id: path
      type: System.String
      description: "Fysiska sökvägen till en fil som innehåller informationen om säkerhetsprinciper."
    - id: type
      type: System.Security.PolicyLevelType
      description: "En uppräkning värden som anger vilken typ av principnivån som ska läsas in."
    return:
      type: System.Security.Policy.PolicyLevel
      description: "Läsa in principnivå."
  overload: System.Security.SecurityManager.LoadPolicyLevelFromFile*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Filen som anges av den <code> path </code> parametern finns inte."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Den kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>.       - eller - kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>.       - eller - kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>.       - eller - kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  id: LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: LoadPolicyLevelFromString(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Belastningar en <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> från den angivna strängen."
  syntax:
    content: public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);
    parameters:
    - id: str
      type: System.String
      description: "XML-representation av en principnivå i samma formulär som det visas i en konfigurationsfil."
    - id: type
      type: System.Security.PolicyLevelType
      description: "En uppräkning värden som anger vilken typ av principnivån som ska läsas in."
    return:
      type: System.Security.Policy.PolicyLevel
      description: "Läsa in principnivå."
  overload: System.Security.SecurityManager.LoadPolicyLevelFromString*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>str</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Den <code> str </code> är inte giltig."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Den kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.PolicyHierarchy
  id: PolicyHierarchy
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: PolicyHierarchy()
  nameWithType: SecurityManager.PolicyHierarchy()
  fullName: System.Security.SecurityManager.PolicyHierarchy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Ger en uppräknare för att komma åt säkerhet principhierarki av nivåer, till exempel dator och användarprinciper."
  remarks: "Returnerade uppräknaren ger efterföljande <xref:System.Security.Policy.PolicyLevel>objekt som representerar policy på respektive (dator, användare, enterprise, programdomänen) nivån i hierarkin.</xref:System.Security.Policy.PolicyLevel> Objekten är live principobjekt; ändra de här objekten kan det orsaka oväntade resultat.       Minsta principhierarki består av en datornivå företagsnivå och en användarnivå. Hierarkin innehåller emellertid mer nivåer."
  syntax:
    content: public static System.Collections.IEnumerator PolicyHierarchy ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "En uppräknare för <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> objekt som ska utgöra säkerhet för hierarkin."
  overload: System.Security.SecurityManager.PolicyHierarchy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Den kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  id: ResolvePolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence)
  nameWithType: SecurityManager.ResolvePolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Avgör vilka behörigheter som ska tilldelas till kod baserat på angivna bevis."
  remarks: "Den här metoden anropar principmodulen säkerhet ger bevis på den anropande koden identitet. Resultatet bestäms av säkerhetsprincipen."
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som angivits för att utvärdera princip."
    return:
      type: System.Security.PermissionSet
      description: "En uppsättning behörigheter som kan beviljas av säkerhetssystem."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  id: ResolvePolicy(System.Security.Policy.Evidence[])
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence[])
  nameWithType: SecurityManager.ResolvePolicy(Evidence[])
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Avgör vilka behörigheter som ska tilldelas till kod baserat på angivna bevis."
  remarks: "Den här metoden startar principmodulen säkerhet att förse den med en matris med <xref:System.Security.Policy.Evidence>objekt.</xref:System.Security.Policy.Evidence> Returnerade behörighetsgruppen representerar endast de behörigheter som gäller för varje bevis i matrisen. Dessa behörigheter är likvärdiga eller en delmängd av de behörigheter som princip skulle ha för varje enskild bevis. Den här metoden fungerar som om du utfört en skärningspunkt på resultat för att matcha principen på alla de <xref:System.Security.Policy.Evidence>objekt i matrisen.</xref:System.Security.Policy.Evidence>"
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);
    parameters:
    - id: evidences
      type: System.Security.Policy.Evidence[]
      description: "En matris med bevis objekt som används för att utvärdera princip."
    return:
      type: System.Security.PermissionSet
      description: "En uppsättning behörigheter som är lämplig för alla angivna bevis."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  id: ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Avgör vilka behörigheter som ska tilldelas till kod baserat på angivna bevis och förfrågningar."
  remarks: "Den här metoden startar principmodulen säkerhet, ger det bevis på den anropande koden identitet och en uppsättning behörigheter koden begäranden. Resultatet bestäms av säkerhetsprincipen. Den här metoden returnerar en uppsättning behörigheter som ges av säkerhetssystem och returnerar en uppsättning behörigheter som skulle avvisas som en utdataparameter. Gällande beviljade behörigheter är de i uppsättningen som beviljades som inte ingår i uppsättningen nekas."
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som angivits för att utvärdera princip."
    - id: reqdPset
      type: System.Security.PermissionSet
      description: "Behörigheterna som krävs av koden måste köras."
    - id: optPset
      type: System.Security.PermissionSet
      description: "De valfria behörigheter som ska användas om beviljad men inte behövs att köra koden."
    - id: denyPset
      type: System.Security.PermissionSet
      description: "De nekade behörigheterna som aldrig ges till koden även om principen annars tillåter den."
    - id: denied
      type: System.Security.PermissionSet
      description: "En output-parameter som innehåller en uppsättning behörigheter som inte beviljats."
    return:
      type: System.Security.PermissionSet
      description: "En uppsättning behörigheter som ges av säkerhetssystem."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "Gruppolicy inte att bevilja lägsta behörighet som anges av den <code> reqdPset </code> parameter."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  id: ResolvePolicyGroups(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicyGroups(Evidence)
  nameWithType: SecurityManager.ResolvePolicyGroups(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicyGroups(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Hämtar en samling grupper matchar de angivna bevis."
  remarks: "Den här metoden är användbar i analysera hur en angiven principkonfiguration fungerar med specifika typer av bevis.       Grupper som ska returneras från alla tillämpliga nivåer i hierarkin för principen som matchar den `evidence` parameter."
  syntax:
    content: public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Det visar mot principen ska utvärderas."
    return:
      type: System.Collections.IEnumerator
      description: "En uppräkning av en uppsättning grupper matchar bevis."
  overload: System.Security.SecurityManager.ResolvePolicyGroups*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  id: ResolveSystemPolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolveSystemPolicy(Evidence)
  nameWithType: SecurityManager.ResolveSystemPolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolveSystemPolicy(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Avgör vilka behörigheter som ska tilldelas till kod baserat på den angivna bevis undantag för principen för den <xref href=&quot;System.AppDomain&quot;> </xref> nivå."
  remarks: "Den här metoden anropar principmodulen säkerhet och ger bevis på den anropande koden identitet. Resultatet bestäms av datorns säkerhetsprinciper utan någon <xref:System.AppDomain>princip.</xref:System.AppDomain>"
  syntax:
    content: public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som angivits för att utvärdera princip."
    return:
      type: System.Security.PermissionSet
      description: "En uppsättning behörigheter som kan beviljas av säkerhetssystem."
  overload: System.Security.SecurityManager.ResolveSystemPolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.SavePolicy
  id: SavePolicy
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SavePolicy()
  nameWithType: SecurityManager.SavePolicy()
  fullName: System.Security.SecurityManager.SavePolicy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Sparar ändrade principen säkerhetstillstånd."
  remarks: "Den här metoden sparar principen som exponeras av <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, och andra klasser som representerar konfigurationen av säkerhetsprincipen.</xref:System.Security.Policy.PolicyLevel> </xref:System.Security.SecurityManager.PolicyHierarchy%2A> Om den här metoden anropas principobjekt ändringar sparas inte och påverkar inte efterföljande program körs."
  syntax:
    content: public static void SavePolicy ();
    parameters: []
  overload: System.Security.SecurityManager.SavePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Den kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  id: SavePolicyLevel(System.Security.Policy.PolicyLevel)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SavePolicyLevel(PolicyLevel)
  nameWithType: SecurityManager.SavePolicyLevel(PolicyLevel)
  fullName: System.Security.SecurityManager.SavePolicyLevel(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Sparar ändrade principen säkerhetsnivån lästs in med <xref:System.Security.SecurityManager.LoadPolicyLevelFromFile*>.</xref:System.Security.SecurityManager.LoadPolicyLevelFromFile*>"
  remarks: "Den <xref:System.Security.Policy.PolicyLevel>kommer att sparas på samma plats som den har lästs in.</xref:System.Security.Policy.PolicyLevel>"
  syntax:
    content: public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);
    parameters:
    - id: level
      type: System.Security.Policy.PolicyLevel
      description: "Principobjektet för nivå som ska sparas."
  overload: System.Security.SecurityManager.SavePolicyLevel*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Den kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den här metoden använder kod kodåtkomstsäkerhet (CAS) åtkomstprincipen som är föråldrade i den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Om du vill aktivera CAS-principen för kompatibilitet med tidigare versioner av .NET Framework använder den [ &lt;legacyCasPolicy&gt; elementet](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.SecurityEnabled
  id: SecurityEnabled
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
  fullName: System.Security.SecurityManager.SecurityEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Hämtar eller anger ett värde som anger om säkerhet är aktiverad."
  remarks: "Den här egenskapen används av den [Caspol.exe (Code Access princip säkerhetsverktyget)](~/add/includes/ajax-current-ext-md.md) `-security` (`-s`) alternativet att inaktivera kodbaserad säkerhet.              SecurityEnabled är ett sätt för administratörer att inaktivera kodåtkomstsäkerhet. När kodåtkomstsäkerhet inaktiveras att alla krav för åtkomst av koden. Effektivt, ger detta all kod `FullTrust`. Inaktivera kodåtkomstsäkerhet kringgår systemets säkerhet så att kod kan utföra något bättre än motsvarande säkerhet princip beviljande `FullTrust` för all kod. Den här egenskapen inaktivera inte rollbaserad säkerhet. Därför <xref:System.Security.Permissions.PrincipalPermission>krav påverkas inte.</xref:System.Security.Permissions.PrincipalPermission>      > [!CAUTION] > Inaktiverat kodåtkomstsäkerhet kan systemet sårbar för angrepp av skadlig kod, till exempel virus och maskar. Inaktivera kodåtkomstsäkerhet blockerar inte förvaltad kod körs på något sätt automatiskt. IT endast orsaker förvaltad kod ska köras utan begränsning av code access security system och bör endast göras med försiktighet extrema. Stänga av säkerhet för att få extra prestanda bör endast göras när andra säkerhetsmetoder som har vidtagits för att skydda datorn. Exempel på andra säkerhetsåtgärder inkluderar kopplar från offentliga nätverk, fysiskt säkra datorer, och så vidare.       En ändring av den här egenskapen inte beständig i registret förrän <xref:System.Security.SecurityManager.SavePolicy%2A>kallas.</xref:System.Security.SecurityManager.SavePolicy%2A> Nya processer påverkas inte ändringen förrän den sparas i registret. Ändra värdet för den här egenskapen i en process som körs ändras inte nödvändigtvis tillståndet på förväntat sätt. För att säkerställa att ändringarna börjar gälla, måste du anropa <xref:System.Security.SecurityManager.SavePolicy%2A>och starta en ny process.</xref:System.Security.SecurityManager.SavePolicy%2A>"
  syntax:
    content: public static bool SecurityEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om Säkerhetsaktiverade; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.SecurityEnabled*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Den kod som anropar den här metoden har inte <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.Security.SecurityManager.CheckExecutionRights
  parent: System.Security.SecurityManager
  isExternal: false
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
  fullName: System.Security.SecurityManager.CheckExecutionRights
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  parent: System.Security.SecurityManager
  isExternal: false
  name: CurrentThreadRequiresSecurityContextCapture()
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  fullName: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture()
- uid: System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetStandardSandbox(Evidence)
  nameWithType: SecurityManager.GetStandardSandbox(Evidence)
  fullName: System.Security.SecurityManager.GetStandardSandbox(Evidence)
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetZoneAndOrigin(ArrayList,ArrayList)
  nameWithType: SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  fullName: System.Security.SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
- uid: System.Collections.ArrayList
  parent: System.Collections
  isExternal: false
  name: ArrayList
  nameWithType: ArrayList
  fullName: System.Collections.ArrayList
- uid: System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  parent: System.Security.SecurityManager
  isExternal: false
  name: IsGranted(IPermission)
  nameWithType: SecurityManager.IsGranted(IPermission)
  fullName: System.Security.SecurityManager.IsGranted(IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromFile(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.PolicyLevelType
  parent: System.Security
  isExternal: false
  name: PolicyLevelType
  nameWithType: PolicyLevelType
  fullName: System.Security.PolicyLevelType
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromString(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
- uid: System.Security.SecurityManager.PolicyHierarchy
  parent: System.Security.SecurityManager
  isExternal: false
  name: PolicyHierarchy()
  nameWithType: SecurityManager.PolicyHierarchy()
  fullName: System.Security.SecurityManager.PolicyHierarchy()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence)
  nameWithType: SecurityManager.ResolvePolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence)
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence[])
  nameWithType: SecurityManager.ResolvePolicy(Evidence[])
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence[])
- uid: System.Security.Policy.Evidence[]
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence[]
  spec.csharp:
  - uid: System.Security.Policy.Evidence
    name: Evidence
    nameWithType: Evidence
    fullName: Evidence[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
- uid: System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicyGroups(Evidence)
  nameWithType: SecurityManager.ResolvePolicyGroups(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicyGroups(Evidence)
- uid: System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolveSystemPolicy(Evidence)
  nameWithType: SecurityManager.ResolveSystemPolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolveSystemPolicy(Evidence)
- uid: System.Security.SecurityManager.SavePolicy
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicy()
  nameWithType: SecurityManager.SavePolicy()
  fullName: System.Security.SecurityManager.SavePolicy()
- uid: System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicyLevel(PolicyLevel)
  nameWithType: SecurityManager.SavePolicyLevel(PolicyLevel)
  fullName: System.Security.SecurityManager.SavePolicyLevel(PolicyLevel)
- uid: System.Security.SecurityManager.SecurityEnabled
  parent: System.Security.SecurityManager
  isExternal: false
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
  fullName: System.Security.SecurityManager.SecurityEnabled
- uid: System.Security.SecurityManager.CheckExecutionRights*
  parent: System.Security.SecurityManager
  isExternal: false
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture*
  parent: System.Security.SecurityManager
  isExternal: false
  name: CurrentThreadRequiresSecurityContextCapture
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture
- uid: System.Security.SecurityManager.GetStandardSandbox*
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetStandardSandbox
  nameWithType: SecurityManager.GetStandardSandbox
- uid: System.Security.SecurityManager.GetZoneAndOrigin*
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetZoneAndOrigin
  nameWithType: SecurityManager.GetZoneAndOrigin
- uid: System.Security.SecurityManager.IsGranted*
  parent: System.Security.SecurityManager
  isExternal: false
  name: IsGranted
  nameWithType: SecurityManager.IsGranted
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile*
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromFile
  nameWithType: SecurityManager.LoadPolicyLevelFromFile
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString*
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromString
  nameWithType: SecurityManager.LoadPolicyLevelFromString
- uid: System.Security.SecurityManager.PolicyHierarchy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: PolicyHierarchy
  nameWithType: SecurityManager.PolicyHierarchy
- uid: System.Security.SecurityManager.ResolvePolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy
  nameWithType: SecurityManager.ResolvePolicy
- uid: System.Security.SecurityManager.ResolvePolicyGroups*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicyGroups
  nameWithType: SecurityManager.ResolvePolicyGroups
- uid: System.Security.SecurityManager.ResolveSystemPolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolveSystemPolicy
  nameWithType: SecurityManager.ResolveSystemPolicy
- uid: System.Security.SecurityManager.SavePolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicy
  nameWithType: SecurityManager.SavePolicy
- uid: System.Security.SecurityManager.SavePolicyLevel*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicyLevel
  nameWithType: SecurityManager.SavePolicyLevel
- uid: System.Security.SecurityManager.SecurityEnabled*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
