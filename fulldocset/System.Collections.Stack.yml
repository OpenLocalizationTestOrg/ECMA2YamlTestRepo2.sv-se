### YamlMime:ManagedReference
items:
- uid: System.Collections.Stack
  id: Stack
  children:
  - System.Collections.Stack.#ctor
  - System.Collections.Stack.#ctor(System.Collections.ICollection)
  - System.Collections.Stack.#ctor(System.Int32)
  - System.Collections.Stack.Clear
  - System.Collections.Stack.Clone
  - System.Collections.Stack.Contains(System.Object)
  - System.Collections.Stack.CopyTo(System.Array,System.Int32)
  - System.Collections.Stack.Count
  - System.Collections.Stack.GetEnumerator
  - System.Collections.Stack.IsSynchronized
  - System.Collections.Stack.Peek
  - System.Collections.Stack.Pop
  - System.Collections.Stack.Push(System.Object)
  - System.Collections.Stack.Synchronized(System.Collections.Stack)
  - System.Collections.Stack.SyncRoot
  - System.Collections.Stack.ToArray
  langs:
  - csharp
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
  type: Class
  summary: "Representerar en enkel senaste in first out (LIFO) icke-generisk samling objekt."
  remarks: "Den allmänna versionen av den här samlingen finns <xref:System.Collections.Generic.Stack%601?displayProperty=fullName>.</xref:System.Collections.Generic.Stack%601?displayProperty=fullName>       En hög kapacitet är antalet element i stacken kan innehålla. Som läggs till i en grupp, ökas automatiskt kapaciteten som krävs genom omfördelning.       Om <xref:System.Collections.Stack.Count%2A>är mindre än kapaciteten för stacken, <xref:System.Collections.Stack.Push%2A>är en O(1) åtgärd.</xref:System.Collections.Stack.Push%2A> </xref:System.Collections.Stack.Count%2A> Om kapaciteten måste ökas för att anpassa det nya elementet <xref:System.Collections.Stack.Push%2A>blir en O (`n`) igen, där `n` är <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A> </xref:System.Collections.Stack.Push%2A> <xref:System.Collections.Stack.Pop%2A>är en O(1)-åtgärd.</xref:System.Collections.Stack.Pop%2A>       Stacken accepterar `null` som ett giltigt värde och tillåter dubblettelement."
  example:
  - "The following example shows how to create and add values to a Stack and how to display its values.  \n  \n [!code-cs[Classic Stack Example#1](~/add/codesnippet/csharp/t-system.collections.stack_1.cs)]\n [!code-vb[Classic Stack Example#1](~/add/codesnippet/visualbasic/t-system.collections.stack_1.vb)]\n [!code-cpp[Classic Stack Example#1](~/add/codesnippet/cpp/t-system.collections.stack_1.cpp)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Stack : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor
  id: '#ctor'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initierar en ny instans av den <xref href=&quot;System.Collections.Stack&quot;> </xref> klass som är tom och inledande standardkapaciteten."
  remarks: "Kapaciteten för en <xref:System.Collections.Stack>är antalet element som det <xref:System.Collections.Stack>kan innehålla.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Som läggs till i en <xref:System.Collections.Stack>, ökas automatiskt kapaciteten som krävs av omallokera den interna matrisen.</xref:System.Collections.Stack>       Om storleken på samlingen kan vara eliminerar att ange den inledande kapaciteten behovet av att genomföra ett antal storleksändringar när du lägger till element i <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Den här konstruktorn är en O(1)-åtgärd."
  syntax:
    content: public Stack ();
    parameters: []
  overload: System.Collections.Stack.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initierar en ny instans av den <xref href=&quot;System.Collections.Stack&quot;> </xref> klass som innehåller element som kopieras från den angivna samlingen och har samma inledande kapacitet som antalet element kopieras."
  remarks: "Kapaciteten för en <xref:System.Collections.Stack>är antalet element som det <xref:System.Collections.Stack>kan innehålla.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Som läggs till i en <xref:System.Collections.Stack>, ökas automatiskt kapaciteten som krävs av omallokera den interna matrisen.</xref:System.Collections.Stack>       Om storleken på samlingen kan vara eliminerar att ange den inledande kapaciteten behovet av att genomföra ett antal storleksändringar när du lägger till element i <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Elementen kopieras till <xref:System.Collections.Stack>i samma ordning som de läses av <xref:System.Collections.IEnumerator>i <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Stack>       Den här konstruktorn är en O (`n`) igen, där `n` är antalet element i `col`."
  syntax:
    content: public Stack (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "Den <xref:System.Collections.ICollection>att kopiera element från.</xref:System.Collections.ICollection>"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initierar en ny instans av den <xref href=&quot;System.Collections.Stack&quot;> </xref> klass som är tom och har den angivna inledande kapaciteten eller inledande standardkapaciteten, största."
  remarks: "Kapaciteten för en <xref:System.Collections.Stack>är antalet element som det <xref:System.Collections.Stack>kan innehålla.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Som läggs till i en <xref:System.Collections.Stack>, ökas automatiskt kapaciteten som krävs av omallokera den interna matrisen.</xref:System.Collections.Stack>       Om storleken på samlingen kan vara eliminerar att ange den inledande kapaciteten behovet av att genomföra ett antal storleksändringar när du lägger till element i <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Den här konstruktorn är en O (`n`) igen, där `n` är `initialCapacity`."
  syntax:
    content: public Stack (int initialCapacity);
    parameters:
    - id: initialCapacity
      type: System.Int32
      description: "Det ursprungliga numret för element som det <xref href=&quot;System.Collections.Stack&quot;> </xref> kan innehålla."
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>initialCapacity</code>är mindre än noll."
  platform:
  - net462
- uid: System.Collections.Stack.Clear
  id: Clear
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Tar bort alla objekt från den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "<xref:System.Collections.Stack.Count%2A>är angivet till noll och släpps också referenser till andra objekt från element i mängden.</xref:System.Collections.Stack.Count%2A>       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Stack>.  \n  \n [!code-cpp[Classic Stack.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sta_5_1.cpp)]\n [!code-vb[Classic Stack.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_5_1.vb)]\n [!code-cs[Classic Stack.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sta_5_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Stack.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Clone
  id: Clone
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Skapar en lite kopia av den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "En lite kopia av en samling kopieras endast element i mängden, om de är referenstyper eller värdetyper, men kopierar inte de objekt som referenserna refererar till. Referenserna i den nya samlingen pekar på samma objekt som refererar till i samlingen ursprungliga pekar på.       Däremot en djup kopia av en samling kopierar elementen och allt direkt eller indirekt refereras av elementen.       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "En lite kopia av den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Anger om det är ett element i den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Den här metoden anger likheten genom att anropa den <xref:System.Object.Equals%2A?displayProperty=fullName>metoden.</xref:System.Object.Equals%2A?displayProperty=fullName>       Den här metoden utförs en linjär sökning. den här metoden är därför en O (`n`) igen, där `n` är <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>       Från och med .NET Framework 2.0 kan den här metoden testar likheten genom att skicka den `obj` argument till den <xref:System.Object.Equals%2A>metoden för enskilda objekt i samlingen.</xref:System.Object.Equals%2A> I tidigare versioner av .NET Framework gjordes detta genom att använda skicka enskilda objekt i samlingen till den <xref:System.Object.Equals%2A>metod för den `obj` argument.</xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Objektet för att hitta i den <xref href=&quot;System.Collections.Stack&quot;> </xref>. Värdet kan vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, if <code>obj</code> is found in the <xref href=&quot;System.Collections.Stack&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Stack.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopior av <xref href=&quot;System.Collections.Stack&quot;> </xref> till en befintlig endimensionell <xref:System.Array>början från det angivna matrisindexet.</xref:System.Array>"
  remarks: "Elementen kopieras till matrisen i senaste in first out (LIFO) ordning som motsvarar den ordning de element som returneras av en följd av anrop till <xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_6_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_6_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_6_1.cs)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "Den endimensionell <xref:System.Array>som är mål för element som kopieras från <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Array> Den <xref:System.Array>måste ha Nollbaserad indexering.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "Det nollbaserade indexet i `array` vilka kopiera börjar."
  overload: System.Collections.Stack.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>är mindre än noll."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>är multidimensionell.       - eller - antalet element i källan <xref href=&quot;System.Collections.Stack&quot;> </xref> är större än det tillgängliga utrymmet från <code>index</code> till slutet av destinationen <code>array</code>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Typ av källan <xref href=&quot;System.Collections.Stack&quot;> </xref> kan inte omvandlas automatiskt till typ av målet <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Stack.Count
  id: Count
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hämtar antalet element som ingår i den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Kapaciteten är antalet element som det <xref:System.Collections.Stack>kan lagra.</xref:System.Collections.Stack> Antalet är antalet element som finns i <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       Kapaciteten är alltid större än eller lika med Count. Om antalet överstiger kapaciteten när du lägger till element, ökar kapaciteten automatiskt med omallokera den interna matrisen innan du kopierar gamla element och lägga till nya element.       Hämtar värdet för den här egenskapen är en O(1)-åtgärd."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Antalet element i den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Stack
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Returnerar en <xref:System.Collections.IEnumerator>för den <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Collections.IEnumerator>"
  remarks: "[Visual Basic och C#]       Den `foreach` satsen i C#-språk (`for each` i Visual Basic) döljer komplexiteten i uppräknare.  Därför använder `foreach` rekommenderas, i stället för direkt manipulering uppräknaren.       Uppräknare kan användas för att läsa data i samlingen, men de kan inte användas för att ändra den underliggande mängden.       Inledningsvis har uppräknaren placerats före det första elementet i mängden. <xref:System.Collections.IEnumerator.Reset%2A>medför också uppräknaren tillbaka till den här positionen.</xref:System.Collections.IEnumerator.Reset%2A>  I den här positionen <xref:System.Collections.IEnumerator.Current%2A>är odefinierad.</xref:System.Collections.IEnumerator.Current%2A> Därför måste du anropa <xref:System.Collections.IEnumerator.MoveNext%2A>att avancera uppräknaren till det första elementet i mängden innan du läser värdet för <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>returnerar samma objekt förrän antingen <xref:System.Collections.IEnumerator.MoveNext%2A>eller <xref:System.Collections.IEnumerator.Reset%2A>kallas.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Anger <xref:System.Collections.IEnumerator.Current%2A>till nästa element.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Om <xref:System.Collections.IEnumerator.MoveNext%2A>passerar slutet på mängden uppräknaren är placerad efter det sista elementet i mängden och <xref:System.Collections.IEnumerator.MoveNext%2A>returnerar `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> När uppräknaren är på denna position efterföljande anrop till <xref:System.Collections.IEnumerator.MoveNext%2A>också returnera `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Om senast anropet till <xref:System.Collections.IEnumerator.MoveNext%2A>returnerade `false`, <xref:System.Collections.IEnumerator.Current%2A>är odefinierad.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Ange <xref:System.Collections.IEnumerator.Current%2A>att det första elementet i mängden igen, kan du anropa <xref:System.Collections.IEnumerator.Reset%2A>följt av <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       En uppräknare är giltig så länge samlingen förblir oförändrad. Om ändringar görs i samlingen, till exempel att lägga till, ändra eller ta bort element, uppräknaren blir inaktuella och sitt beteende är odefinierad.       Uppräknaren har inte exklusiv åtkomst till samlingen; uppräkning av en samling är därför är inte en trådsäker procedur.  Om du vill garantera tråd under uppräkning, kan du låsa samlingen under hela uppräkningen.  Om du vill tillåta en samling som ska användas av flera trådar för läsning och skrivning, måste du implementera ditt eget synkronisering.       Den här metoden är en O(1)-åtgärd."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Stack&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Stack.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Stack
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hämtar ett värde som anger om åtkomst till den <xref href=&quot;System.Collections.Stack&quot;> </xref> är synkroniserade (trådsäkra)."
  remarks: "Att garantera säkerhet tråd i <xref:System.Collections.Stack>, alla åtgärder måste utföras via adapterprogram returneras av den <xref:System.Collections.Stack.Synchronized%2A>metoden.</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack>       Uppräkning av en samling är är inte en trådsäker procedur. Även när en samling har synkroniserats, kan andra trådar ändå ändra samlingen, vilket gör att uppräknaren att utlösa ett undantag. För att garantera tråd under uppräkning, kan du låsa samlingen under hela uppräkning eller fånga undantag som uppstår till följd av ändringar som gjorts av andra trådar.       Följande kodexempel visar hur du låser en samling med hjälp av den <xref:System.Collections.Stack.SyncRoot%2A>under hela uppräkningen.</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[Klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)][!code-cs[klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)][!code-vb[klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb) ] hämta värdet för den här egenskapen är en O(1)-åtgärd.    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.sta_0_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.sta_0_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.sta_0_2.cs)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, om åtkomst till den <xref href=&quot;System.Collections.Stack&quot;> </xref> är synkroniserade (trådsäkra); annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardvärdet är <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Stack.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Peek
  id: Peek
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Returnerar objektet högst upp i den <xref href=&quot;System.Collections.Stack&quot;> </xref> utan att ta bort den."
  remarks: "Den här metoden liknar <xref:System.Collections.Stack.Pop%2A>metoden, men titt inte ändrar <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Pop%2A>       `null`kan skickas till den <xref:System.Collections.Stack>som platshållare, om det behövs.</xref:System.Collections.Stack> För att skilja mellan ett null-värde och slutet på stacken, kontrollera den <xref:System.Collections.Stack.Count%2A>egenskapen eller catch den <xref:System.InvalidOperationException>, som genereras när den <xref:System.Collections.Stack>är tom.</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       Den här metoden är en O(1)-åtgärd."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_4_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_4_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_4_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "Den <xref:System.Object>överst i den <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref href=&quot;System.Collections.Stack&quot;> </xref> är tom."
  platform:
  - net462
- uid: System.Collections.Stack.Pop
  id: Pop
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Tar bort och returnerar objektet högst upp i den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Den här metoden påminner om den <xref:System.Collections.Stack.Peek%2A>metoden, men <xref:System.Collections.Stack.Peek%2A>inte ändra <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Peek%2A> </xref:System.Collections.Stack.Peek%2A>       `null`kan skickas till den <xref:System.Collections.Stack>som platshållare, om det behövs.</xref:System.Collections.Stack> För att skilja mellan ett null-värde och slutet på stacken, kontrollera den <xref:System.Collections.Stack.Count%2A>egenskapen eller catch den <xref:System.InvalidOperationException>, som genereras när den <xref:System.Collections.Stack>är tom.</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       Den här metoden är en O(1)-åtgärd."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_2_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_2_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_2_1.cpp)]"
  syntax:
    content: public virtual object Pop ();
    parameters: []
    return:
      type: System.Object
      description: "Den <xref:System.Object>tas bort från början av den <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.Pop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref href=&quot;System.Collections.Stack&quot;> </xref> är tom."
  platform:
  - net462
- uid: System.Collections.Stack.Push(System.Object)
  id: Push(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Infogar ett objekt överst i den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Om <xref:System.Collections.Stack.Count%2A>redan är lika med kapaciteten, kapaciteten för den <xref:System.Collections.Stack>ökas genom att omfördela automatiskt den interna matrisen och befintliga element kopieras till den nya matrisen innan du lägger till nya element.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Count%2A>       `null`kan skickas till den <xref:System.Collections.Stack>som platshållare, om det behövs.</xref:System.Collections.Stack> Det finns en plats i stacken och behandlas som ett objekt.       Om <xref:System.Collections.Stack.Count%2A>är mindre än kapaciteten för stacken Push är en O(1) åtgärd.</xref:System.Collections.Stack.Count%2A> Om kapaciteten behöver ökas för att anpassa det nya elementet Push blir en O (`n`) igen, där `n` är <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_1_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_1_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_1_1.cpp)]"
  syntax:
    content: public virtual void Push (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Den <xref:System.Object>att skicka till den <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object> Värdet kan vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Stack.Push*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  id: Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Returnerar ett synkroniserat (trådsäkra) Omslutning för det <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Att garantera säkerhet tråd i <xref:System.Collections.Stack>, alla åtgärder måste göras via den här omslutning.</xref:System.Collections.Stack>       Uppräkning av en samling är är inte en trådsäker procedur. Även när en samling har synkroniserats, kan andra trådar ändå ändra samlingen, vilket gör att uppräknaren att utlösa ett undantag. För att garantera tråd under uppräkning, kan du låsa samlingen under hela uppräkning eller fånga undantag som uppstår till följd av ändringar som gjorts av andra trådar.       Följande kodexempel visar hur du låser en samling med hjälp av den <xref:System.Collections.Stack.SyncRoot%2A>under hela uppräkningen.</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[Klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)][!code-cs[klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)][!code-vb[klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb) ] den här metoden är en O(1)-åtgärd.    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_3_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.sta_3_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.sta_3_2.cs)]"
  syntax:
    content: public static System.Collections.Stack Synchronized (System.Collections.Stack stack);
    parameters:
    - id: stack
      type: System.Collections.Stack
      description: "Den <xref href=&quot;System.Collections.Stack&quot;> </xref> att synkronisera."
    return:
      type: System.Collections.Stack
      description: "En synkroniserade wrapper runt den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.SyncRoot
  id: SyncRoot
  parent: System.Collections.Stack
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hämtar ett objekt som kan användas för att synkronisera åtkomst till den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Så här skapar du en synkroniserade version av den <xref:System.Collections.Stack>, använda den <xref:System.Collections.Stack.Synchronized%2A>metoden.</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack> Härledda klasser kan dock ge sina egna synkroniserade versionen av den <xref:System.Collections.Stack>med egenskapen SyncRoot.</xref:System.Collections.Stack> Synkronisera kod måste utföra åtgärder på SyncRoot av den <xref:System.Collections.Stack>, inte direkt på <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Detta säkerställer att samlingar som är härledda från andra objekt ska fungera korrekt. Mer specifikt den upprätthåller rätt synkronisering med andra trådar samtidigt ändra den <xref:System.Collections.Stack>objekt.</xref:System.Collections.Stack>       Uppräkning av en samling är är inte en trådsäker procedur. Även när en samling har synkroniserats, kan andra trådar ändå ändra samlingen, vilket gör att uppräknaren att utlösa ett undantag. För att garantera tråd under uppräkning, kan du låsa samlingen under hela uppräkning eller fånga undantag som uppstår till följd av ändringar som gjorts av andra trådar.       Följande kodexempel visar hur du låsa den samling som använder SyncRoot under hela uppräkningen.       [!code-cpp[Klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)][!code-cs[klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)][!code-vb[klassiska Stack.IsSynchronized exempel&#2;](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb) ] hämta värdet för den här egenskapen är en O(1)-åtgärd.    "
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "En <xref:System.Object>som kan användas för att synkronisera åtkomst till den <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.ToArray
  id: ToArray
  parent: System.Collections.Stack
  langs:
  - csharp
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopior av <xref href=&quot;System.Collections.Stack&quot;> </xref> till en ny matris."
  remarks: "Elementen kopieras till matrisen i senaste in first out (LIFO) ordning som motsvarar den ordning de element som returneras av en följd av anrop till <xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_0_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_0_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_0_1.cs)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "En ny matris som innehåller kopior av elementen i den <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.ToArray*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Collections.Stack.#ctor
  parent: System.Collections.Stack
  isExternal: false
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Stack.#ctor(System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Stack.Clear
  parent: System.Collections.Stack
  isExternal: false
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
- uid: System.Collections.Stack.Clone
  parent: System.Collections.Stack
  isExternal: false
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
- uid: System.Collections.Stack.Contains(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Stack.Count
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
- uid: System.Collections.Stack.GetEnumerator
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Stack.IsSynchronized
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
- uid: System.Collections.Stack.Peek
  parent: System.Collections.Stack
  isExternal: false
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
- uid: System.Collections.Stack.Pop
  parent: System.Collections.Stack
  isExternal: false
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
- uid: System.Collections.Stack.Push(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
- uid: System.Collections.Stack
  parent: System.Collections
  isExternal: false
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
- uid: System.Collections.Stack.SyncRoot
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
- uid: System.Collections.Stack.ToArray
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Stack.#ctor*
  parent: System.Collections.Stack
  isExternal: false
  name: Stack
  nameWithType: Stack.Stack
- uid: System.Collections.Stack.Clear*
  parent: System.Collections.Stack
  isExternal: false
  name: Clear
  nameWithType: Stack.Clear
- uid: System.Collections.Stack.Clone*
  parent: System.Collections.Stack
  isExternal: false
  name: Clone
  nameWithType: Stack.Clone
- uid: System.Collections.Stack.Contains*
  parent: System.Collections.Stack
  isExternal: false
  name: Contains
  nameWithType: Stack.Contains
- uid: System.Collections.Stack.CopyTo*
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo
  nameWithType: Stack.CopyTo
- uid: System.Collections.Stack.Count*
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
- uid: System.Collections.Stack.GetEnumerator*
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator
  nameWithType: Stack.GetEnumerator
- uid: System.Collections.Stack.IsSynchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
- uid: System.Collections.Stack.Peek*
  parent: System.Collections.Stack
  isExternal: false
  name: Peek
  nameWithType: Stack.Peek
- uid: System.Collections.Stack.Pop*
  parent: System.Collections.Stack
  isExternal: false
  name: Pop
  nameWithType: Stack.Pop
- uid: System.Collections.Stack.Push*
  parent: System.Collections.Stack
  isExternal: false
  name: Push
  nameWithType: Stack.Push
- uid: System.Collections.Stack.Synchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized
  nameWithType: Stack.Synchronized
- uid: System.Collections.Stack.SyncRoot*
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
- uid: System.Collections.Stack.ToArray*
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray
  nameWithType: Stack.ToArray
