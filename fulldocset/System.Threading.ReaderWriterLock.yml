### YamlMime:ManagedReference
items:
- uid: System.Threading.ReaderWriterLock
  id: ReaderWriterLock
  children:
  - System.Threading.ReaderWriterLock.#ctor
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  - System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.Finalize
  - System.Threading.ReaderWriterLock.IsReaderLockHeld
  - System.Threading.ReaderWriterLock.IsWriterLockHeld
  - System.Threading.ReaderWriterLock.ReleaseLock
  - System.Threading.ReaderWriterLock.ReleaseReaderLock
  - System.Threading.ReaderWriterLock.ReleaseWriterLock
  - System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.WriterSeqNum
  langs:
  - csharp
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock
  fullName: System.Threading.ReaderWriterLock
  type: Class
  summary: "Definierar ett lås som har stöd för skrivare för enstaka och flera läsare."
  remarks: "> [!IMPORTANT]> De [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] har två läsare skrivare Lås <xref:System.Threading.ReaderWriterLockSlim>och ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>rekommenderas för alla nya utveckling.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>liknar ReaderWriterLock, men den har förenklad regler för rekursion och för uppgradering och degradering låser upp.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>undviker ofta för potentiella dödläge.</xref:System.Threading.ReaderWriterLockSlim> Dessutom prestanda för <xref:System.Threading.ReaderWriterLockSlim>är betydligt bättre än ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim>       ReaderWriterLock används för att synkronisera åtkomst till en resurs. Vid en given tidpunkt kan samtidiga läsbehörighet för flera trådar eller skrivbehörighet för en enskild tråd. I en situation där en resurs ändras sällan, en `ReaderWriterLock` ger bättre genomströmning än en enkel lock-en i taget, till exempel <xref:System.Threading.Monitor>.</xref:System.Threading.Monitor>       `ReaderWriterLock`fungerar bäst om de flesta åtkomsten är läsning, skrivning är ovanligt och på kort tid. Flera läsare alternativa med enda skrivare så att varken läsare eller skrivare blockeras under långa perioder.      > [!NOTE] > Hålla reader Lås eller writer Lås för långa perioder kommer strypa andra trådar. Överväg att omstrukturering av ditt program för att minimera skrivningar varaktighet för bästa prestanda.       En tråd kan innehålla en läsare Lås eller ett skrivlås, men inte båda samtidigt. I stället för att frigöra ett läslås för att låsa skrivare, kan du använda <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>och <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> </xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Rekursiva lock-begäranden att öka låsningsantalet på ett lås.       Läsare och skrivare köas separat. När en tråd låsa upp ett skrivare, beviljas alla trådar som väntar i läsaren kön på den direkta reader Lås; När alla dessa reader Lås har släppts, den nästa tråden väntan i skrivaren kö, om sådant finns, beviljas writer låset och så vidare. Med andra ord `ReaderWriterLock` ersättare mellan en samling läsare och en skrivare.       När en tråd i kön writer väntar för aktiv läsare Lås frigörs ackumuleras trådar som begär den nya läsaren Lås i läsaren kön. Begäranden godkänns inte trots att de kan dela samtidig åtkomst med befintliga läslås innehavare; Det skyddar skrivare mot obestämd blockering av läsare.       De flesta metoder för att hämta lås på en `ReaderWriterLock` acceptera timeout-värden. Timeout Undvik att använda deadlocks i ditt program. Till exempel kan en tråd låsa skrivare på en resurs och begär sedan ett läslås på en andra resurs. under tiden kan en annan tråd låsa skrivare på den andra resursen och begära ett läslås på först. Såvida inte timeout används trådar dödläge.       Om tidsgränsen upphör att gälla och lock-begäran har inte beviljats, returnerar metoden kontrollen till den anropande tråden genom att <xref:System.ApplicationException>.</xref:System.ApplicationException> En tråd kan fånga undantaget och fastställa åtgärd att vidta nästa.       Timeout anges i millisekunder. Om du använder en <xref:System.TimeSpan?displayProperty=fullName>Om du vill ange timeout-värde, det värde som används är det totala antalet hela millisekunder som representeras av <xref:System.TimeSpan>.</xref:System.TimeSpan> </xref:System.TimeSpan?displayProperty=fullName> Följande tabell visar giltiga timeout-värden i millisekunder.      | Värdet | Beskrivning |   |-----------|-----------------|   | -1 | Tråden väntar tills låset förvärvas, oavsett hur lång tid det tar. Konstanten <xref:System.Threading.Timeout.Infinite>kan användas för metoder som anger heltal för timeout. |   |&0; | Tråden väntar inte att hämta låset.</xref:System.Threading.Timeout.Infinite> Om det inte går att hämta Lås omedelbart, returnerar-metoden. |   | >&0; | Antalet millisekunder. |       Med undantag för -1 tillåts inte negativt timeout-värden. Om du anger ett negativt heltal än -1 används ett timeout-värde på noll i stället. (Det vill säga returnerar-metoden utan väntar, om det inte går att hämta låset omedelbart.) Om du anger en <xref:System.TimeSpan>som representerar ett negativt tal millisekunder än -1, <xref:System.ArgumentOutOfRangeException>genereras.</xref:System.ArgumentOutOfRangeException> </xref:System.TimeSpan>"
  example:
  - "The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#1](~/add/codesnippet/cpp/t-system.threading.reade_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#1](~/add/codesnippet/csharp/t-system.threading.reade_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#1](~/add/codesnippet/visualbasic/t-system.threading.reade_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.#ctor
  id: '#ctor'
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initierar en ny instans av den <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> klass."
  remarks: ''
  example:
  - "The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_0_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_0_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_0_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_0_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_0_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_0_2.vb)]"
  syntax:
    content: public ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  id: AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar en läsare låsa, med hjälp av en <xref:System.Int32>värdet för tidsgränsen.</xref:System.Int32>"
  remarks: "AcquireReaderLock blockerar om en annan tråd har writer lås, eller om minst en tråd väntar på låset writer.      > [!NOTE] > Om den aktuella tråden har redan låset skrivare, inget läslås förvärvas. Låsningsantalet på skrivlås ökas i stället. Detta förhindrar att en tråd blockerar på sin egen skrivlås. Resultatet är exakt samma som anropar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, och ett ytterligare anrop till <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>krävs när du lanserar skrivlås.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`stöder rekursiva läslås begäranden. Det vill säga kan en tråd anropa AcquireReaderLock flera gånger, vilket ökar låsningsantalet varje gång. Du måste anropa <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>en gång för varje gång du anropar `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Alternativt kan du anropa <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>att minska låsningsantalet till noll omedelbart.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Rekursiva lock-begäranden beviljas alltid direkt, utan att placera den begärande tråden i läsaren kön. Rekursiva Lås med försiktighet Undvik att använda blockerar skrivlås begäranden under långa perioder.       Ogiltig timeout-värden finns i <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_6_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_6_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_6_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_6_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_6_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_6_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_6_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_6_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_6_3.vb)]"
  syntax:
    content: public void AcquireReaderLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Tidsgräns i millisekunder."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>upphör att gälla innan en låsbegäran har godkänts."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  id: AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar en läsare låsa, med hjälp av en <xref:System.TimeSpan>värdet för tidsgränsen.</xref:System.TimeSpan>"
  remarks: "<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>blockerar om en annan tråd har writer lås, eller om minst en tråd väntar på låset writer.</xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>      > [!NOTE] > Om den aktuella tråden har redan låset skrivare, inget läslås förvärvas. Låsningsantalet på skrivlås ökas i stället. Detta förhindrar att en tråd blockerar på sin egen skrivlås. Resultatet är exakt samma som anropar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, och ett ytterligare anrop till <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>krävs när du lanserar skrivlås.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`stöder rekursiva läslås begäranden. Det vill säga kan en tråd anropa AcquireReaderLock flera gånger, vilket ökar låsningsantalet varje gång. Du måste anropa <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>en gång för varje gång du anropar `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Alternativt kan du anropa <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>att minska låsningsantalet till noll omedelbart.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Rekursiva lock-begäranden beviljas alltid direkt, utan att placera den begärande tråden i läsaren kön. Rekursiva Lås med försiktighet Undvik att använda blockerar skrivlås begäranden under långa perioder.       Ogiltig timeout-värden finns i <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireReaderLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "En <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> anger timeout-perioden."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>upphör att gälla innan en låsbegäran har godkänts."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Anger ett negativt värde än-1 millisekunder."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  id: AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar skrivaren låsa, med hjälp av en <xref:System.Int32>värdet för tidsgränsen.</xref:System.Int32>"
  remarks: "Den här metoden blockerar om en annan tråd har ett läslås eller skrivlås. En beskrivning av hur finns skrivaren Lås ersättare med flera samtidiga läsare Lås <xref:System.Threading.ReaderWriterLock>klass.</xref:System.Threading.ReaderWriterLock>       En tråd som redan har ett läslås kan låsa den skrivaren i ett av två sätt: genom att släppa läslås innan du anropar AcquireWriterLock eller genom att anropa <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>      > [!CAUTION] > Om en tråd anropar `AcquireWriterLock` medan det fortfarande har ett läslås blockerar på sin egen läslås; om en oändlig timeout anges tråden kommer dödläge. Använd för att undvika sådana deadlocks <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>att avgöra om den aktuella tråden redan har ett läslås.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`stöder rekursiva skrivlås begäranden. Det vill säga en tråd kan anropa `AcquireWriterLock` flera gånger, vilket ökar låsningsantalet varje gång. Du måste anropa <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>en gång för varje gång du anropar `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Alternativt kan du anropa <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>att minska låsningsantalet till noll omedelbart.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Rekursiva lock-begäranden beviljas alltid direkt, utan att placera den begärande tråden i kön writer.       Ogiltig timeout-värden finns i <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_4_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_4_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_4_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_4_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_4_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_4_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_4_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_4_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_4_3.vb)]"
  syntax:
    content: public void AcquireWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Tidsgräns i millisekunder."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>upphör att gälla innan en låsbegäran har godkänts."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  id: AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar skrivaren låsa, med hjälp av en <xref:System.TimeSpan>värdet för tidsgränsen.</xref:System.TimeSpan>"
  remarks: "Den här metoden blockerar om en annan tråd har ett läslås eller skrivlås. En beskrivning av hur finns skrivaren Lås ersättare med flera samtidiga läsare Lås <xref:System.Threading.ReaderWriterLock>klass.</xref:System.Threading.ReaderWriterLock>       En tråd som redan har ett läslås kan låsa den skrivaren i ett av två sätt: genom att släppa läslås innan du anropar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, eller genom att anropa <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>      > [!CAUTION] > Om en tråd anropar `AcquireWriterLock` medan det fortfarande har ett läslås blockerar på sin egen läslås; om en oändlig timeout anges tråden kommer dödläge. Använd för att undvika sådana deadlocks <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>att avgöra om den aktuella tråden redan har ett läslås.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`stöder rekursiva skrivlås begäranden. Det vill säga en tråd kan anropa `AcquireWriterLock` flera gånger, vilket ökar låsningsantalet varje gång. Du måste anropa <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>en gång för varje gång du anropar `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Alternativt kan du anropa <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>att minska låsningsantalet till noll omedelbart.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Rekursiva lock-begäranden beviljas alltid direkt, utan att placera den begärande tråden i kön writer.       Ogiltig timeout-värden finns i <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Den <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> anger timeout-perioden."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>upphör att gälla innan en låsbegäran har godkänts."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Anger ett negativt värde än-1 millisekunder."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  id: AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Anger om skrivaren låset har getts till en tråd eftersom sekvensnumret hämtades."
  remarks: "Du kan använda <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>och `AnyWritersSince` att förbättra programmens prestanda.</xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> Till exempel kan en tråd cachelagra informationen hämtas Håll ett läslås. När du publicerar och senare skapas låset tråden kan använda `AnyWritersSince` att avgöra om andra trådar har skrivits till resursen i tiden, om inte, den cachelagrade informationen kan användas. Den här metoden är användbar om läsning av information som skyddas av låset är dyrt. till exempel köra en databasfråga.       Anroparen måste hålla ett läslås eller ett skrivlås för sekvensnummer ska vara användbar."
  example:
  - "The following code example shows how to use the AnyWritersSince method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_8_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_8_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_8_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_8_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_8_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_8_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_8_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_8_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_8_3.vb)]"
  syntax:
    content: public bool AnyWritersSince (int seqNum);
    parameters:
    - id: seqNum
      type: System.Int32
      description: "Sekvensnummer."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om skrivlås har getts till en tråd eftersom sekvensnumret hämtades; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.AnyWritersSince*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  id: DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Återställer status för aktiveringslås för tråden till de hade innan <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>anropades.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  remarks: "DowngradeFromWriterLock släpper skrivlås, oavsett antalet rekursiva Lås och återställer läslås som hölls tråden innan du uppgraderar till skrivaren låset. Låsningsantalet på läslås har återställts.      > [!NOTE]  >   `DowngradeFromWriterLock` accepterar en som <xref:System.Threading.LockCookie>erhålls genom att anropa <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.LockCookie> Använd inte en `LockCookie` returneras av <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       En tråd blockerar inte när nedgradering från skrivlås, även om andra trådar som väntar på skrivlås, eftersom alla läsare lock-begäranden beviljas när skrivlås släpps."
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_3.vb)]"
  syntax:
    content: public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "En <xref href=&quot;System.Threading.LockCookie&quot;> </xref> returneras av <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  overload: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Tråden har inte skrivlås."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Adressen till <code> lockCookie </code> är en null-pekare."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.Finalize
  id: Finalize
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Säkerställer att frigörs resurser och andra rensningsåtgärder utförs när skräpinsamlingen återtar den <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> objekt."
  remarks: "Skräpinsamlingen anrop Slutför när aktuellt <xref:System.Threading.ReaderWriterLock>objektet är redo att slutföras.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: ~ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  id: IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar ett värde som anger om den aktuella tråden innehåller ett läslås."
  remarks: ''
  example:
  - "The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_1_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_1_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_1_1.cs)]"
  syntax:
    content: public bool IsReaderLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den aktuella tråden innehåller ett läslås; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  id: IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar ett värde som anger om den aktuella tråden har writer-Lås."
  remarks: ''
  example:
  - "The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_0_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_0_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_0_1.cs)]"
  syntax:
    content: public bool IsWriterLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den aktuella tråden innehåller skrivlås; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  id: ReleaseLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Låsa upp, oavsett hur många gånger som tråden har köpt låset."
  remarks: "ReleaseLock Frigör läslås eller skrivlås, oavsett antalet rekursiva Lås. Om du vill återställa tillståndet för låsa, inklusive låsningsantalet skicka <xref:System.Threading.LockCookie>till <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the ReleaseLock method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_1_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_1_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_1_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_1_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_1_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_1_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_1_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_1_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_1_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie ReleaseLock ();
    parameters: []
    return:
      type: System.Threading.LockCookie
      description: "En <xref href=&quot;System.Threading.LockCookie&quot;> </xref> -värde som representerar utgivna låset."
  overload: System.Threading.ReaderWriterLock.ReleaseLock*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  id: ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Minskar antalet låset."
  remarks: "ReleaseReaderLock minskar låset räknas. När antalet når noll, släpps låset.      > [!NOTE] > Om en tråd har skrivlås, anropar `ReleaseReaderLock` har samma effekt som anropar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Om en tråd har inga lås, anropar `ReleaseReaderLock` utlöser <xref:System.ApplicationException>.</xref:System.ApplicationException>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_5_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_5_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_5_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_5_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_5_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_5_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_5_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_5_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_5_3.vb)]"
  syntax:
    content: public void ReleaseReaderLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Tråden har inte någon läsaren eller writer Lås."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  id: ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Minskar låset räkna med writer låset."
  remarks: "ReleaseWriterLock minskar skrivlås räknas. När antalet når noll, släpps skrivlås.      > [!NOTE] > Om en tråd har ett läslås eller inga lås, anropar `ReleaseWriterLock` utlöser <xref:System.ApplicationException>.</xref:System.ApplicationException>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_3_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_3_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_3_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_3_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_3_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_3_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_3_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_3_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_3_3.vb)]"
  syntax:
    content: public void ReleaseWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Tråden har inte skrivlås."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  id: RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Återställer status för aktiveringslås för tråden till den ursprungliga innan du anropar <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>"
  remarks: "Tillståndet återställs med `RestoreLock` innehåller låsningsantalet rekursiv.       En tråd block vid försök att återställa ett läslås när en annan tråd har köpt skrivlås eller om den försöker återställa skrivlås efter att en annan tråd har fått ett läslås eller skrivlås. Eftersom `RestoreLock` accepterar inte en timeout noga för att undvika möjlig deadlocks.      > [!CAUTION] > Innan du anropar `RestoreLock`, kontrollera att du har publicerat alla låsningar som hämtades sedan anropet till <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Till exempel en tråd deadlocks om den får ett läslås, och försök sedan att återställa en tidigare skrivlås. Använd <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>och <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>att identifiera sådana ytterligare Lås.</xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> </xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       Använd inte en <xref:System.Threading.LockCookie>returnerades från <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_2_3.vb)]"
  syntax:
    content: public void RestoreLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "En <xref href=&quot;System.Threading.LockCookie&quot;> </xref> returneras av <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>"
  overload: System.Threading.ReaderWriterLock.RestoreLock*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Adressen till <code> lockCookie </code> är en null-pekare."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  id: UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Uppgraderingar ett läslås till writer låsa, med hjälp av en <xref uid=&quot;langword_csharp_Int32&quot; name=&quot;Int32&quot; href=&quot;&quot;> </xref> värde för timeout-värdet."
  remarks: "När en tråd anropar `UpgradeToWriterLock` reader låset släpps, oavsett låsningsantalet och tråden går till slutet av kön för skrivaren låset. Därför kan andra trådar skriva till resursen innan tråden som begärt uppgraderingen beviljas writer låset.      > [!IMPORTANT] > Timeout-undantagsfel utlöses inte förrän den tråd som anropas metoden UpgradeToWriterLock kan hämta låset läsare. Om det finns inga andra trådar som väntar på låset skrivaren kan sker detta omedelbart. Men om en annan tråd är i kö för skrivaren lock, kan inte tråden som anropas metoden UpgradeToWriterLock hämta reader låset tills alla aktuella läsare har släppt deras lås och en tråd har köpt och publicerat skrivlås. Detta gäller även om den tråd som begärt skrivlås begärt det efter den aktuella tråden anropas metoden UpgradeToWriterLock.       Om du vill återställa låser upp anropa <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>med hjälp av den <xref:System.Threading.LockCookie>som returneras av `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Använd inte detta `LockCookie` med <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       När en tråd har inget läslås kan inte använda `UpgradeToWriterLock`. Använd <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>i stället.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Ogiltig timeout-värden finns i <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_7_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_7_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_7_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/m-system.threading.reade_7_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/m-system.threading.reade_7_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/m-system.threading.reade_7_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_7_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_7_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_7_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Tidsgräns i millisekunder."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>upphör att gälla innan en låsbegäran har godkänts."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  id: UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Uppgraderingar ett läslås till writer låsa, med hjälp av en <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> värde för timeout-värdet."
  remarks: "När en tråd anropar `UpgradeToWriterLock` reader låset släpps, oavsett låsningsantalet och tråden går till slutet av kön för skrivaren låset. Därför kan andra trådar skriva till resursen innan tråden som begärt uppgraderingen beviljas writer låset.      > [!IMPORTANT] > Timeout-undantagsfel utlöses inte förrän den tråd som kallas den <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>metod kan hämta läslås.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Om det finns inga andra trådar som väntar på låset skrivaren kan sker detta omedelbart. Men om en annan tråd är i kö för skrivlås, tråden som anropas av <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>metod kan inte hämta tillbaka Lås för läsare tills alla aktuella läsare har släppt deras lås och en tråd har köpt och publicerat skrivlås.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Detta gäller även om den tråd som begärt skrivlås begärt det efter den aktuella tråden kallas den <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>metoden.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Om du vill återställa låser upp anropa <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>med hjälp av den <xref:System.Threading.LockCookie>som returneras av `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Använd inte detta `LockCookie` med <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       När en tråd har inget läslås kan inte använda `UpgradeToWriterLock`. Använd <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>i stället.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Ogiltig timeout-värden finns i <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Den <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> anger timeout-perioden."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>upphör att gälla innan en låsbegäran har godkänts."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Anger ett negativt värde än-1 millisekunder."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  id: WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar det aktuella sekvensnumret."
  remarks: "De antal ökar för aktivitetssekvensen när en tråd hämtar writer-Lås. Du kan spara sekvensnumret och skicka det till <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>vid ett senare tillfälle om du vill avgöra om andra trådar som har hämtat skrivlås under tiden.</xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>       Du kan använda `WriterSeqNum` att förbättra programmens prestanda. Till exempel kan en tråd cachelagra informationen hämtas Håll ett läslås. När du publicerar och senare skapas låset tråden kan avgöra om andra trådar har skrivs till resursen genom att anropa `AnyWritersSince`; om inte, den cachelagrade informationen kan användas. Den här tekniken är användbart när läsning av information som skyddas av låset är dyrt. till exempel köra en databasfråga.       Anroparen måste hålla ett läslås eller ett skrivlås för sekvensnummer ska vara användbar."
  example:
  - "The following code example shows how to use the WriterSeqNum property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/p-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/p-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/p-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/p-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/p-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/p-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/p-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/p-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/p-system.threading.reade_2_3.vb)]"
  syntax:
    content: public int WriterSeqNum { get; }
    return:
      type: System.Int32
      description: "Det aktuella sekvensnumret."
  overload: System.Threading.ReaderWriterLock.WriterSeqNum*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.Threading.ReaderWriterLock.#ctor
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
- uid: System.Threading.LockCookie
  parent: System.Threading
  isExternal: false
  name: LockCookie
  nameWithType: LockCookie
  fullName: System.Threading.LockCookie
- uid: System.Threading.ReaderWriterLock.Finalize
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
- uid: System.Threading.ReaderWriterLock.#ctor*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock.ReaderWriterLock
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock
  nameWithType: ReaderWriterLock.AcquireReaderLock
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock
  nameWithType: ReaderWriterLock.AcquireWriterLock
- uid: System.Threading.ReaderWriterLock.AnyWritersSince*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince
  nameWithType: ReaderWriterLock.AnyWritersSince
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock
- uid: System.Threading.ReaderWriterLock.Finalize*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize
  nameWithType: ReaderWriterLock.Finalize
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock
  nameWithType: ReaderWriterLock.ReleaseLock
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock
  nameWithType: ReaderWriterLock.ReleaseReaderLock
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock
  nameWithType: ReaderWriterLock.ReleaseWriterLock
- uid: System.Threading.ReaderWriterLock.RestoreLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock
  nameWithType: ReaderWriterLock.RestoreLock
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock
  nameWithType: ReaderWriterLock.UpgradeToWriterLock
- uid: System.Threading.ReaderWriterLock.WriterSeqNum*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
