### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "Tillhandahåller åtkomst till lokala processer och fjärrprocesser och gör att du kan starta och stoppa lokala systemprocesser.       Om du vill bläddra .NET Framework källkoden för den här typen finns i [referenskälla](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Initierar en ny instans av den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> klass."
  remarks: "Om du inte anger den <xref:System.Diagnostics.Process.MachineName%2A>egenskapen, standard är den lokala datorn (&quot;.&quot;).</xref:System.Diagnostics.Process.MachineName%2A>       Har du två alternativ för att associera en ny <xref:System.Diagnostics.Process>komponent med en process på datorn.</xref:System.Diagnostics.Process> Det första alternativet är att använda konstruktorn för att skapa den <xref:System.Diagnostics.Process>komponent, ange lämpliga medlemmar av den <xref:System.Diagnostics.Process.StartInfo%2A>egenskapen och anropa <xref:System.Diagnostics.Process.Start%2A>att associera den <xref:System.Diagnostics.Process>med en ny systemprocess.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> Det andra alternativet är att associera den <xref:System.Diagnostics.Process>med en systemprocess som körs med hjälp av <xref:System.Diagnostics.Process.GetProcessById%2A>eller en av de <xref:System.Diagnostics.Process.GetProcesses%2A>returvärden.</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       Om du använder en `static` överlagring för den <xref:System.Diagnostics.Process.Start%2A>metod för att starta en ny systemprocess, metoden skapar en ny <xref:System.Diagnostics.Process>komponent som associeras med processen.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       När den <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>egenskap är inställd på standardvärdet, `true`, du kan starta program och dokument på ett sätt som liknar med hjälp av den `Run` dialogrutan i Windows `Start` menyn.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> När <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>är `false`, kan du starta endast körbara filer.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       Alla körbara filer som du kan anropa från kommandoraden kan startas på något av två sätt: genom att ange lämplig medlemmarna i den <xref:System.Diagnostics.Process.StartInfo%2A>egenskapen och anropar den <xref:System.Diagnostics.Process.Start%2A>metod utan parametrar eller genom att skicka lämpliga parametern till den `static` <xref:System.Diagnostics.Process.Start%2A>medlem.</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       Du kan skapa en <xref:System.Diagnostics.Process>komponenten med hjälp av konstruktor en av statiskhet <xref:System.Diagnostics.Process.Start%2A>överlagringar eller någon av de <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, eller <xref:System.Diagnostics.Process.GetProcessesByName%2A>metoder.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> När du har gjort det, har du en överblick över den associerade processen. Detta är inte en dynamisk vy som uppdateras automatiskt när processegenskaper har ändrats i minnet. I stället måste du anropa <xref:System.Diagnostics.Process.Refresh%2A>för komponenten att uppdatera den <xref:System.Diagnostics.Process>egenskapsinformation i ditt program.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar basprioriteten för den associerade processen."
  remarks: "BasePriority processens är första prioriteten för trådar som skapas i den associerade processen. Du kan visa information om basprioritet via den Systemövervakaren prioritet Basräknare.       Baserat på tiden förflutna eller andra ökar operativsystemet kan ändra basprioritet när en process ska placeras längre än andra.       Egenskapen BasePriority kan du visa den första prioritet som tilldelas till en process. Eftersom den är skrivskyddad, kan du använda BasePriority för att ange prioritet för processen. Om du vill ändra prioriteten den <xref:System.Diagnostics.Process.PriorityClass%2A>egenskapen.</xref:System.Diagnostics.Process.PriorityClass%2A> BasePriority kan visas med Systemövervakaren, medan den <xref:System.Diagnostics.Process.PriorityClass%2A>inte.</xref:System.Diagnostics.Process.PriorityClass%2A> Både BasePriority och <xref:System.Diagnostics.Process.PriorityClass%2A>kan granskas via programmering.</xref:System.Diagnostics.Process.PriorityClass%2A> Följande tabell visar relationen mellan BasePriority värden och <xref:System.Diagnostics.Process.PriorityClass%2A>värden.</xref:System.Diagnostics.Process.PriorityClass%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "Basprioriteten som har beräknats från den <xref:System.Diagnostics.Process.PriorityClass*>av den associerade processen.</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange den &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; egenskapen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen har avslutats.       - eller - processen har inte startat, så det finns ingen process-ID."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Börjar asynkrona läsåtgärder på den omdirigerade <xref:System.Diagnostics.Process.StandardError*>dataström med programmet.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "Den <xref:System.Diagnostics.Process.StandardError%2A>dataströmmen kan läsas synkront eller asynkront.</xref:System.Diagnostics.Process.StandardError%2A> Metoder som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, och <xref:System.IO.StreamReader.ReadToEnd%2A>utföra synkron läsåtgärder på fel utdataströmmen processens.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Dessa synkron läsa operations inte behöver du göra förrän den associerade <xref:System.Diagnostics.Process>skriver till dess <xref:System.Diagnostics.Process.StandardError%2A>strömma eller stänger dataströmmen.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Däremot BeginErrorReadLine startar asynkrona läsåtgärder på den <xref:System.Diagnostics.Process.StandardError%2A>dataström.</xref:System.Diagnostics.Process.StandardError%2A> Den här metoden aktiverar avsedda händelsehanteraren för strömmad utdata och returnerar omedelbart till anroparen som kan utföra annat arbete när strömmad utdata omdirigeras till händelsehanteraren.       Följ dessa steg för att utföra asynkrona läsåtgärder på <xref:System.Diagnostics.Process.StandardError%2A>för en <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  Lägg till din händelsehanteraren ska den <xref:System.Diagnostics.Process.ErrorDataReceived>händelse.</xref:System.Diagnostics.Process.ErrorDataReceived> Händelsehanteraren måste matcha den <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>delegatsignatur.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Starta <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Anropa BeginErrorReadLine för <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Det här anropet startar asynkrona läsåtgärder <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A>       När asynkrona läsåtgärder start, händelsehanteraren anropas varje gång den associerade <xref:System.Diagnostics.Process>skriver en rad med text till dess <xref:System.Diagnostics.Process.StandardError%2A>dataström.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Du kan avbryta en asynkron läsåtgärd genom att anropa <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> Läsåtgärden kan avbrytas av anroparen eller av händelsehanteraren. När du avbryter, kan du anropa BeginErrorReadLine igen om du vill återuppta asynkrona läsåtgärder.      > [!NOTE] > Du inte kan blanda asynkrona och synkrona läsåtgärder på en omdirigerade dataström. När den omdirigerade dataströmmen en <xref:System.Diagnostics.Process>har öppnats asynkront eller i synkront läge, alla ytterligare Läs-operationer på dataströmmen måste vara i samma läge.</xref:System.Diagnostics.Process> Till exempel inte följer BeginErrorReadLine med ett anrop till <xref:System.IO.StreamReader.ReadLine%2A>på den <xref:System.Diagnostics.Process.StandardError%2A>stream, och vice versa.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> Du kan dock läsa två olika dataströmmar i olika lägen. Du kan till exempel anropa BeginErrorReadLine och sedan anropa <xref:System.IO.StreamReader.ReadLine%2A>för den <xref:System.Diagnostics.Process.StandardOutput%2A>dataström.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Börjar asynkrona läsåtgärder på den omdirigerade <xref:System.Diagnostics.Process.StandardOutput*>dataström med programmet.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "Den <xref:System.Diagnostics.Process.StandardOutput%2A>dataströmmen kan läsas synkront eller asynkront.</xref:System.Diagnostics.Process.StandardOutput%2A> Metoder som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, och <xref:System.IO.StreamReader.ReadToEnd%2A>utföra synkron läsåtgärder på utdataströmmen processens.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Dessa synkron läsa operations inte behöver du göra förrän den associerade <xref:System.Diagnostics.Process>skriver till dess <xref:System.Diagnostics.Process.StandardOutput%2A>strömma eller stänger dataströmmen.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Däremot BeginOutputReadLine startar asynkrona läsåtgärder på den <xref:System.Diagnostics.Process.StandardOutput%2A>dataström.</xref:System.Diagnostics.Process.StandardOutput%2A> Den här metoden aktiverar en avsedda händelsehanteraren för strömmad utdata och returnerar omedelbart till anroparen som kan utföra annat arbete när strömmad utdata omdirigeras till händelsehanteraren.       Följ dessa steg för att utföra asynkrona läsåtgärder på <xref:System.Diagnostics.Process.StandardOutput%2A>för en <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  Lägg till din händelsehanteraren ska den <xref:System.Diagnostics.Process.OutputDataReceived>händelse.</xref:System.Diagnostics.Process.OutputDataReceived> Händelsehanteraren måste matcha den <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>delegatsignatur.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Starta <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Anropa BeginOutputReadLine för <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Det här anropet startar asynkrona läsåtgärder <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A>       När asynkrona läsåtgärder start, händelsehanteraren anropas varje gång den associerade <xref:System.Diagnostics.Process>skriver en rad med text till dess <xref:System.Diagnostics.Process.StandardOutput%2A>dataström.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Du kan avbryta en asynkron läsåtgärd genom att anropa <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> Läsåtgärden kan avbrytas av anroparen eller av händelsehanteraren. När du avbryter, kan du anropa BeginOutputReadLine igen om du vill återuppta asynkrona läsåtgärder.      > [!NOTE] > Du inte kan blanda asynkrona och synkrona läsåtgärder på en omdirigerade dataström. När den omdirigerade dataströmmen en <xref:System.Diagnostics.Process>har öppnats asynkront eller i synkront läge, alla ytterligare Läs-operationer på dataströmmen måste vara i samma läge.</xref:System.Diagnostics.Process> Till exempel inte följer BeginOutputReadLine med ett anrop till <xref:System.IO.StreamReader.ReadLine%2A>på den <xref:System.Diagnostics.Process.StandardOutput%2A>stream, och vice versa.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> Du kan dock läsa två olika dataströmmar i olika lägen. Du kan till exempel anropa BeginOutputReadLine och sedan anropa <xref:System.IO.StreamReader.ReadLine%2A>för den <xref:System.Diagnostics.Process.StandardError%2A>dataström.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avbryter den asynkron läsåtgärd på den omdirigerade <xref:System.Diagnostics.Process.StandardError*>dataström med ett program.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>startar en asynkron läsåtgärd på den <xref:System.Diagnostics.Process.StandardError%2A>dataström.</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead slutar asynkron läsning.       När du avbryter, du kan återuppta asynkron läsåtgärd genom att anropa <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>igen.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       När du anropar CancelErrorRead alla pågående läsåtgärder för <xref:System.Diagnostics.Process.StandardError%2A>har slutförts och sedan händelsehanteraren är inaktiverat.</xref:System.Diagnostics.Process.StandardError%2A> Alla ytterligare omdirigeras utdata till <xref:System.Diagnostics.Process.StandardError%2A>sparas i en buffert.</xref:System.Diagnostics.Process.StandardError%2A> Om du återaktiverar händelsehanterare med ett anrop till <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, sparade utdata skickas till händelsehanteraren och återuppta för asynkrona läsåtgärder.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Om du vill ändra händelsehanteraren innan du fortsätter med asynkrona läsåtgärder måste du ta bort den befintliga händelsehanteraren innan du lägger till nya händelsehanteraren: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] > du inte kan blanda asynkrona och synkrona läsåtgärder på den omdirigerade <xref:System.Diagnostics.Process.StandardError%2A>dataström.</xref:System.Diagnostics.Process.StandardError%2A> När den omdirigerade dataströmmen en <xref:System.Diagnostics.Process>har öppnats asynkront eller i synkront läge, alla ytterligare Läs-operationer på dataströmmen måste vara i samma läge.</xref:System.Diagnostics.Process> Om du avbryter en asynkron läsåtgärd på <xref:System.Diagnostics.Process.StandardError%2A>och behöver läsa från strömmen igen, måste du använda <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>att återuppta asynkrona läsåtgärder.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> Följ inte CancelErrorRead med ett anrop till synkron skrivskyddade metoderna för <xref:System.Diagnostics.Process.StandardError%2A>som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, eller <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref:System.Diagnostics.Process.StandardError*>dataströmmen har inte aktiverats för asynkrona läsåtgärder.</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avbryter den asynkron läsåtgärd på den omdirigerade <xref:System.Diagnostics.Process.StandardOutput*>dataström med ett program.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>startar en asynkron läsåtgärd på den <xref:System.Diagnostics.Process.StandardOutput%2A>dataström.</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead slutar asynkron läsning.       När du avbryter, du kan återuppta asynkrona läsåtgärder genom att anropa <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>igen.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       När du anropar CancelOutputRead alla pågående läsåtgärder för <xref:System.Diagnostics.Process.StandardOutput%2A>har slutförts och sedan händelsehanteraren är inaktiverat.</xref:System.Diagnostics.Process.StandardOutput%2A> Alla ytterligare omdirigeras utdata till <xref:System.Diagnostics.Process.StandardOutput%2A>sparas i en buffert.</xref:System.Diagnostics.Process.StandardOutput%2A> Om du återaktiverar händelsehanterare med ett anrop till <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, sparade utdata skickas till händelsehanteraren och återuppta för asynkrona läsåtgärder.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Om du vill ändra händelsehanteraren innan du fortsätter med asynkrona läsåtgärder måste du ta bort den befintliga händelsehanteraren innan du lägger till nya händelsehanteraren: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] > du inte kan blanda asynkrona och synkrona läsåtgärder på den omdirigerade <xref:System.Diagnostics.Process.StandardOutput%2A>dataström.</xref:System.Diagnostics.Process.StandardOutput%2A> När den omdirigerade dataströmmen en <xref:System.Diagnostics.Process>har öppnats asynkront eller i synkront läge, alla ytterligare Läs-operationer på dataströmmen måste vara i samma läge.</xref:System.Diagnostics.Process> Om du avbryter en asynkron läsåtgärd på <xref:System.Diagnostics.Process.StandardOutput%2A>och behöver läsa från strömmen igen, måste du använda <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>att återuppta asynkrona läsåtgärder.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> Följ inte CancelOutputRead med ett anrop till synkron skrivskyddade metoderna för <xref:System.Diagnostics.Process.StandardOutput%2A>som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, eller <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref:System.Diagnostics.Process.StandardOutput*>dataströmmen har inte aktiverats för asynkrona läsåtgärder.</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Frigör alla resurser som är associerade med den här komponenten."
  remarks: "Close-metoden gör processen att stoppa väntar på Avsluta om den väntade stänger processreferensen och rensar processpecifika egenskaper. Stäng stänger inte standard utgående och inkommande fel läsare och skrivare om de som refererar till externt.      > [!NOTE] > Den <xref:System.Diagnostics.Process.Dispose%2A>Stäng metodanrop.</xref:System.Diagnostics.Process.Dispose%2A> Placera den <xref:System.Diagnostics.Process>objekt i en `using` block omhändertar resurser utan att behöva ringa Stäng.</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Stänger en process som har ett användargränssnitt genom att skicka ett stängningsmeddelande till dess huvudfönstret."
  remarks: "När en process körs, är dess meddelandeloop i tillståndet vänta. Meddelandeloopen körs varje gång ett Windows-meddelande skickas till processen av operativsystemet. Anropar CloseMainWindow skickar en begäran om att nära huvudfönstret som i ett giltigt program stänger underordnade fönster och återkallar alla pågående meddelande slingor för programmet. Begäran om att avsluta processen genom att anropa CloseMainWindow tvingar inte programmet avslutas. Programmet kan be om användarens verifiering innan du avslutar eller kan avvisa avslutas. Om du vill tvinga programmet avslutas, använda den <xref:System.Diagnostics.Process.Kill%2A>metoden.</xref:System.Diagnostics.Process.Kill%2A> Beteendet för CloseMainWindow är identisk med en användare stänga huvudfönstret i ett program med hjälp av systemmenyn. Begäran om att avsluta processen genom att stänga huvudfönstret tvingar därför inte programmet avslutas omedelbart.       Data som redigeras av processen eller resurser som tilldelats processen kan gå förlorad om du anropar <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>Gör en onormal processavslutning och används bara när det behövs.</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow aktiverar en korrekt avslutning av processen och stänger alla fönster, så det är bättre för program med ett gränssnitt. Om CloseMainWindow misslyckas, kan du använda <xref:System.Diagnostics.Process.Kill%2A>att avsluta processen.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>är det enda sättet att avsluta processer som inte har grafiska gränssnitt.</xref:System.Diagnostics.Process.Kill%2A>       Du kan anropa <xref:System.Diagnostics.Process.Kill%2A>och CloseMainWindow endast för processer som körs på den lokala datorn.</xref:System.Diagnostics.Process.Kill%2A> Du kan orsaka processer på fjärrdatorer för att avsluta. Du kan bara visa information för processer som körs på fjärrdatorer."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om stängningsmeddelande skickades; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om den associerade processen inte har en huvudfönstret eller om huvudfönstret inaktiveras (till exempel om en spärrad dialogruta visas)."
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange den &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; egenskapen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen har redan avslutats.       - eller - ingen process har associerats med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt."
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Frigör alla resurser som används av den här processen."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Frisläpp både hanterade och ohanterade resurser. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att släppa endast resurser som inte hanteras."
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar eller anger om den <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> händelsen ska aktiveras när processen avslutas."
  remarks: "Egenskapen EnableRaisingEvents anger om komponenten ska aviseras när operativsystemet har stängts av en process. Egenskapen EnableRaisingEvents används vid asynkron bearbetning för att informera programmet som en processen har avslutats. Om du vill tvinga programmet att synkront vänta på ett avsluta-händelse (vilket gör att bearbetningen av programmet förrän avsluta händelse har inträffat) använder du den <xref:System.Diagnostics.Process.WaitForExit%2A>metoden.</xref:System.Diagnostics.Process.WaitForExit%2A>      > [!NOTE] > Om du använder Visual Studio och dubbelklicka på en <xref:System.Diagnostics.Process>komponenten i projektet, en <xref:System.Diagnostics.Process.Exited>händelsedelegeringen och händelsehanteraren genereras automatiskt.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> Ytterligare kod anges egenskapen EnableRaisingEvents till `false`. Du måste ändra den här egenskapen till `true` för din händelsehanterare som ska köras när den associerade processen avslutas.       När en associerade processen avslutas efter att stänga av operativsystemet antingen via en normal eller onormal avslutning, meddelar operativsystemet varje processkomponenten som processen har associerade, så länge komponentens EnableRaisingEvents värde är `true`. Om en komponent som startats processen komponenten sedan komma åt administrativ information för den associerade processen som lagras av operativsystemet. Denna information inkluderar den <xref:System.Diagnostics.Process.ExitTime%2A>, och i <xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       När den associerade processen avslutas, <xref:System.Diagnostics.Process.Handle%2A>för komponenten längre pekar på en befintlig resurs process.</xref:System.Diagnostics.Process.Handle%2A> I stället kan det användas till operativsystemets information om processen för resursen. Operativsystemet är medveten om att det finns referenser till stängts processer som inte getts ut av <xref:System.Diagnostics.Process>komponenter, så den bevarar de <xref:System.Diagnostics.Process.ExitTime%2A>och <xref:System.Diagnostics.Process.Handle%2A>information i minnet.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Det finns en kostnaden för att se upp för en process för att avsluta. Om EnableRaisingEvents `true`, <xref:System.Diagnostics.Process.Exited>händelsen utlöses när den associerade processen avslutas.</xref:System.Diagnostics.Process.Exited> De procedurer som du har angett för den <xref:System.Diagnostics.Process.Exited>händelse köras vid den tiden.</xref:System.Diagnostics.Process.Exited>       Ibland kan programmet startar en process men behöver inte meddelas om dess avslutas. Ditt program kan exempelvis starta Anteckningar för att tillåta användaren att utföra textredigering men inte längre att använda programmet anteckningar. Du kan välja att inte bli meddelad när processen avslutas eftersom den inte är relevanta för fortsatt drift för ditt program. Ange EnableRaisingEvents till `false` sparar systemresurser."
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> händelsen ska aktiveras när den associerade processen avslutas (via en avsluta eller ett anrop till <xref:System.Diagnostics.Process.Kill*>), annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.Kill*> Standardvärdet är <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Placerar en <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten tillstånd för att interagera med operativsystemet processer som körs i ett särskilt läge genom att aktivera den inbyggda egenskapen <xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;> </xref> i den aktuella tråden."
  remarks: "Vissa operativsystemprocesser köras i ett särskilt läge. Försök att läsa egenskaperna för eller ansluta till de här processerna är inte möjlig såvida inte du har anropat EnterDebugMode på komponenten. Anropa <xref:System.Diagnostics.Process.LeaveDebugMode%2A>när du inte längre behöver åtkomst till dessa processer som körs i särskilda läge.</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inträffar när ett program skriver till sin omdirigerade <xref:System.Diagnostics.Process.StandardError*>dataström.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "Händelsen ErrorDataReceived anger att den associerade processen har skrivits till den omdirigerade <xref:System.Diagnostics.Process.StandardError%2A>dataström.</xref:System.Diagnostics.Process.StandardError%2A>       Händelsen inträffar bara under asynkrona läsåtgärder <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> Om du vill starta asynkrona läsåtgärder, måste du dirigera <xref:System.Diagnostics.Process.StandardError%2A>ström med en <xref:System.Diagnostics.Process>lägger du till din händelsehanteraren för händelsen ErrorDataReceived och anropa <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> Därefter ErrorDataReceived händelse som signalerar varje gång processen skriver en rad till den omdirigerade <xref:System.Diagnostics.Process.StandardError%2A>stream, tills processen avslutas eller samtal <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      > [!NOTE] > Det program som bearbetar asynkront utdata ska anropa den <xref:System.Diagnostics.Process.WaitForExit%2A>metod för att säkerställa att utdatabufferten har tömts.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar värdet för den associerade processen angett när den avslutades."
  remarks: "Använd ExitCode för att hämta status för systemprocessen returneras när den avslutades. Du kan använda slutkoden mycket som ett heltal som returneras värdet från en `main()` procedur.       ExitCode värdet för en process motsvarar specifika konventionen implementeras av programutvecklaren för den här processen. Om du använder värdet för avslutningskoden för att fatta beslut i koden kan vara viktigt att du vet att avsluta kod konventionen används av programmet.       Utvecklare vanligtvis indikera en lyckad har avslutats av en ExitCode värdet noll och utse fel med andra värden än noll som anropa metoden kan användas för att identifiera orsaken till en onormal processavslutning. Det är inte nödvändigt att följa dessa riktlinjer, men de är konventionen.       Om du försöker hämta ExitCode innan processen har avslutats utlöser försöket ett undantag. Granska den <xref:System.Diagnostics.Process.HasExited%2A>egenskapen först för att kontrollera om den associerade processen har avslutats.</xref:System.Diagnostics.Process.HasExited%2A>      > [!NOTE] > När standardutdata har omdirigerats till asynkron händelsehanterare, är det möjligt att utdata inte ska har slutfört när <xref:System.Diagnostics.Process.HasExited%2A>returnerar `true`.</xref:System.Diagnostics.Process.HasExited%2A> För att säkerställa att asynkron händelsehantering har slutförts, anropa <xref:System.Diagnostics.Process.WaitForExit>överlagring som tar ingen parameter innan <xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit>       Du kan använda den <xref:System.Diagnostics.Process.CloseMainWindow%2A>eller <xref:System.Diagnostics.Process.Kill%2A>metod för att göra en associerade processen avslutas.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       Det finns två sätt att meddelas när den associerade processen avslutas: synkront och asynkront. Synkron meddelande beroende anropar den <xref:System.Diagnostics.Process.WaitForExit%2A>metod för att pausa bearbetningen av ditt program tills den associerade komponenten avslutas.</xref:System.Diagnostics.Process.WaitForExit%2A> Asynkrona meddelanden bygger på den <xref:System.Diagnostics.Process.Exited>händelse.</xref:System.Diagnostics.Process.Exited> När du använder asynkrona meddelanden <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>måste anges till `true` för den <xref:System.Diagnostics.Process>komponenten som ska få ett meddelande som processen har avslutats.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "Den kod som den associerade processen anges när den avslutades."
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen har inte avslutats.       - eller - processen <xref:System.Diagnostics.Process.Handle*>är inte giltig.</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen ExitCode för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inträffar när en processen avslutas."
  remarks: "Exited-händelsen indikerar att den associerade processen avslutades. Den här förekomsten innebär antingen att processen avslutade (avbrutits) eller har stängt. Den här händelsen kan inträffa om värdet för den <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>egenskapen är `true`.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Det finns två sätt att meddelas när den associerade processen avslutas: synkront och asynkront. Synkron meddelande innebär anropar den <xref:System.Diagnostics.Process.WaitForExit%2A>metod för att blockera den aktuella tråden tills processen avslutas.</xref:System.Diagnostics.Process.WaitForExit%2A> Asynkrona meddelanden använder Exited-händelsen, vilket gör att den anropande tråden fortsättningsvis ska köras under tiden. I det senare fallet <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>måste anges till `true` för det anropande programmet att ta emot Exited-händelsen.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       När operativsystemet stängs av en process, meddela andra processer som har registrerat hanterare för Exited-händelsen. För tillfället referensen för den process som just avslutats kan användas för åtkomst till vissa egenskaper som <xref:System.Diagnostics.Process.ExitTime%2A>och <xref:System.Diagnostics.Process.HasExited%2A>att operativsystemet upprätthåller tills den Frigör handtaget helt.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      > [!NOTE] > Även om du har en referens till en stängts process, du kan inte anropa <xref:System.Diagnostics.Process.Start%2A>igen för att återansluta till samma process.</xref:System.Diagnostics.Process.Start%2A> Anropar <xref:System.Diagnostics.Process.Start%2A>automatiskt släpper den associerade processen och ansluter till en process med samma fil, men en helt ny <xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.Start%2A>       Mer information om hur du använder Exited-händelsen i Windows Forms-program finns i <xref:System.Diagnostics.Process.SynchronizingObject%2A>egenskap.</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den tidpunkt då den associerade processen avslutades."
  remarks: "Om processen inte har avslutats, utlöser försök att hämta egenskapen ExitTime ett undantag. Använd <xref:System.Diagnostics.Process.HasExited%2A>innan du hämtar egenskapen ExitTime för att avgöra om den associerade processen har avslutats.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "En <xref:System.DateTime>som anger när den associerade processen avslutades.</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen ExitTime för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som associeras med den aktiva processen."
  remarks: "Använd den här metoden för att skapa en ny <xref:System.Diagnostics.Process>instansen och koppla den till resursen processen på den lokala datorn.</xref:System.Diagnostics.Process>       Som det liknande <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, och <xref:System.Diagnostics.Process.GetProcesses%2A>metoder, GetCurrentProcess associerar en befintlig resurs med en ny <xref:System.Diagnostics.Process>komponent.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent kopplad till resursen process som körs det anropande programmet."
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Returnerar en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent, givet identifierare för en process på den lokala datorn."
  remarks: "Använd den här metoden för att skapa en ny <xref:System.Diagnostics.Process>komponent och koppla den till en process-resurs på den lokala datorn.</xref:System.Diagnostics.Process> Process-resursen måste redan finnas på datorn, eftersom GetProcessById skapar inte en systemresurs, men i stället associerar en resurs med en programgenererade <xref:System.Diagnostics.Process>komponent.</xref:System.Diagnostics.Process> En process <xref:System.Diagnostics.Process.Id%2A>kan hämtas endast för en process som körs på datorn.</xref:System.Diagnostics.Process.Id%2A> När processen avslutas, genererar GetProcessById ett undantag om du skickar en identifierare som har upphört att gälla.       Identifierare för en process är unikt på en viss dator. GetProcessById returnerar en process som mest. Om du vill hämta alla processer som körs ett visst program kan använda <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Om det finns flera processer på datorn som kör det angivna programmet <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>returnerar en matris med alla associerade processer.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Du kan fråga dessa processer i sin tur efter dess identifierare. Process-ID kan visas i den `Processes` panelen i Aktivitetshanteraren. Den `PID` visar process-ID som är tilldelad till en process för kolumnen."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "System-Unik identifierare för en resurs i processen."
    return:
      type: System.Diagnostics.Process
      description: "En <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som är associerad med lokal process-resurs som identifieras av den <code> processId </code> parameter."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Processen som anges av den <code> processId </code> parametern körs inte. Identifieraren kanske har löpt ut."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen har inte startats av det här objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Returnerar en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent, baserat på ett process-ID och namnet på en dator i nätverket."
  remarks: "Använd den här metoden för att skapa en ny <xref:System.Diagnostics.Process>komponent och koppla den till en process-resurs på en fjärrdator i nätverket.</xref:System.Diagnostics.Process> Process-resursen måste redan finnas på den angivna datorn eftersom GetProcessById skapar inte en systemresurs, men i stället associerar en resurs med en programgenererade <xref:System.Diagnostics.Process>komponent.</xref:System.Diagnostics.Process> En process <xref:System.Diagnostics.Process.Id%2A>kan hämtas endast för en process som körs på datorn.</xref:System.Diagnostics.Process.Id%2A> När processen avslutas, genererar GetProcessById ett undantag om du skickar en identifierare som har upphört att gälla.       Identifierare för en process är unikt på en viss dator. GetProcessById returnerar en process som mest. Om du vill hämta alla processer som körs ett visst program kan använda <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Om det finns flera processer på datorn som kör det angivna programmet <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>returnerar en matris med alla associerade processer.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Du kan fråga dessa processer i sin tur efter dess identifierare. Process-ID kan visas i den `Processes` panelen i Aktivitetshanteraren. Den `PID` visar process-ID som är tilldelad till en process för kolumnen.       Om du inte anger en `machineName`, används den lokala datorn. Alternativt kan du ange den lokala datorn genom att ange `machineName` till värdet &quot;.&quot; eller en tom sträng (&quot;&quot;)."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "System-Unik identifierare för en resurs i processen."
    - id: machineName
      type: System.String
      description: "Namnet på en dator i nätverket."
    return:
      type: System.Diagnostics.Process
      description: "En <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som är associerad med en fjärrprocess resurs som identifieras av den <code> processId </code> parameter."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Processen som anges av den <code> processId </code> parametern körs inte. Identifieraren kanske har löpt ut.       - eller - <code> machineName </code> parametern syntax är ogiltig. Namnet kan ha längden noll (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen har inte startats av det här objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Skapar en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten för varje process resurs på den lokala datorn."
  remarks: "Använd den här metoden för att skapa en matris med nya <xref:System.Diagnostics.Process>komponenter och koppla dem till alla resurser som processen på den lokala datorn.</xref:System.Diagnostics.Process> Process-resurser måste redan finnas på den lokala datorn, eftersom GetProcesses inte skapa systemresurser men i stället associerar resurser med programgenererade <xref:System.Diagnostics.Process>komponenter.</xref:System.Diagnostics.Process> Eftersom själva operativsystemet körs bakgrundsprocesser är denna matris aldrig tom.       Om du inte vill hämta alla processer som körs på datorn kan du begränsa antalet med hjälp av den <xref:System.Diagnostics.Process.GetProcessById%2A>eller <xref:System.Diagnostics.Process.GetProcessesByName%2A>metod.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>skapar en <xref:System.Diagnostics.Process>komponent som är associerad med den process som identifierats på systemet med process-ID som du skickar till metoden.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>skapar en matris med <xref:System.Diagnostics.Process>komponenter vars associerade processen resurser dela den körbara filen som du skickar till metoden.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      > [!NOTE] > Flera Windows-tjänster kan läsas in i samma instans av värdprocessen för Service (svchost.exe). GetProcesses identifierar inte de enskilda tjänsterna. för att se <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "En matris av typen <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som representerar alla processen resurser som körs på den lokala datorn."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Skapar en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten för varje process resurs på den angivna datorn."
  remarks: "Använd den här metoden för att skapa en matris med nya <xref:System.Diagnostics.Process>komponenter och koppla dem till alla resurser som processen på den angivna (vanligtvis) fjärrdatorn.</xref:System.Diagnostics.Process> Process-resurser måste redan finnas på den lokala datorn, eftersom <xref:System.Diagnostics.Process.GetProcesses%2A>inte skapa systemresurser men i stället associerar resurser med programgenererade <xref:System.Diagnostics.Process>komponenter.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> Eftersom själva operativsystemet körs bakgrundsprocesser är denna matris aldrig tom.       Om du inte vill hämta alla processer som körs på datorn kan du begränsa antalet med hjälp av den <xref:System.Diagnostics.Process.GetProcessById%2A>eller <xref:System.Diagnostics.Process.GetProcessesByName%2A>metod.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>skapar en <xref:System.Diagnostics.Process>komponent som är associerad med den process som identifierats på systemet med process-ID som du skickar till metoden.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>skapar en matris med <xref:System.Diagnostics.Process>komponenter vars associerade processen resurser dela den körbara filen som du skickar till metoden.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       Den här överlagring för den <xref:System.Diagnostics.Process.GetProcesses%2A>metoden används vanligtvis för att hämta listan över resurser som processen körs på en fjärrdator i nätverket, men du kan ange den lokala datorn genom att skicka &quot;.&quot;.</xref:System.Diagnostics.Process.GetProcesses%2A>      > [!NOTE] > Flera Windows-tjänster kan läsas in i samma instans av värdprocessen för Service (svchost.exe). GetProcesses identifierar inte de enskilda tjänsterna. för att se <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "Den dator som du vill läsa processlistan."
    return:
      type: System.Diagnostics.Process[]
      description: "En matris av typen <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som representerar alla processen resurser som körs på den angivna datorn."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Den <code> machineName </code> parametern syntax är ogiltig. Det kan ha längden noll (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Operativsystemet stöder inte den här åtgärden på fjärrdatorer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det finns problem med åtkomst till API: er som används för att hämta information om prestandaräknare. Det här undantaget är specifik för Windows NT, Windows 2000 och Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett problem uppstod när en underliggande systemet API."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Skapar en matris med nya <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenter som associeras med alla processen resurser på den lokala datorn som delar det angivna processnamnet."
  remarks: "Använd den här metoden för att skapa en matris med nya <xref:System.Diagnostics.Process>komponenter och koppla dem till alla process-resurser som kör samma körbara filen på den lokala datorn.</xref:System.Diagnostics.Process> Process-resurser måste redan finnas på datorn, eftersom GetProcessesByName inte skapa systemresurser men i stället associerar dem med programgenererade <xref:System.Diagnostics.Process>komponenter.</xref:System.Diagnostics.Process> En `processName` kan anges för en körbar fil som inte körs på den lokala datorn så att matrisen returnerar-metoden kan vara tom.       Processnamnet är ett eget namn för processen, till exempel Outlook, som inte innehåller filnamnstillägget .exe eller sökvägen. GetProcessesByName är användbara för att hämta, manipulera alla processer som är associerade med samma körbara fil. Du kan till exempel skicka en körbar filnamn som den `processName` parametern för att stänga alla instanser av den körbara filen.       Även om en process <xref:System.Diagnostics.Process.Id%2A>är unika för en enda process resurs i systemet, flera processer på den lokala datorn kan köra program som anges av den `processName` parameter.</xref:System.Diagnostics.Process.Id%2A> Därför <xref:System.Diagnostics.Process.GetProcessById%2A>returnerar en process som mest men GetProcessesByName returnerar en matris med alla associerade processer.</xref:System.Diagnostics.Process.GetProcessById%2A> Om du behöver ändra processen med standard-API-anrop kan du fråga dessa processer i sin tur efter dess identifierare. Du kan inte komma åt processen resurser via processnamnet enbart men när du har hämtat en matris med <xref:System.Diagnostics.Process>komponenter som är associerade med process-resurser du kan starta, avsluta och ändra systemresurserna.</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "Eget namn på processen."
    return:
      type: System.Diagnostics.Process[]
      description: "En matris av typen <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som representerar de processen resurser som kör ett visst program eller en fil."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det finns problem med åtkomst till API: er som används för att hämta information om prestandaräknare. Det här undantaget är specifik för Windows NT, Windows 2000 och Windows XP."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Skapar en matris med nya <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenter som associeras med alla processen resurser på en fjärrdator som delar det angivna processnamnet."
  remarks: "Använd den här metoden för att skapa en matris med nya <xref:System.Diagnostics.Process>komponenter och koppla dem till alla process-resurser som kör samma körbara filen på den angivna datorn.</xref:System.Diagnostics.Process> Process-resurser måste redan finnas på datorn, eftersom <xref:System.Diagnostics.Process.GetProcessesByName%2A>inte skapa systemresurser men i stället associerar dem med programgenererade <xref:System.Diagnostics.Process>komponenter.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> En `processName` kan anges för en körbar fil som inte körs på den lokala datorn så att matrisen returnerar-metoden kan vara tom.       Processnamnet är ett eget namn för processen, till exempel Outlook, som inte innehåller filnamnstillägget .exe eller sökvägen. <xref:System.Diagnostics.Process.GetProcessesByName%2A>är användbart för att hämta och ändra alla processer som är associerade med samma körbara fil.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Du kan till exempel skicka en körbar filnamn som den `processName` parametern för att stänga alla instanser av den körbara filen.       Även om en process <xref:System.Diagnostics.Process.Id%2A>är unika för en enda process resurs i systemet, flera processer på den lokala datorn kan köra program som anges av den `processName` parameter.</xref:System.Diagnostics.Process.Id%2A> Därför <xref:System.Diagnostics.Process.GetProcessById%2A>returnerar en process som mest men <xref:System.Diagnostics.Process.GetProcessesByName%2A>returnerar en matris med alla associerade processer.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> Om du behöver ändra processen med standard-API-anrop kan du fråga dessa processer i sin tur efter dess identifierare. Du kan inte komma åt processen resurser via processnamnet enbart men när du har hämtat en matris med <xref:System.Diagnostics.Process>komponenter som är associerade med process-resurser du kan starta, avsluta och ändra systemresurserna.</xref:System.Diagnostics.Process>       Du kan använda den här överlagring för att hämta processer på den lokala datorn samt på en fjärrdator. Använd &quot;.&quot; för att ange den lokala datorn. Det finns en annan överlagring som använder den lokala datorn som standard.       Du kan öppna processer på fjärrdatorer bara för att visa information, till exempel statistik, om processerna. Du kan inte stänga, avsluta (med <xref:System.Diagnostics.Process.Kill%2A>), eller starta processer på fjärrdatorer.</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "Eget namn på processen."
    - id: machineName
      type: System.String
      description: "Namnet på en dator i nätverket."
    return:
      type: System.Diagnostics.Process[]
      description: "En matris av typen <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som representerar de processen resurser som kör ett visst program eller en fil."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Den <code> machineName </code> parametern syntax är ogiltig. Det kan ha längden noll (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Operativsystemet stöder inte den här åtgärden på fjärrdatorer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det finns problem med åtkomst till API: er som används för att hämta information om prestandaräknare. Det här undantaget är specifik för Windows NT, Windows 2000 och Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett problem uppstod när en underliggande systemet API."
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den egna referensen för den associerade processen."
  remarks: "Ett program kan hämta en referens till en process som kan användas som parameter till många funktioner för process-information och kontroll. Du kan använda den här referensen för att initiera en <xref:System.Threading.WaitHandle>eller för att anropa invoke-metoder med plattformen.</xref:System.Threading.WaitHandle>       Den här processreferensen är privat för ett program – med andra ord processen referenser inte kan delas. En process har också en process <xref:System.Diagnostics.Process.Id%2A>som, till skillnad från referensen är unikt och därmed giltiga i hela systemet.</xref:System.Diagnostics.Process.Id%2A>       Endast processer som startas via ett anrop till <xref:System.Diagnostics.Process.Start%2A>egenskapen referensen för motsvarande <xref:System.Diagnostics.Process>instanser.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "Referensen som operativsystemet som tilldelats till den associerade processen när processen startades. Den här referensen används för att hålla reda på attribut."
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen har inte startats eller har avslutats. Egenskapen Handle kan inte läsas eftersom det inte finns någon process som är associerade med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instans.       - eller - <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instans har kopplats till en process som körs men du har inte tillräcklig behörighet för att hämta en referens med fullständig behörighet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen referensen för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar antalet handtag som öppnas av processen."
  remarks: "Hanterar gör det möjligt för en process att referera till objekt. En process kan hämta referenser till filer, resurser, meddelandeköer och många andra objekt i operativsystemet. Operativsystemet återtar minnet som är associerade med processen endast när antal referenser är noll."
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "Antalet operativsystemet referenser som processen har öppnats."
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange den &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; egenskapen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar ett värde som anger om den associerade processen har avslutats."
  remarks: "Värdet `true` för HasExited anger att den associerade processen har avslutats onormalt eller normalt. Du kan begära eller tvinga den associerade processen avslutas genom att anropa <xref:System.Diagnostics.Process.CloseMainWindow%2A>eller <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Om en referens är öppen för processen Frigör minne för processen i operativsystemet när processen har avslutats, men behåller administrativ information om processen, till exempel referensen, slutkod och avsluta tid. För att få den här informationen kan du använda den <xref:System.Diagnostics.Process.ExitCode%2A>och <xref:System.Diagnostics.Process.ExitTime%2A>Egenskaper.</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> Dessa egenskaper fylls i automatiskt för processer som har startats av den här komponenten. Administrativ information släpps när alla de <xref:System.Diagnostics.Process>komponenter som är associerade med systemprocessen förstörs och innehåller inga fler referenser till stängts processen.</xref:System.Diagnostics.Process>       En process kan säga upp oberoende av din kod. Om du startade processen med den här komponenten uppdaterar systemet värdet för HasExited automatiskt, även om den associerade processen avslutas oberoende av varandra.      > [!NOTE] > När standardutdata har omdirigerats till asynkron händelsehanterare, är det möjligt att utdata inte ska har slutfört den här egenskapen returnerar `true`. För att säkerställa att asynkron händelsehantering har slutförts, anropa den <xref:System.Diagnostics.Process.WaitForExit>överlagring som inte tar ingen parameter innan HasExited.</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om operativsystemet processen refererar till den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten har avslutats, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det finns ingen process som är associerad med objektet."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det gick inte att hämta slutkoden för processen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen HasExited för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den unika identifieraren för den associerade processen."
  remarks: "Processen Id är inte giltigt om den associerade processen inte körs. Därför bör du kontrollera att processen körs innan du försöker hämta Id-egenskapen. Tills processen avslutas, identifierar processidentifieraren processen i hela systemet.       Du kan ansluta en process som körs på en lokal eller fjärransluten dator till en ny <xref:System.Diagnostics.Process>instans genom att skicka process-ID som den <xref:System.Diagnostics.Process.GetProcessById%2A>metoden.</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>är en `static` metod som skapar en ny komponent och anger Id-egenskapen för den nya <xref:System.Diagnostics.Process>instansen automatiskt.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       Process-ID kan återanvändas av systemet. Värdet för egenskapen Id är unikt endast när den associerade processen körs. När processen har avslutats återanvända systemet egenskapsvärdet Id för en orelaterade process.       Eftersom ID är unikt på datorn du skickar det till andra trådar i stället för att skicka en <xref:System.Diagnostics.Process>instans.</xref:System.Diagnostics.Process> Den här åtgärden kan spara systemresurser än garantera att processen identifieras korrekt."
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Den systemgenererade unika identifieraren för processen som refererar till detta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instans."
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den process-Id-egenskapen har inte angetts.       - eller - det finns ingen process som är associerade med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange den &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; egenskapen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Omedelbart stoppar den associerade processen."
  remarks: "Kill tvingar fram en avslutning av processen, medan <xref:System.Diagnostics.Process.CloseMainWindow%2A>endast begär en avslutning.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Vid körning av en process med ett grafiskt gränssnitt är dess meddelandeloop i tillståndet vänta. Meddelandeloopen körs varje gång ett Windows-meddelande skickas till processen av operativsystemet. Anropar <xref:System.Diagnostics.Process.CloseMainWindow%2A>skickar en begäran om att nära huvudfönstret som i ett giltigt program stänger underordnade fönster och återkallar alla pågående meddelande slingor för programmet.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Begäran om att avsluta processen genom att anropa <xref:System.Diagnostics.Process.CloseMainWindow%2A>utan att programmet avslutas.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Programmet kan be om användarens verifiering innan du avslutar eller kan avvisa avslutas. Använd metoden Kill för att tvinga programmet avslutas. Beteendet för <xref:System.Diagnostics.Process.CloseMainWindow%2A>är identisk med en användare stänga huvudfönstret i ett program med hjälp av systemmenyn.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Begäran om att avsluta processen genom att stänga huvudfönstret tvingar därför inte programmet avslutas omedelbart.      > [!NOTE] > I Kill metoden Kör asynkront. När du anropar metoden Kill anropa den <xref:System.Diagnostics.Process.WaitForExit%2A>metod för att vänta på att processen för att avsluta eller kontrollera den <xref:System.Diagnostics.Process.HasExited%2A>egenskapen för att avgöra om processen har avslutats.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       Data som redigeras av processen eller resurser som tilldelats processen kan gå förlorade om du anropar Kill. Kill orsakar en onormal processavslutning och används bara när det behövs. <xref:System.Diagnostics.Process.CloseMainWindow%2A>aktiverar en korrekt avslutning av processen och stänger alla fönster, så det är bättre för program med ett gränssnitt.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Om <xref:System.Diagnostics.Process.CloseMainWindow%2A>misslyckas, du kan använda Kill för att avsluta processen.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Kill är det enda sättet att avsluta processer som inte har grafiska gränssnitt.       Du kan anropa Kill och <xref:System.Diagnostics.Process.CloseMainWindow%2A>endast för processer som körs på den lokala datorn.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Du kan orsaka processer på fjärrdatorer för att avsluta. Du kan bara visa information för processer som körs på fjärrdatorer.      > [!NOTE] > Om anrop till metoden Kill görs när processen avslutas för närvarande, en <xref:System.ComponentModel.Win32Exception>genereras för åtkomst nekad.</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det gick inte att avsluta den associerade processen.       - eller - processen avslutas.       - eller - den associerade processen är en Win16 körbar fil."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker anropa Kill för en process som körs på en fjärrdator. Metoden är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen har redan avslutats.       - eller - det finns ingen process som är associerade med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt."
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Tar en <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent utanför det tillstånd som gör det interagerar med operativsystemprocesser som körs i ett särskilt läge."
  remarks: "Vissa operativsystemprocesser köras i ett särskilt läge. Försök att läsa egenskaperna för eller ansluta till de här processerna inte är möjligt om du har anropat <xref:System.Diagnostics.Process.EnterDebugMode%2A>på komponenten.</xref:System.Diagnostics.Process.EnterDebugMode%2A> Anropa LeaveDebugMode när du inte längre behöver åtkomst till dessa processer som körs i särskilda läge."
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar namnet på den associerade processen körs på datorn."
  remarks: "Du kan visa statistiska data och processinformation om för processer som körs på fjärrdatorer, men du kan inte anropa <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, eller <xref:System.Diagnostics.Process.Kill%2A>på fjärrdatorer.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      > [!NOTE] > När den associerade processen körs på den lokala datorn måste den här egenskapen returnerar en punkt (&quot;.&quot;) för namnet på datorn. Du bör använda den <xref:System.Environment.MachineName%2A?displayProperty=fullName>egenskapen för att hämta rätt datornamnet.</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "Namnet på den dator som den associerade processen körs på."
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det finns ingen process som är associerade med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar Huvudmodulen för den associerade processen."
  remarks: "En processmodulen representerar a.dll eller .exe-fil som läses in i en viss process. Egenskapen MainModule kan du visa information om den körbara filen som används för att starta processen, inklusive namn, filnamn och minne modulinformation."
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "Den <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> som användes för att starta processen."
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen MainModule för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "En 32-bitarsprocess försöker komma åt moduler för en 64-bitarsprocess."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; till <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen <xref:System.Diagnostics.Process.Id*>är inte tillgänglig.</xref:System.Diagnostics.Process.Id*>       - eller - processen har avslutats."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar fönsterreferensen i fönstret för den associerade processen."
  remarks: "Huvudfönstret är det fönster som öppnas av den process som har fokus för tillfället (den <xref:System.Windows.Forms.Form.TopLevel%2A>formuläret).</xref:System.Windows.Forms.Form.TopLevel%2A> Du måste använda den <xref:System.Diagnostics.Process.Refresh%2A>metod för att uppdatera den <xref:System.Diagnostics.Process>objekt för att hämta den aktuella huvudfönstret referensen om den har ändrats.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> I allmänhet eftersom fönsterreferensen cachelagras använda <xref:System.Diagnostics.Process.Refresh%2A>förhand att garantera att ska du hämta den aktuella referensen.</xref:System.Diagnostics.Process.Refresh%2A>       Du kan hämta egenskapen MainWindowHandle endast för processer som körs på den lokala datorn. Egenskapen MainWindowHandle är ett värde som unikt identifierar det fönster som är associerade med processen.       En process har en associerad endast om processen har ett grafiskt gränssnitt huvudfönstret. Om den associerade processen inte har en huvudfönstret är MainWindowHandle-värdet noll. Värdet är också noll för processer som har dolts, det vill säga bearbetar som inte visas i Aktivitetsfältet. Detta kan vara fallet för processer som visas som ikoner i meddelandefältet längst till höger i Aktivitetsfältet.       Om du precis har startat en process och vill använda huvudfönstret referensen, bör du använda den <xref:System.Diagnostics.Process.WaitForInputIdle%2A>metod för att skapa processen har startat, se till att huvudsakliga fönsterreferensen har skapats.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Annars genereras ett undantagsfel."
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "Systemgenererade fönsterreferensen i fönstret för den associerade processen."
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "MainWindowHandle har inte definierats eftersom processen har avslutats."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen MainWindowHandle för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; till <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar titeln för processens huvudfönster."
  remarks: "En process har en associerad endast om processen har ett grafiskt gränssnitt huvudfönstret. Om den associerade processen inte har en huvudfönstret (så att <xref:System.Diagnostics.Process.MainWindowHandle%2A>är noll), MainWindowTitle är en tom sträng (&quot;&quot;).</xref:System.Diagnostics.Process.MainWindowHandle%2A> Om du precis har startat en process och vill använda huvudfönstret rubrik, bör du använda den <xref:System.Diagnostics.Process.WaitForInputIdle%2A>metod för att skapa processen har startat, se till att huvudsakliga fönsterreferensen har skapats.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Annars genereras ett undantag i systemet.      > [!NOTE] > Huvudfönstret är fönstret som har fokus för tillfället; Observera att detta inte är primär fönstret för processen. Du måste använda den <xref:System.Diagnostics.Process.Refresh%2A>metod för att uppdatera den <xref:System.Diagnostics.Process>objekt för att hämta den aktuella huvudfönstret referensen om den har ändrats.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "Rubriken processens huvudfönster."
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Egenskapen MainWindowTitle har inte definierats eftersom processen har avslutats."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen MainWindowTitle för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; till <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar eller anger den största tillåtna fungerande set storleken, i byte, för den associerade processen."
  remarks: "Arbetsminnet för en process är uppsättningen minnessidor som för närvarande är synliga för processen i det fysiska RAM-minnet. Dessa sidor är fasta och tillgängliga för ett program kan använda utan att utlösa ett sidfel.       Arbetsminnet innehåller både delade och privata data. Delade data innehåller de sidor som innehåller de instruktioner som utförs av ditt program, inklusive sidorna i DLL-filer och system.dll-filer. När aktiv sidmängd storlek ökar, ökar minne begäran.       En process har minsta och största fungerande set storlekar. Varje gång en resurs process skapas reserverar systemet en mängd minne som är lika med den minimala storlek för aktiv sidmängd för processen. Hanteraren för virtuellt minne försöker hålla minst den minsta mängden minne resident när processen är aktiv, men den aldrig bevarar mer än den maximala storleken.       Systemet anger standard fungerar set storlekar. Du kan ändra dessa storlekar som använder MaxWorkingSet och <xref:System.Diagnostics.Process.MinWorkingSet%2A>medlemmar.</xref:System.Diagnostics.Process.MinWorkingSet%2A> Men garanterar dessa inställningsvärden inte att minnet blir reserverad eller resident.      > [!NOTE] > Om du ökar växlingsminnet för en process kan du ta fysiskt minne från resten av systemet. Se till att du inte begära en lägsta eller högsta växlingsminnet som är för stor, eftersom detta kan påverka systemprestanda."
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "Maximalt aktiv sidmängd storleken som tillåts i minnet för processen i byte."
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Den maximala växlingsminnet är ogiltig. Det måste vara större än eller lika med den minimala storlek för aktiv sidmängd."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Arbeta mängd information kan inte hämtas från den associerade process resursen.       - eller - process-ID eller processreferensen är noll eftersom processen inte har startats."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen MaxWorkingSet för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen <xref:System.Diagnostics.Process.Id*>är inte tillgänglig.</xref:System.Diagnostics.Process.Id*>       - eller - processen har avslutats."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar eller anger den minsta tillåtna fungerande set storleken, i byte, för den associerade processen."
  remarks: "Arbetsminnet för en process är uppsättningen minnessidor som för närvarande är synliga för processen i det fysiska RAM-minnet. Dessa sidor är fasta och tillgängliga för ett program kan använda utan att utlösa ett sidfel.       Arbetsminnet innehåller både delade och privata data. Delade data innehåller de sidor som innehåller de instruktioner som utförs av ditt program, inklusive sidorna i DLL-filer och system.dll-filer. När aktiv sidmängd storlek ökar, ökar minne begäran.       En process har minsta och största fungerande set storlekar. Varje gång en resurs process skapas reserverar systemet en mängd minne som är lika med den minimala storlek för aktiv sidmängd för processen. Hanteraren för virtuellt minne försöker hålla minst den minsta mängden minne resident när processen är aktiv, men den aldrig bevarar mer än den maximala storleken.       Systemet anger standard fungerar set storlekar. Du kan ändra dessa storlekar som använder den <xref:System.Diagnostics.Process.MaxWorkingSet%2A>och MinWorkingSet medlemmar.</xref:System.Diagnostics.Process.MaxWorkingSet%2A> Men garanterar dessa inställningsvärden inte att minnet blir reserverad eller resident.      > [!NOTE] > Om du ökar växlingsminnet för en process kan du ta fysiskt minne från resten av systemet. Se till att du inte begära en lägsta eller högsta växlingsminnet som är för stor, eftersom detta kan påverka systemprestanda."
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "Minsta aktiv sidmängd storlek som krävs i minnet för processen i byte."
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Den minsta storlek för aktiv sidmängd är ogiltig. Det måste vara mindre än eller lika med den maximala storlek för aktiv sidmängd."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Arbeta mängd information kan inte hämtas från den associerade process resursen.       - eller - process-ID eller processreferensen är noll eftersom processen inte har startats."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen MinWorkingSet för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen <xref:System.Diagnostics.Process.Id*>är inte tillgänglig.</xref:System.Diagnostics.Process.Id*>       - eller - processen har avslutats."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar de moduler som har lästs in av den associerade processen."
  remarks: "En processmodulen representerar a.dll eller .exe-fil som läses in i en viss process. En <xref:System.Diagnostics.ProcessModule>instans kan du visa information om en modul, inklusive namn, filnamn och minne modulinformation.</xref:System.Diagnostics.ProcessModule>       En process kan läsa in flera moduler i minnet. Till exempel att .exe-filer som läser in ytterligare DLL-filer har flera moduler.       Den här samlingen är tom när den startas förrän datorn har lästs in i processen. Om processen har en huvudfönstret, kan du anropa <xref:System.Diagnostics.Process.WaitForInputIdle%2A>innan du hämtar den här egenskapen så att samlingen är tom när du får listan.</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "En matris av typen <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> som representerar de moduler som har lästs in av den associerade processen."
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen moduler för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen <xref:System.Diagnostics.Process.Id*>är inte tillgänglig.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; till <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Du försöker komma åt egenskapen moduler för systemprocessen eller inaktiva processen. De här processerna inte moduler."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden icke-växlingsbart systemminne i byte som tilldelats för den associerade processen."
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "Mängden minne i byte, systemet har allokerats för den associerade processen inte kan skrivas till virtuella minnesväxlingsfil."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden icke-växlingsbart systemminne i byte som tilldelats för den associerade processen."
  remarks: "Värdet som returneras av denna egenskap representerar den aktuella storleken för icke-växlingsbart systemminne som används av processen i byte. Systemminne är fysiskt minne som används av operativsystemet och är uppdelad i växlingsbara och icke-växlingsbart pooler. Icke-växlingsbart minne allokeringar finns kvar i systemminnet och växlas inte ut till virtuella minnesväxlingsfil.       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **Pool växlingsbart systemminne-byte** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Mängden systemminne, i byte som tilldelats för den associerade processen inte kan skrivas till virtuella minnesväxlingsfil."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Genererar den <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> händelse."
  remarks: "OnExited är API-metod som genererar den <xref:System.Diagnostics.Process.Exited>händelse.</xref:System.Diagnostics.Process.Exited> Anropar OnExited orsaker i <xref:System.Diagnostics.Process.Exited>händelse ska inträffa och är det enda sättet att generera en händelse med hjälp av den <xref:System.Diagnostics.Process>komponent.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> OnExited används främst när härledda klasser från komponenten.       Du kan skriva egna händelsehanteraren som ett alternativ till OnExited. Du skapar egna händelse hanterardelegaten och händelsehantering metoden.      > [!NOTE] > Om du använder Visual Studio-miljön, en händelse hanterardelegaten (AddOnExited) och händelsehantering-metoden (Process1_Exited) skapas när du drar en <xref:System.Diagnostics.Process>komponent på ett formulär och dubbelklicka på ikonen.</xref:System.Diagnostics.Process> Koden som du skapar för att köras när den <xref:System.Diagnostics.Process.Exited>händelse inträffar har angetts i proceduren Process1_Exited.</xref:System.Diagnostics.Process.Exited> Du behöver inte skapa OnExited-medlem eftersom de är implementerade för dig.       Att en händelse utlöstes anropar händelsehanteraren via ett ombud. En översikt finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Varje gång ett tillämpningsprogram skriver en rad till den omdirigerade <xref:System.Diagnostics.Process.StandardOutput*>dataström.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "OutputDataReceived händelsen indikerar att den associerade <xref:System.Diagnostics.Process>har skrivit en rad som avslutas med ett radmatningstecken till den omdirigerade <xref:System.Diagnostics.Process.StandardOutput%2A>dataström.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Händelsen aktiveras under asynkrona läsåtgärder <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> Om du vill starta asynkrona läsåtgärder, måste du dirigera <xref:System.Diagnostics.Process.StandardOutput%2A>ström med en <xref:System.Diagnostics.Process>lägger du till din händelsehanteraren för händelsen OutputDataReceived och anropa <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> Därefter OutputDataReceived händelse som signalerar varje gång processen skriver en rad till den omdirigerade <xref:System.Diagnostics.Process.StandardOutput%2A>stream, tills processen avslutas eller samtal <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>      > [!NOTE] > Det program som bearbetar asynkront utdata ska anropa den <xref:System.Diagnostics.Process.WaitForExit%2A>metod för att säkerställa att utdatabufferten har tömts.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden växlingsbart minne i byte som tilldelats för den associerade processen."
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "Mängden minne i byte som tilldelats av den associerade processen som kan skrivas till virtuella minnesväxlingsfil."
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden växlingsbart minne i byte som tilldelats för den associerade processen."
  remarks: "Värdet som returneras av denna egenskap representerar den aktuella storleken för minne i virtuella minnesväxlingsfil som används av processen i byte. Operativsystemet använder virtuella minnesväxlingsfil tillsammans med fysiskt minne för att hantera det virtuella adressutrymmet för varje process. När växlingsbart minne inte används, kan det överföras till virtuella minnets växlingsfil på disken. Så här skaffar du storleken på det minne som används av operativsystemet för processen i <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>egenskap.</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **växlingsfiler-byte** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Mängden minne i byte som tilldelats i virtuella minnesväxlingsfil för den associerade processen."
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden växlingsbart systemminne i byte som tilldelats för den associerade processen."
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "Mängden minne i byte, systemet har allokerats för den associerade processen som kan skrivas till virtuella minnesväxlingsfil."
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden växlingsbart systemminne i byte som tilldelats för den associerade processen."
  remarks: "Värdet som returneras av den här egenskapens värde representerar den aktuella storleken för växlingsbart systemminne som används av processen i byte. Systemminne är fysiskt minne som används av operativsystemet och är uppdelad i växlingsbara och icke-växlingsbart pooler. När växlingsbart minne inte används, kan det överföras till virtuella minnets växlingsfil på disken. Så här skaffar du storleken på det program-minne som används av processen i <xref:System.Diagnostics.Process.PagedMemorySize64%2A>egenskap.</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **växlingsbart systemminne-byte** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Mängden systemminne, i byte som tilldelats för den associerade processen som kan skrivas till virtuella minnesväxlingsfil."
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den maximal mängden minne i virtuella minnets växlingsfil, i byte som används av den associerade processen."
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "Den maximala mängden minne i byte som tilldelats av den associerade processen som kan skrivas till virtuella minnesväxlingsfil."
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den maximal mängden minne i virtuella minnets växlingsfil, i byte som används av den associerade processen."
  remarks: "Värdet som returneras av den här egenskapens värde representerar den maximala storleken på växlingsfilen för virtuellt minne som används av processen sedan den startades i byte minne. Operativsystemet använder virtuella minnesväxlingsfil tillsammans med fysiskt minne för att hantera det virtuella adressutrymmet för varje process. När växlingsbart minne inte används, kan det överföras till virtuella minnets växlingsfil på disken.       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **Toppvärde filen byte** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Den maximala mängden minne i byte som tilldelats i virtuella minnesväxlingsfil för den associerade processen sedan den startades."
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den maximal mängden virtuellt minne i byte som används av den associerade processen."
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "Maximal mängd virtuellt minne i byte som den associerade processen har begärt."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den maximal mängden virtuellt minne i byte som används av den associerade processen."
  remarks: "Värdet som returneras av denna egenskap representerar den maximala storleken för virtuellt minne som används av processen sedan den startades i byte. Operativsystemet mappar det virtuella adressutrymmet för varje process som antingen sidorna läses in i det fysiska minnet eller på sidor som lagras i virtuella minnets växlingsfil på disken.       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **högsta antal virtuella byte** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Maximal mängd virtuellt minne i byte som tilldelats för den associerade processen sedan den startades."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den högsta storlek för aktiv sidmängd för den associerade processen i byte."
  remarks: "Arbetsminnet för en process är uppsättningen minnessidor som för närvarande är synliga för processen i det fysiska RAM-minnet. Dessa sidor är fasta och tillgängliga för ett program kan använda utan att utlösa ett sidfel.       Arbetsminnet innehåller både delade och privata data. Delade data innehåller de sidor som innehåller de instruktioner som processen körs, inklusive processmodulerna och systembibliotek."
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "Den maximala mängden fysiskt minne som den associerade processen har krävt samtidigt, i byte."
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den högsta mängden fysiskt minne i byte som används av den associerade processen."
  remarks: "Värdet som returneras av denna egenskap representerar den maximala storleken för arbetsminnet som används av processen sedan den startades i byte. Arbetsminnet för en process är uppsättningen minnessidor som för närvarande är synliga för processen i det fysiska RAM-minnet. Dessa sidor är fasta och tillgängliga för ett program kan använda utan att utlösa ett sidfel.       Arbetsminnet innehåller både delade och privata data. Delade data innehåller de sidor som innehåller de instruktioner som processen körs, inklusive instruktioner från processmodulerna och systembibliotek.       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **Toppvärde för arbetsminne** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "Den högsta mängden fysiskt minne i byte som tilldelats för den associerade processen sedan den startades."
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar eller anger ett värde som anger om den associerade processprioriteten tillfälligt vara förstärkta av operativsystemet när huvudfönstret har fokus."
  remarks: "När en tråd körs i en process där prioritetsklassen har en dynamisk prioritet uppräkningsvärdena (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, eller <xref:System.Diagnostics.ProcessPriorityClass>), systemet förstärker tillfälligt trådens prioritet när den tas ur tillståndet vänta.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Den här åtgärden förhindrar att andra processer att avbryta bearbetningen av den aktuella tråden. PriorityBoostEnabled inställningen påverkar alla befintliga trådar och alla trådar som skapas därefter av processen. Om du vill återställa normal beteende för egenskapen PriorityBoostEnabled `false`.      > [!NOTE] > Öka prioriteten för högt kan tömma resurser från grundläggande operativsystemet och nätverket funktion, orsakar problem med andra operativsystem uppgifter."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den är dynamisk förstärkning av processens prioritet som ska användas för en process när den tas ur tillståndet vänta; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardvärdet är <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det gick inte att hämta prioritet förstärkningen information från den associerade process resursen."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen.       - eller - process-ID eller processreferensen är noll. (Processen har inte startats.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen PriorityBoostEnabled för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen <xref:System.Diagnostics.Process.Id*>är inte tillgänglig.</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar eller anger den övergripande priority kategorin för den associerade processen."
  remarks: "En process prioritetsklass omfattar en mängd tråd prioritetsnivå. Trådar med olika prioriteter som körs i processen körs i förhållande till prioritetsklassen av processen. Win32 använder fyra prioritet klasser med sju basprioritet per klass. Klasserna processen prioritet fångas i den <xref:System.Diagnostics.ProcessPriorityClass>uppräkning, där du kan ange processprioritet för till <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, eller <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Baserat på tiden förflutna eller andra ökar basprioritet nivå kan ändras av operativsystemet när en process ska placeras längre än andra för åtkomst till processorn. Dessutom kan du ange den <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>tillfälligt ökar prioritetsnivån för trådar som har gjorts utanför tillståndet vänta.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Prioriteten återställs när processen återgår till tillståndet vänta.       Den <xref:System.Diagnostics.Process.BasePriority%2A>egenskapen kan du visa första prioriteten som tilldelas till en process.</xref:System.Diagnostics.Process.BasePriority%2A> Men eftersom den är skrivskyddad, du kan inte använda den <xref:System.Diagnostics.Process.BasePriority%2A>egenskapen för att ange prioritet för en process.</xref:System.Diagnostics.Process.BasePriority%2A> Använd egenskapen PriorityClass, som hämtar eller anger den övergripande priority kategorin för processen om du vill ändra prioriteten.       Prioritetsklassen kan inte visas med Systemövervakaren. Följande tabell visar relationen mellan den <xref:System.Diagnostics.Process.BasePriority%2A>och PriorityClass värden.</xref:System.Diagnostics.Process.BasePriority%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "Kategorin prioritet för den associerade processen där den <xref:System.Diagnostics.Process.BasePriority*>processens beräknas.</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Prioritet processinformation kunde inte ange eller hämta från den associerade process resursen.       - eller - process-ID eller processreferensen är noll. (Processen har inte startats.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen PriorityClass för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen <xref:System.Diagnostics.Process.Id*>är inte tillgänglig.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Du har valt PriorityClass <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> när du använder Windows 98 eller Windows ME (Me). Dessa plattformar stöder inte dessa värden för prioritetsklassen."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Prioritetsklass kan inte anges eftersom den inte använder ett giltigt värde enligt definitionen i den <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref> uppräkning."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden privat minne i byte som tilldelats för den associerade processen."
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "Antal byte som har allokerats av den associerade processen som inte kan delas med andra processer."
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden privat minne i byte som tilldelats för den associerade processen."
  remarks: "Värdet som returneras av denna egenskap representerar den aktuella storleken för minne som används av processen i antal byte som inte delas med andra processer.       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **privata byte** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Mängden minne i byte, för den associerade processen som inte kan delas med andra processer."
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar Privilegierade processortiden för den här processen."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "En <xref:System.TimeSpan>som anger hur lång tid som processen har använt för att köra kod i operativsystemets kärna.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen PrivilegedProcessorTime för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar namnet på processen."
  remarks: "Egenskapen ProcessName innehåller ett namn på körbar fil, till exempel Outlook, som inte innehåller filnamnstillägget .exe eller sökvägen. Det är bra för att hämta och ändra alla processer som är associerade med samma körbara fil.      > [!NOTE] > På [!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)] operativsystem, egenskapen ProcessName kan trunkeras 15 tecken om det inte går att hämta modulinformation processen.       Du kan anropa <xref:System.Diagnostics.Process.GetProcessesByName%2A>, skickar den ett namn på körbar fil, om du vill hämta en matris som innehåller varje instans som körs på den angivna datorn.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Du kan använda denna matris, till exempel för att stänga alla instanser av den körbara filen."
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "Namnet som används för att identifiera processen för användaren."
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen saknar en identifierare eller ingen process som är associerad med den <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.       - eller - den associerade processen har avslutats."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; till <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Processen finns inte på den här datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar eller anger processorer som trådarna i den här processen kan schemaläggas att köras."
  remarks: "I Windows 2000 och senare, kan en tråd i en process migrera från processorn till processor, med varje migrering ladda processorcache. Under tunga systembelastningar kan anger vilken processor bör köra en specifik tråd förbättra prestanda genom att minska antalet gånger som laddas processorcache. Processortillhörighet kallas för en association mellan en processor och en tråd.       Varje processor representeras som en stund. Bit 0 är processor en är bit 1 processor två och så vidare. Om du anger en bit värdet 1, väljs motsvarande processorn för tråden tilldelning. När du ställer in värdet till noll ProcessorAffinity Ange operativsystemets schemaläggning algoritmer trådens tillhörighet. När ProcessorAffinity värdet anges till ett värde som inte är noll, är värdet tolkas som en bitmask som anger de processorerna som är berättigade för val.       I följande tabell visas ett urval av ProcessorAffinity värden för ett system med åtta processorer.      | Bitmask | Binärvärde | Tillgängliga processorer |   |-------------|------------------|-------------------------|   | 0x0001 | 00000000 00000001 | 1 |   | 0x0003 | 00000000 00000011 | 1 och 2 |   | 0x0007 | 00000000 00000111 | 1, 2 och 3 |   | 0x0009 | 00000000 00001001 | 1 och 4 |   | 0x007F | 00000000 01111111 | 1, 2, 3, 4, 5, 6 och 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "En bitmask som representerar de processorer som trådarna i den associerade processen kan köras på. Standardvärdet beror på antalet processorer på datorn. Standardvärdet är 2 <sup>n</sup> -1, där n är antalet processorer."
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "ProcessorAffinity information kunde inte ange eller hämta från den associerade process resursen.       - eller - process-ID eller processreferensen är noll. (Processen har inte startats.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen ProcessorAffinity för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen <xref:System.Diagnostics.Process.Id*>inte var tillgänglig.</xref:System.Diagnostics.Process.Id*>       - eller - processen har avslutats."
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Tar bort all information om den associerade processen som har cachelagrats i processkomponenten."
  remarks: "När uppdateringen kallas, gör den första begäranden för information om varje egenskap processkomponenten att hämta ett nytt värde från den associerade processen.       När en <xref:System.Diagnostics.Process>komponent som är kopplad till en process-resurs, värden för den <xref:System.Diagnostics.Process>fylls omedelbart efter status för den associerade processen.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Om informationen om den associerade processen ändras senare, visas inte ändringarna i den <xref:System.Diagnostics.Process>komponentens cachelagrade värden.</xref:System.Diagnostics.Process> Den <xref:System.Diagnostics.Process>komponenten är en ögonblicksbild av resursen processen vid den tidpunkt som de är kopplade.</xref:System.Diagnostics.Process> Anropa metoden uppdatera om du vill visa de aktuella värdena för den associerade processen."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar ett värde som anger om användargränssnittet för processen svarar."
  remarks: "Om en process har ett användargränssnitt, kontaktar egenskapen svarar användargränssnittet för att avgöra om processen svarar på indata från användaren. Om gränssnittet inte svarar omedelbart, svarar egenskapen returnerar `false`. Använd den här egenskapen för att avgöra om gränssnittet för den associerade processen har slutat svara.       Om processen inte har en <xref:System.Diagnostics.Process.MainWindowHandle%2A>, den här egenskapen returnerar `true`.</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>om användargränssnittet för den associerade processen svarar på systemet. Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; till <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det finns ingen process som är associerade med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen svarar för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den egna referensen till den här processen."
  remarks: "Referensen är endast tillgängligt om den anropande komponenten startade processen."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "Den egna referensen till den här processen."
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar Terminal Services-sessions-ID för den associerade processen."
  remarks: "Egenskapen SessionId identifierar sessionen där programmet körs."
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "Terminal Services sessionsidentifierare för den associerade processen."
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Det finns ingen session som är associerade med den här processen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det finns ingen process som är associerad med den här sessionsidentifierare.       - eller - den associerade processen finns inte på den här datorn."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Egenskapen SessionId stöds inte i Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar en dataström som används för att läsa Felutdata från programmet."
  remarks: "När en <xref:System.Diagnostics.Process>skriver texten till dess standardfelströmmen texten visas normalt på konsolen.</xref:System.Diagnostics.Process> Genom att omdirigera StandardError-dataströmmen kan du manipulera eller utelämna fel resultatet av en process. Du kan till exempel filtrera texten, formatera annorlunda eller skriva utdata till både konsolen och en loggfil som är avsedda.      > [!NOTE] > För att använda StandardError, måste du ange <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>till `false`, och du måste ange <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>till `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Annars utlöser läsning från StandardError-dataströmmen ett undantag.       Omdirigerade StandardError-dataströmmen kan läsas synkront eller asynkront. Metoder som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, och <xref:System.IO.StreamReader.ReadToEnd%2A>utföra synkron läsåtgärder på fel utdataströmmen processens.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Dessa synkron läsa operations inte behöver du göra förrän den associerade <xref:System.Diagnostics.Process>skriver till dess StandardError-dataströmmen eller stänger dataströmmen.</xref:System.Diagnostics.Process>       Däremot <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>startar asynkrona läsåtgärder på StandardError-dataströmmen.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Den här metoden aktiverar en avsedda händelsehanteraren för strömmad utdata och returnerar omedelbart till anroparen som kan utföra annat arbete när strömmad utdata omdirigeras till händelsehanteraren.       Synkron läsåtgärder införa ett beroende mellan anroparen läsning från StandardError-dataströmmen och den underordnade processen skriva till dataströmmen. Dessa beroenden kan orsaka deadlock villkor. När anroparen läser från en underordnad process omdirigerade dataströmmen, är det beroende av underordnat. Anroparen väntar på Läsåtgärden tills underordnat skriver till dataströmmen eller stänger dataströmmen. När den underordnade processen skriver tillräckligt med data för att fylla sin omdirigerade stream, är det beroende av överordnat. Den underordnade processen väntar på nästa Skrivåtgärden tills överordnad läser från dataströmmen fullständig eller stänger dataströmmen. Dödläge resultatet när anroparen och underordnad process vänta på att slutföra en åtgärd, och ingen av dem kan fortsätta. Du kan undvika deadlocks genom utvärdering av beroenden mellan anroparen och underordnad process.       Följande C#-kod visar till exempel hur du läser från en dataström med omdirigerade och vänta tills den underordnade processen avslutas.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```Kodexemplet undviker ett dödläge genom att anropa `p.StandardError.ReadToEnd` innan `p.WaitForExit`. Ett dödläge kan uppstå om överordnat behandla samtal `p.WaitForExit` innan `p.StandardError.ReadToEnd` och den underordnade processen skriver tillräckligt med text för att fylla omdirigerade dataströmmen. Den överordnade processen ska vänta på obestämd tid för den underordnade processen avslutas. Den underordnade processen skulle vänta på obestämd tid för överordnat att läsa från fullständig StandardError-dataströmmen.       Det finns ett liknande problem när du Läs all text från både standardutdata och standardfel dataströmmar. Följande C#-kod utför till exempel en Läsåtgärd på båda dataströmmar.      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```Kodexemplet undviker dödläge genom att utföra asynkrona läsåtgärder på den <xref:System.Diagnostics.Process.StandardOutput%2A>dataström.</xref:System.Diagnostics.Process.StandardOutput%2A> Ett dödläge resultat om överordnat behandla samtal `p.StandardOutput.ReadToEnd` följt av `p.StandardError.ReadToEnd` och den underordnade processen skriver tillräckligt med text för att fylla sin fel-dataström. Den överordnade processen ska vänta på obestämd tid för den underordnade processen att stänga dess <xref:System.Diagnostics.Process.StandardOutput%2A>dataström.</xref:System.Diagnostics.Process.StandardOutput%2A> Den underordnade processen skulle vänta på obestämd tid för överordnat att läsa från fullständig StandardError-dataströmmen.       Du kan använda asynkrona läsåtgärder för att undvika dessa beroenden och deras potentiella dödläge. Alternativt kan undvika du dödläge genom att skapa två trådar och läsa utdata från varje ström på en separat tråd.      > [!NOTE] > Du inte kan blanda asynkrona och synkrona läsåtgärder på en omdirigerade dataström. När den omdirigerade dataströmmen en <xref:System.Diagnostics.Process>har öppnats asynkront eller i synkront läge, alla ytterligare Läs-operationer på dataströmmen måste vara i samma läge.</xref:System.Diagnostics.Process> Till exempel följa inte <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>med ett anrop till <xref:System.IO.StreamReader.ReadLine%2A>på StandardError-dataströmmen eller tvärtom.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Du kan dock läsa två olika dataströmmar i olika lägen. Exempelvis kan du anropa <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>och sedan anropa <xref:System.IO.StreamReader.ReadLine%2A>för StandardError-dataströmmen.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "En <xref:System.IO.StreamReader>som kan användas för att läsa standardfeldataström för programmet.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar en dataström som används för att skriva indata för programmet."
  remarks: "En <xref:System.Diagnostics.Process>kan läsa indata från dess Standardindataström, vanligtvis tangentbordet.</xref:System.Diagnostics.Process> Du kan via programmering ange indata genom att omdirigera StandardInput-dataströmmen. I stället för att använda tangentbordet kan ange du exempelvis text från innehållet i en angiven fil eller utdata från ett annat program.      > [!NOTE] > Om du vill använda StandardInput måste du ange <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>till `false`, och du måste ange <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>till `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Annars kan utlöser skrivning till StandardInput dataströmmen ett undantag."
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "En <xref:System.IO.StreamWriter>som kan användas för att skriva Standardindataström för programmet.</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "StandardInput-dataströmmen har inte definierats eftersom &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; är inställd på <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar en dataström som används för att läsa textrepresentation utdata från programmet."
  remarks: "När en <xref:System.Diagnostics.Process>skriver texten till dess standard dataströmmen texten visas normalt på konsolen.</xref:System.Diagnostics.Process> Du kan ändra eller utelämna resultatet av en process genom att omdirigera StandardOutput-dataströmmen. Du kan till exempel filtrera texten, formatera annorlunda eller skriva utdata till både konsolen och en loggfil som är avsedda.      > [!NOTE] > Om du vill använda StandardOutput måste du ange <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>till `false`, och du måste ange <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>till `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Annars utlöser läsning från StandardOutput-dataströmmen ett undantag.       Omdirigerade StandardOutput-dataströmmen kan läsas synkront eller asynkront. Metoder som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, och <xref:System.IO.StreamReader.ReadToEnd%2A>utföra synkron läsåtgärder på utdataströmmen processens.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Dessa synkron läsa operations inte behöver du göra förrän den associerade <xref:System.Diagnostics.Process>skriver till dess StandardOutput-dataströmmen eller stänger dataströmmen.</xref:System.Diagnostics.Process>       Däremot <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>startar asynkrona läsåtgärder på StandardOutput-dataströmmen.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Den här metoden aktiverar en avsedda händelsehanteraren för strömmad utdata och returnerar omedelbart till anroparen som kan utföra annat arbete när strömmad utdata omdirigeras till händelsehanteraren.       Synkron läsåtgärder införa ett beroende mellan anroparen läsning från StandardOutput-dataströmmen och den underordnade processen skriva till dataströmmen. Dessa beroenden kan orsaka deadlock villkor. När anroparen läser från en underordnad process omdirigerade dataströmmen, är det beroende av underordnat. Anroparen väntar på Läsåtgärden tills underordnat skriver till dataströmmen eller stänger dataströmmen. När den underordnade processen skriver tillräckligt med data för att fylla sin omdirigerade stream, är det beroende av överordnat. Den underordnade processen väntar på nästa Skrivåtgärden tills överordnad läser från dataströmmen fullständig eller stänger dataströmmen. Dödläge resultatet när anroparen och underordnad process vänta på att slutföra en åtgärd, och ingen av dem kan fortsätta. Du kan undvika deadlocks genom utvärdering av beroenden mellan anroparen och underordnad process.       Följande C#-kod visar till exempel hur du läser från en dataström med omdirigerade och vänta tills den underordnade processen avslutas.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```Kodexemplet undviker ett dödläge genom att anropa `p.StandardOutput.ReadToEnd` innan `p.WaitForExit`. Ett dödläge kan uppstå om överordnat behandla samtal `p.WaitForExit` innan `p.StandardOutput.ReadToEnd` och den underordnade processen skriver tillräckligt med text för att fylla omdirigerade dataströmmen. Den överordnade processen ska vänta på obestämd tid för den underordnade processen avslutas. Den underordnade processen skulle vänta på obestämd tid för överordnat att läsa från den fullständiga StandardOutput-dataströmmen.       Det finns ett liknande problem när du Läs all text från både standardutdata och standardfel dataströmmar. Följande C#-kod utför till exempel en Läsåtgärd på båda dataströmmar.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```Kodexemplet undviker dödläge genom att utföra asynkrona läsåtgärder på StandardOutput-dataströmmen. Ett dödläge resultat om överordnat behandla samtal `p.StandardOutput.ReadToEnd` följt av `p.StandardError.ReadToEnd` och den underordnade processen skriver tillräckligt med text för att fylla sin fel-dataström. Den överordnade processen ska vänta på obestämd tid för den underordnade processen att stänga dess StandardOutput-dataströmmen. Den underordnade processen skulle väntar tills överordnat att läsa från hela <xref:System.Diagnostics.Process.StandardError%2A>dataström.</xref:System.Diagnostics.Process.StandardError%2A>       Du kan använda asynkrona läsåtgärder för att undvika dessa beroenden och deras potentiella dödläge. Alternativt kan undvika du dödläge genom att skapa två trådar och läsa utdata från varje ström på en separat tråd.      > [!NOTE] > Du inte kan blanda asynkrona och synkrona läsåtgärder på en omdirigerade dataström. När den omdirigerade dataströmmen en <xref:System.Diagnostics.Process>har öppnats asynkront eller i synkront läge, alla ytterligare Läs-operationer på dataströmmen måste vara i samma läge.</xref:System.Diagnostics.Process> Till exempel följa inte <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>med ett anrop till <xref:System.IO.StreamReader.ReadLine%2A>på StandardOutput-dataströmmen eller tvärtom.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Du kan dock läsa två olika dataströmmar i olika lägen. Exempelvis kan du anropa <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>och sedan anropa <xref:System.IO.StreamReader.ReadLine%2A>för den <xref:System.Diagnostics.Process.StandardError%2A>dataström.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "En <xref:System.IO.StreamReader>som kan användas för att läsa Standardutdataström för programmet.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Startar (eller återanvänder) process resursen som anges av den <xref:System.Diagnostics.Process.StartInfo*>egenskapen för detta <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som associeras med komponenten.</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om en resurs för processen startas; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om någon resurs för processen startas (till exempel om en befintlig process återanvänds)."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Inget filnamn har angetts i den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponentens <> </> *>.       - eller - &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; medlem i den <> </> *> egenskapen är <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> medan &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;, eller &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; är <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett fel uppstod i den associerade filen öppnades."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har redan tagits bort."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Startar processen resursen som anges av parametern som innehåller information om processen (till exempel filnamn av processen för att starta) och associerar resursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "Den <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> som innehåller den information som används för att starta processen, inklusive filnamnet och kommandoradsargument."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som är associerad med process-resurs eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om ingen resurs i processen startas. Observera att en ny process startas tillsammans med instanser av samma process som körs redan är oberoende av varandra. Dessutom Start kan returnera en icke-null-Process med dess <xref:System.Diagnostics.Process.HasExited*>redan egenskapsuppsättningen till <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I det här fallet kan startade processen har aktiverats en befintlig instans av sig själv och sedan avslutades."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Inget filnamn har angetts i den <code> startInfo </code> parameterns <> </> *> egenskapen.       -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.       - eller - <> </> *>-egenskapen för den <code> startInfo </code> parametern är <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> och <> </> *>-egenskapen är inte <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> eller tomt eller <> </> *>-egenskapen är inte <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har redan tagits bort."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Filen som anges i den <code> startInfo </code> parameterns <xref:System.Diagnostics.ProcessStartInfo.FileName*>gick inte att hitta egenskapen.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett fel uppstod när du öppnar den associerade filen.       - eller - summan av argumenten längd och längden på den fullständiga sökvägen till processen överstiger 2 080. Felmeddelandet som är associerade med det här undantaget kan vara något av följande: &quot;dataområdet skickas till ett systemanrop är för liten.&quot; eller &quot;Åtkomst nekad&quot;."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Startar en resurs i processen genom att ange namnet på en fil som dokument eller program och associerar resursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Namnet på ett dokument eller program fil som körs i processen."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som är associerad med process-resurs eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om ingen resurs i processen startas. Observera att en ny process startas tillsammans med instanser av samma process som körs redan är oberoende av varandra. Dessutom Start kan returnera en icke-null-Process med dess <xref:System.Diagnostics.Process.HasExited*>redan egenskapsuppsättningen till <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I det här fallet kan startade processen har aktiverats en befintlig instans av sig själv och sedan avslutades."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett fel uppstod när du öppnar den associerade filen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har redan tagits bort."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "PATH-miljövariabeln har en sträng med citattecken."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Startar en resurs i processen genom att ange namnet på ett program och en uppsättning argument på kommandoraden och associerar resursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "Namnet på en fil för programmet att köras i processen."
    - id: arguments
      type: System.String
      description: "Kommandoradsargument för att skicka när den startas."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som är associerad med process-resurs eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om ingen resurs i processen startas. Observera att en ny process startas tillsammans med instanser av samma process som körs redan är oberoende av varandra. Dessutom Start kan returnera en icke-null-Process med dess <xref:System.Diagnostics.Process.HasExited*>redan egenskapsuppsättningen till <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I det här fallet kan startade processen har aktiverats en befintlig instans av sig själv och sedan avslutades."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett fel uppstod när du öppnar den associerade filen.       - eller - summan av argumenten längd och längden på den fullständiga sökvägen till processen överstiger 2 080. Felmeddelandet som är associerade med det här undantaget kan vara något av följande: &quot;dataområdet skickas till ett systemanrop är för liten.&quot; eller &quot;Åtkomst nekad&quot;."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har redan tagits bort."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "PATH-miljövariabeln har en sträng med citattecken."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Startar en resurs i processen genom att ange namnet på ett program, ett användarnamn, lösenord och en domän och associerar resursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Du kan använda den här överlagring för att skapa en ny process och dess primära tråden genom att ange dess namn, användarnamn, lösenord och domän. Den nya processen körs sedan den körbara filen i säkerhetskontexten för de angivna autentiseringsuppgifterna (användare, domän och lösenord).      > [!NOTE] > När den körbara filen finns på en fjärransluten enhet, måste du identifiera nätverksresursen med hjälp av en uniform resource identifier (URI), inte en länkad enhetsbeteckning.      > [!NOTE] > Om en URL är adressen till den körbara filen för att starta processen inte har startats och `null` returneras.       Den här överlagring kan du starta en process utan att först skapa en ny <xref:System.Diagnostics.Process>instans.</xref:System.Diagnostics.Process> Överlagring är ett alternativ till explicit stegen för att skapa en ny <xref:System.Diagnostics.Process>instansen, ange den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, och <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Egenskaper för den <xref:System.Diagnostics.Process.StartInfo%2A>egenskapen och anropar <xref:System.Diagnostics.Process.Start%2A>för den <xref:System.Diagnostics.Process>instans.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       På samma sätt på samma sätt som den **kör** dialogrutan kan acceptera ett namn på körbar fil med eller utan filnamnstillägget .exe, filnamnstillägget .exe är valfritt i den `fileName` parametern. Du kan till exempel ange det `fileName` parametern &quot;Notepad.exe&quot; eller &quot;Anteckningar&quot;. Om den `fileName` parametern representerar en körbar fil på `arguments` parameter kan representera en fil kan vidta åtgärder, till exempel textfil i `Notepad.exe myfile.txt`.      > [!NOTE] > Filnamnet måste representera en körbar fil i den <xref:System.Diagnostics.Process.Start%2A>överlagringar som har `userName`, `password`, och `domain` parametrar.</xref:System.Diagnostics.Process.Start%2A>       När du använder <xref:System.Diagnostics.Process.Start%2A>för att starta en process, du kan behöva stänga eller riskerar du att förlora systemresurser.</xref:System.Diagnostics.Process.Start%2A> Stäng processer med hjälp av <xref:System.Diagnostics.Process.CloseMainWindow%2A>eller <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Du kan kontrollera om en process redan har avslutats med hjälp av dess <xref:System.Diagnostics.Process.HasExited%2A>egenskap...</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Namnet på en fil för programmet att köras i processen."
    - id: userName
      type: System.String
      description: "Användarnamnet som ska användas när den startas."
    - id: password
      type: System.Security.SecureString
      description: "En <xref href=&quot;System.Security.SecureString&quot;> </xref> som innehåller lösenordet som ska användas när den startas."
    - id: domain
      type: System.String
      description: "Domänen som ska användas när den startas."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som är associerad med process-resurs eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om ingen resurs i processen startas. Observera att en ny process startas tillsammans med instanser av samma process som körs redan är oberoende av varandra. Dessutom Start kan returnera en icke-null-Process med dess <xref:System.Diagnostics.Process.HasExited*>redan egenskapsuppsättningen till <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I det här fallet kan startade processen har aktiverats en befintlig instans av sig själv och sedan avslutades."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Inget filnamn har angetts."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett fel uppstod i den associerade filen öppnades."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har redan tagits bort."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Startar en resurs i processen genom att ange namnet på ett program, en uppsättning argument på kommandoraden, ett användarnamn, lösenord och en domän och associerar resursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Du kan använda den här överlagring för att skapa en ny process och dess primära tråden genom att ange dess namn, kommandoradsargument, användarnamn, lösenord och domän. Den nya processen körs sedan den körbara filen i säkerhetskontexten för de angivna autentiseringsuppgifterna (användare, domän och lösenord).      > [!NOTE] > När den körbara filen finns på en fjärransluten enhet, måste du identifiera nätverksresursen med hjälp av en uniform resource identifier (URI), inte en länkad enhetsbeteckning.      > [!NOTE] > Om en URL är adressen till den körbara filen för att starta processen inte har startats och `null` returneras.       Den här överlagring kan du starta en process utan att först skapa en ny <xref:System.Diagnostics.Process>instans.</xref:System.Diagnostics.Process> Överlagring är ett alternativ till explicit stegen för att skapa en ny <xref:System.Diagnostics.Process>instansen, ange den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, och <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Egenskaper för den <xref:System.Diagnostics.Process.StartInfo%2A>egenskapen och anropar <xref:System.Diagnostics.Process.Start%2A>för den <xref:System.Diagnostics.Process>instans.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       På samma sätt på samma sätt som den **kör** dialogrutan kan acceptera ett namn på körbar fil med eller utan filnamnstillägget .exe, filnamnstillägget .exe är valfritt i den `fileName` parametern. Du kan till exempel ange det `fileName` parametern &quot;Notepad.exe&quot; eller &quot;Anteckningar&quot;. Om den `fileName` parametern representerar en körbar fil på `arguments` parameter kan representera en fil kan vidta åtgärder, till exempel textfil i `Notepad.exe myfile.txt`.      > [!NOTE] > Filnamnet måste representera en körbar fil i den <xref:System.Diagnostics.Process.Start%2A>överlagringar som har `userName`, `password`, och `domain` parametrar.</xref:System.Diagnostics.Process.Start%2A>       När du använder <xref:System.Diagnostics.Process.Start%2A>för att starta en process, du kan behöva stänga eller riskerar du att förlora systemresurser.</xref:System.Diagnostics.Process.Start%2A> Stäng processer med hjälp av <xref:System.Diagnostics.Process.CloseMainWindow%2A>eller <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Du kan kontrollera om en process redan har avslutats med hjälp av dess <xref:System.Diagnostics.Process.HasExited%2A>egenskap...</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Namnet på en fil för programmet att köras i processen."
    - id: arguments
      type: System.String
      description: "Kommandoradsargument för att skicka när den startas."
    - id: userName
      type: System.String
      description: "Användarnamnet som ska användas när den startas."
    - id: password
      type: System.Security.SecureString
      description: "En <xref href=&quot;System.Security.SecureString&quot;> </xref> som innehåller lösenordet som ska användas när den startas."
    - id: domain
      type: System.String
      description: "Domänen som ska användas när den startas."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som är associerad med process-resurs eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om ingen resurs i processen startas. Observera att en ny process startas tillsammans med instanser av samma process som körs redan är oberoende av varandra. Dessutom Start kan returnera en icke-null-Process med dess <xref:System.Diagnostics.Process.HasExited*>redan egenskapsuppsättningen till <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I det här fallet kan startade processen har aktiverats en befintlig instans av sig själv och sedan avslutades."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Inget filnamn har angetts."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett fel uppstod när du öppnar den associerade filen.       - eller - summan av argumenten längd och den fullständiga sökvägen till den associerade filen längd överstiger 2 080. Felmeddelandet som är associerade med det här undantaget kan vara något av följande: &quot;dataområdet skickas till ett systemanrop är för liten.&quot; eller &quot;Åtkomst nekad&quot;."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har redan tagits bort."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar eller anger egenskaperna för att skicka till den <xref:System.Diagnostics.Process.Start*>metod för den <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo representerar uppsättningen parametrar som ska användas för att starta en process. När <xref:System.Diagnostics.Process.Start%2A>är anropas på StartInfo används för att ange att processen startas.</xref:System.Diagnostics.Process.Start%2A> Endast nödvändiga StartInfo medlemmen att ange den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Starta en process genom att ange den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen liknar att skriva in informationen i den **kör** dialogrutan i Windows **starta** menyn.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Därför kan den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen behöver inte representerar en körbar fil.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Det kan vara av valfri filtyp som tillägget har associerats med ett program som är installerade i systemet. Till exempel den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>kan ha filnamnstillägget .txt om du har associerat textfiler med en textredigerare, till exempel Anteckningar, eller ha en doc om du har associated.doc filer med ett ordbehandlingsprogram verktyg som Microsoft Word.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> På samma sätt på samma sätt som den **kör** dialogrutan kan acceptera ett namn på körbar fil med eller utan filnamnstillägget .exe, filnamnstillägget .exe är valfritt i den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>medlemmen.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Du kan till exempel ange det <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen till &quot;Notepad.exe&quot; eller &quot;Anteckningar&quot;.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Du kan starta ett ClickOnce-program genom att ange den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen till plats (till exempel en webbadress) från vilken du installerade programmet.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Starta inte ett ClickOnce-program genom att ange installationsplatsen på hårddisken.       Om filnamnet omfattar en icke körbara fil, till exempel en DOC-fil kan du inkludera ett verb som anger vilken åtgärd som ska vidtas på filen. Du kan exempelvis ange den <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>till &quot;Print&quot; för en fil som slutar med tillägget .doc.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Filnamnet som anges i den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen behöver inte ha ett tillägg om du manuellt ange ett värde för den <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>egenskapen.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Men om du använder den <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>egenskapen fastställa vilka verb som är tillgängliga, måste du inkludera filnamnstillägget.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       Du kan ändra de parametrar som anges i egenskapen StartInfo upp till den tid som du anropar den <xref:System.Diagnostics.Process.Start%2A>metoden på processen.</xref:System.Diagnostics.Process.Start%2A> När du har startat processen ändrar StartInfo värdena inte påverkar eller starta om den associerade processen. Om du anropar den <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>metod med den <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>och <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>uppsättning egenskaper, den ohanterade `CreateProcessWithLogonW` funktionen anropas, vilket startar processen i ett nytt fönster även om den <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>egenskapsvärdet är `true` eller <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>egenskapsvärdet är <xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       Om du inte använde den <xref:System.Diagnostics.Process.Start%2A>metod för att starta en process egenskapen StartInfo avspeglar inte de parametrar som används för att starta processen.</xref:System.Diagnostics.Process.Start%2A> Om du använder till exempel <xref:System.Diagnostics.Process.GetProcesses%2A>att hämta en matris med processer som körs på datorn, egenskapen StartInfo för varje <xref:System.Diagnostics.Process>innehåller inte det ursprungliga filnamnet eller argument som används för att starta processen.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       När processen startas filnamnet är den fil som fyller på (skrivskyddad) <xref:System.Diagnostics.Process.MainModule%2A>egenskap.</xref:System.Diagnostics.Process.MainModule%2A> Om du vill hämta den körbara filen som är associerade med processen när processen har startats ska du använda den <xref:System.Diagnostics.Process.MainModule%2A>egenskapen.</xref:System.Diagnostics.Process.MainModule%2A> Om du vill ange den körbara filen för en <xref:System.Diagnostics.Process>instansen för som en associerade processen har inte startats använder egenskapen StartInfo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>medlem.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> Eftersom medlemmarna i egenskapen StartInfo är argument som skickas till den <xref:System.Diagnostics.Process.Start%2A>metoden för en process som ändrar den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen när den associerade processen har startats återställs inte den <xref:System.Diagnostics.Process.MainModule%2A>egenskapen.</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> De här egenskaperna används bara för att initiera den associerade processen."
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "Den <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> som representerar data som du vill starta processen. De här argumenten inkludera namnet på den körbara filen eller dokument som används för att starta processen."
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Är det värde som anger StartInfo <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den tid då den associerade processen startades."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Ett objekt som anger när processen startas. Ett undantag om processen inte körs."
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen StartTime för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen har avslutats.       - eller - processen har inte startats."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ett fel uppstod i anropet till funktionen Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar eller anger det objekt som används för att konvertera de händelsehanteraranrop som utfärdas till följd av händelsen för Avsluta en process."
  remarks: "När <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>är `null`, metoder som hanterar den <xref:System.Diagnostics.Process.Exited>händelse anropas på en tråd från system trådpoolen.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Mer information om system tråd pooler finns <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       När den <xref:System.Diagnostics.Process.Exited>händelsen hanterats av en visual Windows Forms-komponent som en <xref:System.Windows.Forms.Button>, att komma åt komponenten trådpoolen system kanske inte fungerar eller leda till ett undantag.</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> Undvik detta genom att ange SynchronizingObject till en Windows Forms-komponent, vilket gör att de metoder som hanterar den <xref:System.Diagnostics.Process.Exited>händelse anropas på samma tråd där komponenten skapades.</xref:System.Diagnostics.Process.Exited>       Om den <xref:System.Diagnostics.Process>används i [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] SynchronizingObject anges i en Windows Forms-designer automatiskt till den kontroll som innehåller <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Till exempel om du placerar en <xref:System.Diagnostics.Process>på en designer för `Form1` (som ärver från <xref:System.Windows.Forms.Form>) SynchronizingObject-egenskapen för <xref:System.Diagnostics.Process>anges till instansen av `Form1`: [!code-cpp [Process_SynchronizingObject&#2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject&#2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject&#2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ] vanligtvis den här egenskapen anges när komponenten placeras inuti en kontroll eller ett formulär, eftersom dessa komponenter är kopplade till en specifik tråd.    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "Den <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> används för att konvertera händelsehanteraranrop som utfärdas till följd av ett <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> händelse på processen."
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar uppsättningen trådar som körs i den associerade processen."
  remarks: "En tråd kör kod i en process. Varje process har startats med en enskild tråd dess primära tråden. En tråd kan skapa ytterligare trådar. Trådar i en process dela adressutrymmet för processen.       Använd <xref:System.Diagnostics.ProcessThread>att hämta alla trådar som är associerade med den aktuella processen.</xref:System.Diagnostics.ProcessThread> Den primära tråden är inte nödvändigtvis vid index noll i matrisen."
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "En matris av typen <xref href=&quot;System.Diagnostics.ProcessThread&quot;> </xref> som representerar operativsystemet trådar som körs i den associerade processen."
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Processen har inte en <xref:System.Diagnostics.Process.Id*>, eller någon process som är associerad med den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> instans.</xref:System.Diagnostics.Process.Id*>       - eller - den associerade processen har avslutats."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me); Ange &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; till <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> åtkomst till den här egenskapen i Windows 98 och Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Formaterar processens namn som en sträng, i kombination med den överordnade komponenttypen om tillämpligt."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Den <> </> *>, kombinerat med komponenten grundläggande <> </> *> returvärde."
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "ToString stöds inte i Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den totala processortiden för den här processen."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "En <xref:System.TimeSpan>som anger hur lång tid som den associerade processen har använt för att använda Processorn.</xref:System.TimeSpan> Det här värdet är summan av den <> </> *> och <> </> *>."
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen TotalProcessorTime för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar processortid användaren för den här processen."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "En <xref:System.TimeSpan>som anger hur lång tid som den associerade processen har använt för att köra kod i programmet del av processen (inte i operativsystemets kärna).</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du försöker komma åt egenskapen UserProcessorTime för en process som körs på en fjärrdator. Den här egenskapen är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar storleken på processens virtuellt minne i byte."
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "Mängden virtuellt minne i byte som har begärt att den associerade processen."
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden virtuellt minne i byte som tilldelats för den associerade processen."
  remarks: "Värdet som returneras av denna egenskap representerar den aktuella storleken för virtuellt minne som används av processen i byte. Operativsystemet mappar det virtuella adressutrymmet för varje process som antingen sidorna läses in i det fysiska minnet eller på sidor som lagras i virtuella minnets växlingsfil på disken.       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **virtuell storlek-byte** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Mängden virtuellt minne i byte som tilldelats för den associerade processen."
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Anger den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten tidsgräns för den associerade processen avslutas."
  remarks: "WaitForExit gör den aktuella tråden vänta tills den associerade processen avslutas.  Anropas när alla andra metoder anropas på processen. För att undvika blockerar den aktuella tråden kan använda den <xref:System.Diagnostics.Process.Exited>händelse.</xref:System.Diagnostics.Process.Exited>       Den här metoden gör den <xref:System.Diagnostics.Process>komponenten vänta en oändlig tidsperiod att avsluta processen och händelse hanterarna.</xref:System.Diagnostics.Process> Detta kan orsaka ett program slutar svara. Om du anropar exempelvis <xref:System.Diagnostics.Process.CloseMainWindow%2A>för en process som har ett användargränssnitt begäran till operativsystemet att avsluta den tillhörande processen kan inte hanteras om processen skrivs till aldrig ange dess meddelandeloop.</xref:System.Diagnostics.Process.CloseMainWindow%2A>      > [!NOTE] > I den [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] och tidigare versioner WaitForExit överlagring väntade <xref:System.Int32.MaxValue>millisekunder (cirka 24 dagar) inte under obestämd tid.</xref:System.Int32.MaxValue> Dessutom tidigare versioner inte vänta för händelsehanterare att avsluta om hela <xref:System.Int32.MaxValue>har uppnåtts.</xref:System.Int32.MaxValue>       Den här överlagring garanterar att all bearbetning har slutförts, inklusive hantering av asynkrona händelser för omdirigerade standardutdata. Du bör använda den här överlagring efter ett anrop till den <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>överlagra när standardutdata har omdirigerats till asynkron händelsehanterare.</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       När en associerade processen avslutas (det vill säga när det stängs av operativsystemet via en normal eller onormal avslutning), systemet lagrar administrativ information om processen och returnerar till komponenten som hade anropat WaitForExit. Den <xref:System.Diagnostics.Process>komponent kan sedan komma åt information som innehåller den <xref:System.Diagnostics.Process.ExitTime%2A>, med hjälp av den <xref:System.Diagnostics.Process.Handle%2A>till stängts processen.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Eftersom den associerade processen har avslutats av <xref:System.Diagnostics.Process.Handle%2A>-egenskapen för komponenten längre pekar på en befintlig resurs process.</xref:System.Diagnostics.Process.Handle%2A> I stället kan referensen användas till operativsystemets information om processen för resursen. Systemet är medveten om referenser till stängts processer som inte getts ut av <xref:System.Diagnostics.Process>komponenter, så den bevarar de <xref:System.Diagnostics.Process.ExitTime%2A>och <xref:System.Diagnostics.Process.Handle%2A>information i minnet tills den <xref:System.Diagnostics.Process>komponenten uttryckligen frigör resurser.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Därför varje gång du anropar <xref:System.Diagnostics.Process.Start%2A>för en <xref:System.Diagnostics.Process>instans, anropet <xref:System.Diagnostics.Process.Close%2A>när den associerade processen har avslutats och du inte längre behöver några administrativa information om det.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>Frigör det minne som allokerats till stängts processen.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det gick inte att vänteinställningen."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Det finns ingen process <> </> *> har ställts in och en <> </> *> som den <xref:System.Diagnostics.Process.Id*>egenskapen kan fastställas inte finns.</xref:System.Diagnostics.Process.Id*>       - eller - det finns ingen process som är associerade med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt.       - eller - du försöker anropa WaitForExit för en process som körs på en fjärrdator. Den här metoden är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Anger den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten vänta det angivna antalet millisekunder som den associerade processen avslutas."
  remarks: "WaitForExit gör den aktuella tråden vänta tills den associerade processen avslutas. Anropas när alla andra metoder anropas på processen. För att undvika blockerar den aktuella tråden kan använda den <xref:System.Diagnostics.Process.Exited>händelse.</xref:System.Diagnostics.Process.Exited>       Den här metoden gör den <xref:System.Diagnostics.Process>komponenten vänta en begränsad tidsperiod att avsluta processen.</xref:System.Diagnostics.Process> Om den associerade processen inte avslutas i slutet av intervallet eftersom begäran om att avsluta nekas `false` returneras till den anropande proceduren. Du kan ange ett negativt tal (<xref:System.Threading.Timeout.Infinite>) för `milliseconds`, och WaitForExit kommer fungerar på samma sätt som den <xref:System.Diagnostics.Process.WaitForExit>överlagra.</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> Om du skickar 0 (noll) till metoden, returnerar `true` endast om processen har redan avslutats; annars omedelbart returneras `false`.      > [!NOTE] > I den [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] och tidigare versioner om `milliseconds` är -1, WaitForExit överlagring väntade <xref:System.Int32.MaxValue>millisekunder (cirka 24 dagar) inte under obestämd tid.</xref:System.Int32.MaxValue>       När standardutdata har omdirigerats till asynkron händelsehanterare, är det möjligt att utdata inte ska har slutfört den här metoden returnerar. För att säkerställa att asynkron händelsehantering har slutförts, anropa den <xref:System.Diagnostics.Process.WaitForExit>överlagring som inte tar ingen parameter efter mottagandet en `true` från den här överlagring.</xref:System.Diagnostics.Process.WaitForExit> För att se till att den <xref:System.Diagnostics.Process.Exited>händelsen hanteras på rätt sätt i Windows Forms-program genom att ange den <xref:System.Diagnostics.Process.SynchronizingObject%2A>egenskapen.</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       När en associerade processen avslutas (stängs av operativsystemet via en normal eller onormal avslutning), systemet lagrar administrativ information om processen och returnerar till komponenten som hade anropat WaitForExit. Den <xref:System.Diagnostics.Process>komponent kan sedan komma åt information som innehåller den <xref:System.Diagnostics.Process.ExitTime%2A>, med hjälp av den <xref:System.Diagnostics.Process.Handle%2A>till stängts processen.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Eftersom den associerade processen har avslutats av <xref:System.Diagnostics.Process.Handle%2A>-egenskapen för komponenten längre pekar på en befintlig resurs process.</xref:System.Diagnostics.Process.Handle%2A> I stället kan referensen användas till operativsystemets information om processen för resursen. Systemet är medveten om referenser till stängts processer som inte getts ut av <xref:System.Diagnostics.Process>komponenter, så den bevarar de <xref:System.Diagnostics.Process.ExitTime%2A>och <xref:System.Diagnostics.Process.Handle%2A>information i minnet tills den <xref:System.Diagnostics.Process>komponenten uttryckligen frigör resurser.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Därför varje gång du anropar <xref:System.Diagnostics.Process.Start%2A>för en <xref:System.Diagnostics.Process>instans, anropet <xref:System.Diagnostics.Process.Close%2A>när den associerade processen har avslutats och du inte längre behöver några administrativa information om det.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>Frigör det minne som allokerats till stängts processen.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Hur lång tid i millisekunder för att vänta tills den associerade processen avslutas. Maximalt värdet är det högsta värdet för ett 32-bitars heltal som representerar oändligt för operativsystemet."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den associerade processen har avslutats; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det gick inte att vänteinställningen."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Det finns ingen process <> </> *> har ställts in och en <> </> *> som den <xref:System.Diagnostics.Process.Id*>egenskapen kan fastställas inte finns.</xref:System.Diagnostics.Process.Id*>       - eller - det finns ingen process som är associerade med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt.       - eller - du försöker anropa WaitForExit för en process som körs på en fjärrdator. Den här metoden är endast tillgängligt för processer som körs på den lokala datorn."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Gör den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten tidsgräns för den associerade processen att ange inaktivt läge. Den här överlagring gäller enbart för processer med ett användargränssnitt och därmed meddelandeloop."
  remarks: "Använd WaitForInputIdle för att tvinga bearbetningen av ditt program ska vänta tills meddelandeloopen har återgått till att inaktivt läge. Vid körning av en process med ett användargränssnitt körs dess meddelandeloop varje gång ett Windows-meddelande skickas till processen av operativsystemet. Processen återgår sedan till meddelandeloopen. En process som anses vara inaktiv när den väntar på meddelanden inuti en meddelandeloop. Det här tillståndet är användbart, till exempel när programmet måste vänta på att starta processen skapa dess huvudfönstret innan programmet kommunicerar med fönstret.       Om en process som inte har en meddelandeloop utlöser WaitForInputIdle <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       WaitForInputIdle överlagring instruerar den <xref:System.Diagnostics.Process>komponenten väntar processen ska bli inaktiv i meddelandeloopen.</xref:System.Diagnostics.Process> Den här instruktionen kan orsaka ett program slutar svara. Till exempel om processen skrivs till alltid avsluta dess meddelandeloop omedelbart, som i kodfragmentet `while(true)`."
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den associerade processen har uppnått inaktivt läge."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen saknar ett grafiskt gränssnitt.       - eller - ett okänt fel inträffade. Det gick inte att ange inaktiv processen.       - eller - processen har redan avslutats.       - eller - ingen process har associerats med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Gör den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten vänta det angivna antalet millisekunder som den associerade processen att ange inaktivt läge. Den här överlagring gäller enbart för processer med ett användargränssnitt och därmed meddelandeloop."
  remarks: "Använd WaitForInputIdle för att tvinga bearbetningen av ditt program ska vänta tills meddelandeloopen har återgått till att inaktivt läge. Vid körning av en process med ett användargränssnitt körs dess meddelandeloop varje gång ett Windows-meddelande skickas till processen av operativsystemet. Processen återgår sedan till meddelandeloopen. En process som anses vara inaktiv när den väntar på meddelanden inuti en meddelandeloop. Det här tillståndet är användbart, till exempel när programmet måste vänta på att starta processen skapa dess huvudfönstret innan programmet kommunicerar med fönstret.       Om en process som inte har en meddelandeloop utlöser WaitForInputIdle <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       WaitForInputIdle överlagring instruerar den <xref:System.Diagnostics.Process>komponenten vänta en begränsad tidsperiod för processen ska bli inaktiv i meddelandeloopen.</xref:System.Diagnostics.Process> Om den associerade processen inte har är inaktiv i slutet av intervallet eftersom slingan fortfarande bearbetar meddelanden, `false` returneras till den anropande proceduren.       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Ett värde av 1 till <xref:System.Int32>som anger hur lång tid i millisekunder för att vänta tills den associerade processen ska bli inaktiv.</xref:System.Int32> Värdet 0 anger en omedelbar avkastning, och värdet -1 anger en oändlig väntetid."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den associerade processen har uppnått inaktiv; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Processen saknar ett grafiskt gränssnitt.       - eller - ett okänt fel inträffade. Det gick inte att ange inaktiv processen.       - eller - processen har redan avslutats.       - eller - ingen process har associerats med den här <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objekt."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar den associerade processen fysisk minnesanvändning, i byte."
  remarks: "Värdet som returneras av denna egenskap representerar den aktuella storleken för arbetsminnet som används av processen i byte. Arbetsminnet för en process är uppsättningen minnessidor som för närvarande är synliga för processen i det fysiska RAM-minnet. Dessa sidor är fasta och tillgängliga för ett program kan använda utan att utlösa ett sidfel.       Arbetsminnet innehåller både delade och privata data. Delade data innehåller de sidor som innehåller de instruktioner som processen körs, inklusive processmodulerna och systembibliotek."
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "Den totala mängden fysiskt minne den associerade processen använder, i byte."
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hämtar mängden fysiskt minne i byte som tilldelats för den associerade processen."
  remarks: "Värdet som returneras av denna egenskap representerar den aktuella storleken för arbetsminnet som används av processen i byte. Arbetsminnet för en process är uppsättningen minnessidor som för närvarande är synliga för processen i det fysiska RAM-minnet. Dessa sidor är fasta och tillgängliga för ett program kan använda utan att utlösa ett sidfel.       Arbetsminnet innehåller både delade och privata data. Delade data innehåller de sidor som innehåller de instruktioner som processen körs, inklusive instruktioner i processmodulerna och systembibliotek.       Den här egenskapen kan användas för att övervaka minnesanvändning på datorer med 32-bitars eller 64-bitars processorer. Egenskapsvärdet som motsvarar den **sidmängd** prestandaräknaren för processen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "Mängden fysiskt minne i byte som tilldelats för den associerade processen."
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen är Windows 98 eller Windows ME (Windows Me), som inte stöder den här egenskapen."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
