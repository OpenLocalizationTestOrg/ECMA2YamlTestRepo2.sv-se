### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "Representerar en tillämpningsdomän, vilket är en isolerad miljö där program ska köras. Den här klassen kan inte ärvas."
  remarks: "Programdomäner som representeras av AppDomain-objekt, ger isolering, inaktivera och säkerhet gränser för att köra förvaltad kod.      -Använd programdomäner för att isolera uppgifter som kan få ned en process. Om tillståndet för programdomänen som kör en uppgift blir instabil kan AppDomain inte inaktiveras utan att påverka processen. Detta är viktigt när en process måste köras under långa perioder utan omstart. Du kan också använda programdomäner för att isolera uppgifter som inte ska dela data.      – Om en sammansättning har lästs in i standarddomänen, kan inte den tas bort från minnet när processen körs. Men om du öppnar en andra programdomänen för att ladda och köra sammansättningen inaktiveras sammansättningen när den domänen tas bort. Använd den här tekniken för att minimera arbetsminnet för tidskrävande processer som använder ibland stora DLL-filer.       Flera programdomäner kan köras i en enda process. Det finns dock inte en-till-en korrelation mellan tillämpningsdomäner och trådar. Flera trådar kan höra till en enda domän och när en viss tråd inte är begränsad till en enda programdomän samtidigt, en tråd körs i en enda domän.       Programdomäner skapas med den <xref:System.AppDomain.CreateDomain%2A>metoden.</xref:System.AppDomain.CreateDomain%2A> AppDomain-instanser som används för att ladda och köra sammansättningar (<xref:System.Reflection.Assembly>).</xref:System.Reflection.Assembly> När en AppDomain inte längre används, kan det tas bort från minnet.       AppDomain-klassen implementerar en uppsättning händelser som gör det möjligt att svara när en sammansättning har lästs in, när en tillämpningsdomän tas bort från minnet, eller när ett ohanterat undantag.       Mer information om hur du använder programdomäner finns [programdomäner](~/add/includes/ajax-current-ext-md.md).       Den här klassen implementerar den <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, och <xref:System.Security.IEvidenceFactory>gränssnitt.</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       Du bör aldrig skapa en fjärranslutningsbar Omslutning för en AppDomain-objektet. Då kan publicera en fjärransluten referens till den AppDomain exponerar metoder som <xref:System.AppDomain.CreateInstance%2A>fjärråtkomst och effektivt förstöra kodåtkomstsäkerhet för att AppDomain.</xref:System.AppDomain.CreateInstance%2A> Skadliga klienter som ansluter till fjärranslutas AppDomain kan få tillgång till alla resurser som AppDomain själva har åtkomst till. Skapa inte fjärranslutningsbar omslutningar för någon typ som utökar <xref:System.MarshalByRefObject>och som implementerar metoderna som kan användas av skadliga klienter för att kringgå systemets säkerhet.</xref:System.MarshalByRefObject>      > [!CAUTION] > Standardvärdet för den <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>egenskapen är `false`.</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> Den här inställningen är inte säkert för tjänster. Om du vill förhindra att tjänster hämtas delvis betrodd kod kan du ange egenskapen till `true`."
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar aktiveringskontexten för den aktuella domänen."
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "Ett objekt som representerar aktiveringskontexten för den aktuella domänen i programmet eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om domänen har ingen aktiveringskontext för."
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Lägger till det angivna katalognamnet privat sökväg-listan."
  remarks: "Användning av den här egenskapen rekommenderas inte eftersom den kan ändras avsöknings sökvägen för sammansättningar när de har redan lästs in. Använd den <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>egenskapen i stället.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       Privat sökväg eller relativa sökvägen är sökväg i förhållande till baskatalog där sammansättningen matcharen avsökningar för privata sammansättningar."
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Namnet på katalogen som ska läggas till privat sökväg."
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar identiteten för programmet i programdomänen."
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "Ett objekt som identifierar programmet i programdomänen."
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar information om behörigheterna för ett program och om programmet har en förtroendenivå som att den kan köras."
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "Ett objekt som innehåller information om behörighet och förtroende för programmet i programdomänen."
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Returnerar den sammansättning visningsnamn när principen har tillämpats."
  remarks: "ApplyPolicy metoden tar en sammansättning visningsnamn och returnerar efter visningsnamn. Detta är användbart om du behöver läsa in en sammansättning med hjälp av Grupprincip, eftersom ramen reflection-only inte gäller principen."
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Sammansättningen visningsnamn, i formuläret som tillhandahålls av den &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt; egenskapen."
    return:
      type: System.String
      description: "En sträng som innehåller sammansättningen visningsnamn när principen har tillämpats."
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när en sammansättning har lästs in."
  remarks: "Den <xref:System.AssemblyLoadEventHandler>Delegera för den här händelsen anger vilka sammansättningen har lästs in.</xref:System.AssemblyLoadEventHandler>       Du måste ha behörigheterna som krävs för att registrera en händelsehanterare för den här händelsen, eller en <xref:System.Security.SecurityException>genereras.</xref:System.Security.SecurityException>       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när matchning av en sammansättning inte."
  remarks: "Ansvarar för den <xref:System.ResolveEventHandler>för den här händelsen att returnera sammansättningen som anges av den <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>egenskap, eller för att returnera null om sammansättningen inte är giltig.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> Sammansättningen måste läsas in i en körningskontexten; Om den läses in i ramen reflection-only, misslyckas belastningen som orsakade det här-händelse.       Anvisningar för användning av den här händelsen finns [lösa sammansättningen belastningar](~/add/includes/ajax-current-ext-md.md).       Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>-egenskap returnerar sammansättningen som begärt belastningen sammansättning som inte kunde matchas.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Till exempel kanske inläsaren inte att läsa in ett beroende av den begärande sammansättningen eftersom begärande sammansättningen och dess beroende inte är i avsöknings sökvägen. Känna till den begärande sammansättningen identitet kan vara användbart att hitta beroendet eller för att identifiera rätt version om mer än en version av beroendet är tillgänglig. Mer information finns i <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      > [!IMPORTANT] > Från och med den [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler>händelsen aktiveras för alla sammansättningar, inklusive resurs-sammansättningar.</xref:System.ResolveEventHandler> Händelsen skapades inte för resurs sammansättningar i tidigare versioner. Om operativsystemet är lokaliserade hanteraren kan anropas flera gånger: en gång för varje kultur i återställningsplats kedjan.       För den här händelsen på <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>-egenskap returnerar sammansättningsnamnet innan principen tillämpas.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > Om mer än en händelsehanterare är registrerad för den här händelsen, händelse handlersarecalled i ordning tills en händelsehanterare returnerar ett värde som inte är `null`. Efterföljande händelsehanterare ignoreras.       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar det baskatalog sammansättningen matcharen används för att avsökning för sammansättningar."
  remarks: "Den här egenskapen som motsvarar den <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>egenskapen.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> Det kan också hämtas med hjälp av den <xref:System.AppDomain.GetData%2A>metod med strängen &quot;PROGRAMBASEN&quot;.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "Baskatalog där sammansättningen matcharen att avsökning för sammansättningar."
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Återställer den sökväg som anger platsen för privata sammansättningar som en tom sträng (&quot;&quot;)."
  remarks: "Privat sökväg är en sökväg i förhållande till det baskatalog common language runtime söker igenom för att hitta privata sammansättningar.       Mer information finns i <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Återställer du listan med kataloger som innehåller skuggkopior sammansättningar som en tom sträng (&quot;&quot;)."
  remarks: "Shadow copy sökvägen är en lista över kataloger där shadow kopieras sammansättningar lagras.       Mer information finns i <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>och [Shadow kopierar sammansättningar](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av en viss typ av COM. Parametrar anger namnet på en fil som innehåller en sammansättning som innehåller typen och namnet på typen."
  remarks: "Använd den här metoden för att skapa objekt från en annan dator utan att behöva läsa in typen lokalt.       Det returnera värdet måste vara ett packats upp för att komma åt det verkliga objektet.       En<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName> attributet med värdet `true` måste tillämpas uttryckligen eller standard för COM-typ för den här metoden för att skapa en instans av den typen, annars <xref:System.TypeLoadException>genereras.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Namnet på en fil som innehåller en sammansättning som definierar den begärda typen."
    - id: typeName
      type: System.String
      description: "Namnet på den begärda typen."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen som anges av <code> typeName </code>. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Typen kan inte läsas in."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen offentlig parameterlös konstruktor hittades."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>är en abstrakt klass.       - eller - den här medlemmen anropades med en mekanism med sen bindning."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>en tom sträng (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "COM-objektet som refereras till <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av en viss typ av COM. Parametrar anger namnet på en fil som innehåller en sammansättning som innehåller typen och namnet på typen."
  remarks: "Använd den här metoden för att skapa objekt från en annan dator utan att behöva läsa in typen lokalt.       Det returnera värdet måste vara ett packats upp för att komma åt det verkliga objektet.       En <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>attributet med värdet `true` måste tillämpas uttryckligen eller standard för COM-typ för den här metoden för att skapa en instans av den typen, annars <xref:System.TypeLoadException>genereras.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Namnet på en fil som innehåller en sammansättning som definierar den begärda typen."
    - id: typeName
      type: System.String
      description: "Namnet på den begärda typen."
    - id: hashValue
      type: System.Byte[]
      description: "Representerar värdet för beräknade hash-koden."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representerar den hash-algoritm som används av sammansättningsmanifestet."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen som anges av <code> typeName </code>. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Typen kan inte läsas in."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen offentlig parameterlös konstruktor hittades."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>är en abstrakt klass.       - eller - den här medlemmen anropades med en mekanism med sen bindning."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>är en tom sträng (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "COM-objektet som refereras till <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny domän med det angivna namnet."
  remarks: "Den `friendlyName` parameter är avsedd att identifiera domänen på ett sätt som passar för människor. Den här strängen ska vara lämpligt för visning i användargränssnitt.       Den här metodöverlagringen använder den <xref:System.AppDomainSetup>information från standarddomänen.</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Det egna namnet på domänen."
    return:
      type: System.AppDomain
      description: "Nyligen skapade programdomänen."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny domän med det angivna namnet med hjälp av angivna bevis."
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Det egna namnet på domänen. Detta egna namn kan visas i användargränssnitt för att identifiera domänen. Mer information finns i <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Bevis som bestämmer identiteten hos den kod som körs i programdomänen. Skicka <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> att använda bevis på den aktuella domänen."
    return:
      type: System.AppDomain
      description: "Nyligen skapade programdomänen."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny programdomän med angivet namn, bevis och programinformation domän installationen."
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Det egna namnet på domänen. Detta egna namn kan visas i användargränssnitt för att identifiera domänen. Mer information finns i <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Bevis som bestämmer identiteten hos den kod som körs i programdomänen. Skicka <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> att använda bevis på den aktuella domänen."
    - id: info
      type: System.AppDomainSetup
      description: "Ett objekt som innehåller programmet domäninformation för initiering."
    return:
      type: System.AppDomain
      description: "Nyligen skapade programdomänen."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny programdomän med angivet namn, bevis, programinformation domän installationen, Standardgrupp och matris med fullständigt betrodda sammansättningar."
  remarks: "Du måste ange den <xref:System.AppDomainSetup.ApplicationBase%2A>egenskapen för den <xref:System.AppDomainSetup>objekt som du anger för `info`.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> Annars genereras ett undantag.       Om `securityInfo` har inte angetts bevis på den aktuella domänen i programmet används.       Informationen för `grantSet` och `fullTrustAssemblies` används för att skapa en <xref:System.Security.Policy.ApplicationTrust>objektet för den nya programdomänen.</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Det egna namnet på domänen. Detta egna namn kan visas i användargränssnitt för att identifiera domänen. Mer information finns i beskrivningen av <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Bevis som bestämmer identiteten hos den kod som körs i programdomänen. Skicka <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> att använda bevis på den aktuella domänen."
    - id: info
      type: System.AppDomainSetup
      description: "Ett objekt som innehåller programmet domäninformation för initiering."
    - id: grantSet
      type: System.Security.PermissionSet
      description: "En standardbehörighetsgrupp som beviljas till alla sammansättningar läses in i den nya programdomänen som inte har särskilda bidrag."
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "En matris med starka krypterade namn som representerar sammansättningar anses vara fullständigt betrodda i den nya domänen i programmet."
    return:
      type: System.AppDomain
      description: "Nyligen skapade programdomänen."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Programdomänen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.       - eller - <xref:System.AppDomainSetup.ApplicationBase*>egenskap är inte inställd på den <xref href=&quot;System.AppDomainSetup&quot;> </xref> objekt som har angetts för <code> info </code>.</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny domän med det angivna namnet, med hjälp av bevis, grundläggande programsökväg, relativ sökväg och en parameter som anger om en skuggkopia av en sammansättning som ska läsas in i programdomänen."
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Det egna namnet på domänen. Detta egna namn kan visas i användargränssnitt för att identifiera domänen. Mer information finns i <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Bevis som bestämmer identiteten hos den kod som körs i programdomänen. Skicka <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> att använda bevis på den aktuella domänen."
    - id: appBasePath
      type: System.String
      description: "Baskatalog där sammansättningen matcharen att avsökning för sammansättningar. Mer information finns i <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Sökväg i förhållande till baskatalog där sammansättningen matcharen bör avsökning för privata sammansättningar. Mer information finns i <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "Om <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, en skuggkopia av en sammansättning har lästs in i den här domänen."
    return:
      type: System.AppDomain
      description: "Nyligen skapade programdomänen."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny domän med det angivna namnet, med hjälp av bevis, grundläggande programsökväg, relativ sökväg och en parameter som anger om en skuggkopia av en sammansättning som ska läsas in i programdomänen. Anger en metod som anropas när programdomänen initieras och en matris med strängargument skickar Återanropsmetoden."
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Det egna namnet på domänen. Detta egna namn kan visas i användargränssnitt för att identifiera domänen. Mer information finns i <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Bevis som bestämmer identiteten hos den kod som körs i programdomänen. Skicka <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> att använda bevis på den aktuella domänen."
    - id: appBasePath
      type: System.String
      description: "Baskatalog där sammansättningen matcharen att avsökning för sammansättningar. Mer information finns i <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Sökväg i förhållande till baskatalog där sammansättningen matcharen bör avsökning för privata sammansättningar. Mer information finns i <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>att läsa in en skuggkopia av en sammansättning i programdomänen."
    - id: adInit
      type: System.AppDomainInitializer
      description: "En <xref href=&quot;System.AppDomainInitializer&quot;> </xref> delegat som representerar en metod att anropa när den nya <xref href=&quot;System.AppDomain&quot;> </xref> objektet har initierats."
    - id: adInitArgs
      type: System.String[]
      description: "En matris med strängargument som ska skickas till återanropet som representeras av `adInit`när den nya <xref href=&quot;System.AppDomain&quot;> </xref> objektet har initierats."
    return:
      type: System.AppDomain
      description: "Nyligen skapade programdomänen."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningen."
  remarks: "Den här metoden anropar standardkonstruktor för `typeName`.       Se <xref:System.Reflection.AssemblyName>för format `assemblyName`.</xref:System.Reflection.AssemblyName>       Ett försök att anropa en Måltillämpningsdomänen som inte är den aktuella programdomänen CreateInstance resulterar i en lyckad inläsning av sammansättning i Måltillämpningsdomänen. Eftersom en <xref:System.Reflection.Assembly>inte <xref:System.MarshalByRefObject>när den här metoden försöker denna att returnera den <xref:System.Reflection.Assembly>för att läsa in sammansättningen ska den aktuella programdomänen CLR kommer att försöka läsa in sammansättningen i den aktuella domänen och belastningen kan misslyckas.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Sammansättningen har lästs in i den aktuella domänen kan skilja sig från sammansättningen som lästes in först om sökvägsinställningarna två programdomäner är olika."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen som anges av <code> typeName </code>. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte behörighet att anropa den här konstruktorn."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>hittades inte i <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Den här instansen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningen. En parameter anger en matris med Aktiveringsattribut."
  remarks: "Den här metoden anropar standardkonstruktor för `typeName`.       Se <xref:System.Reflection.AssemblyName>för format `assemblyName`.</xref:System.Reflection.AssemblyName>       Ett försök att anropa <xref:System.AppDomain.CreateInstance%2A>på ett mål programdomänen som inte är den aktuella programdomänen resulterar i en lyckad inläsning av sammansättning i Måltillämpningsdomänen.</xref:System.AppDomain.CreateInstance%2A> Eftersom en <xref:System.Reflection.Assembly>inte <xref:System.MarshalByRefObject>när den här metoden försöker denna att returnera den <xref:System.Reflection.Assembly>för att läsa in sammansättningen ska den aktuella programdomänen CLR kommer att försöka läsa in sammansättningen i den aktuella domänen och belastningen kan misslyckas.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Sammansättningen har lästs in i den aktuella domänen kan skilja sig från sammansättningen som lästes in först om sökvägsinställningarna två programdomäner är olika."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen som anges av <code> typeName </code>. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte behörighet att anropa den här konstruktorn."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>hittades inte i <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Den här instansen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningen. Parametrarna anger en binder, bindningsflaggor, konstruktorargument, kultur-specifik information som används för att tolka argument och valfria Aktiveringsattribut."
  remarks: "Se <xref:System.Reflection.AssemblyName>för format `assemblyName`.</xref:System.Reflection.AssemblyName>       Ett försök att anropa <xref:System.AppDomain.CreateInstance%2A>på ett mål programdomänen som inte är den aktuella programdomänen resulterar i en lyckad inläsning av sammansättning i Måltillämpningsdomänen.</xref:System.AppDomain.CreateInstance%2A> Eftersom en <xref:System.Reflection.Assembly>inte <xref:System.MarshalByRefObject>när den här metoden försöker denna att returnera den <xref:System.Reflection.Assembly>för att läsa in sammansättningen ska den aktuella programdomänen CLR kommer att försöka läsa in sammansättningen i den aktuella domänen och belastningen kan misslyckas.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Sammansättningen har lästs in i den aktuella domänen kan skilja sig från sammansättningen som lästes in först om sökvägsinställningarna två programdomäner är olika."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: ignoreCase
      type: System.Boolean
      description: "Ett booleskt värde som anger om du vill utföra en skiftlägeskänslig sökning eller inte."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "En kombination av noll eller fler bitar flaggor som påverkar Sök efter den `typeName` konstruktor. Om `bindingAttr` är noll, en skiftlägeskänslig sökning för offentliga konstruktorer utförs."
    - id: binder
      type: System.Reflection.Binder
      description: "Typer av ett objekt som gör att bindningen tvång för argumentet, anrop av medlemmar och hämtning av <xref:System.Reflection.MemberInfo>objekt med hjälp av reflektion.</xref:System.Reflection.MemberInfo> Om `binder` är null, standard binder används."
    - id: args
      type: System.Object[]
      description: "Argument att skicka vidare till konstruktorn. Denna matris argument måste matcha antalet ordning, och Skriv parametrar för att anropa konstruktorn. Om Standardkonstruktorn föredras `args` måste vara en tom matris eller null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kultur-specifik information som reglerar tvång av `args` till formella typer som har deklarerats för den `typeName` konstruktor. Om `culture` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>för den aktuella tråden används.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen som anges av <code> typeName </code>. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - <code>assemblyName</code> kompilerades med en senare version av CLR än den version som för närvarande är inläst."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte behörighet att anropa den här konstruktorn."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande konstruktor hittades."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>hittades inte i <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Den här instansen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningen. Parametrarna anger en binder, bindningsflaggor, konstruktorargument, kultur-specifik information som används för att tolka argument och Aktiveringsattribut behörighet att skapa typen."
  remarks: "Se <xref:System.Reflection.AssemblyName>för format `assemblyName`.</xref:System.Reflection.AssemblyName>       Ett försök att anropa <xref:System.AppDomain.CreateInstance%2A>på ett mål programdomänen som inte är den aktuella programdomänen resulterar i en lyckad inläsning av sammansättning i Måltillämpningsdomänen.</xref:System.AppDomain.CreateInstance%2A> Eftersom en <xref:System.Reflection.Assembly>inte <xref:System.MarshalByRefObject>när den här metoden försöker denna att returnera den <xref:System.Reflection.Assembly>för att läsa in sammansättningen ska den aktuella programdomänen CLR kommer att försöka läsa in sammansättningen i den aktuella domänen och belastningen kan misslyckas.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Sammansättningen har lästs in i den aktuella domänen kan skilja sig från sammansättningen som lästes in först om sökvägsinställningarna två programdomäner är olika."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: ignoreCase
      type: System.Boolean
      description: "Ett booleskt värde som anger om du vill utföra en skiftlägeskänslig sökning eller inte."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "En kombination av noll eller fler bitar flaggor som påverkar Sök efter den `typeName` konstruktor. Om `bindingAttr` är noll, en skiftlägeskänslig sökning för offentliga konstruktorer utförs."
    - id: binder
      type: System.Reflection.Binder
      description: "Typer av ett objekt som gör att bindningen tvång för argumentet, anrop av medlemmar och hämtning av <xref:System.Reflection.MemberInfo>objekt med hjälp av reflektion.</xref:System.Reflection.MemberInfo> Om `binder` är null, standard binder används."
    - id: args
      type: System.Object[]
      description: "Argument att skicka vidare till konstruktorn. Denna matris argument måste matcha antalet ordning, och Skriv parametrar för att anropa konstruktorn. Om Standardkonstruktorn föredras `args` måste vara en tom matris eller null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kultur-specifik information som reglerar tvång av `args` till formella typer som har deklarerats för den `typeName` konstruktor. Om `culture` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>för den aktuella tråden används.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Information som används för att auktorisera skapandet av `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen som anges av <code> typeName </code>. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte behörighet att anropa den här konstruktorn."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande konstruktor hittades."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. När äldre CAS-principen inte är aktiverad <code> securityAttributes </code> ska vara<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>hittades inte i <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Den här instansen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen. Parametrar anger sammansättningen som innehåller typen är definierad och namnet på typen."
  remarks: "Detta är en metod för bekvämlighet som kombinerar <xref:System.AppDomain.CreateInstance%2A>och <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Den här metoden anropar standardkonstruktor för `typeName`.       Se <xref:System.Reflection.AssemblyName>för format `assemblyName`.</xref:System.Reflection.AssemblyName> Finns det <xref:System.Type.FullName%2A?displayProperty=fullName>egenskapen för format `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Om du gör ett tidigt bundet anrop till en metod `M` för ett objekt av typen `T1` som returnerades av CreateInstanceAndUnwrap och metoden gör ett tidigt bundet anrop till en metod för ett objekt av typen `T2` i en sammansättning `C` än den aktuella sammansättningen eller att sammansättningen som innehåller `T1`, sammansättningen `C` läses in i den aktuella domänen. Den här inläsningen sker även om den tidiga bunden anrop till `T1.M()` gjordes i brödtexten för en <xref:System.Reflection.Emit.DynamicMethod>, eller i andra dynamiskt genererade koden.</xref:System.Reflection.Emit.DynamicMethod> Om den aktuella domänen är standarddomänen sammansättningen `C` kan inte tas bort förrän processen avslutas. Om den aktuella domänen senare görs ett försök att läsa in sammansättningen `C`, belastningen misslyckas."
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    return:
      type: System.Object
      description: "En instans av objektet som anges av <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>hittades inte i <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte behörighet att anropa den här konstruktorn."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen. Parametrarna anger sammansättningen som innehåller typen är definierad, namnet på typen och en matris med Aktiveringsattribut."
  remarks: "Detta är en metod för bekvämlighet som kombinerar <xref:System.AppDomain.CreateInstance%2A>och <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Den här metoden anropar standardkonstruktor för `typeName`.       Se <xref:System.Reflection.AssemblyName>för format `assemblyName`.</xref:System.Reflection.AssemblyName> Finns det <xref:System.Type.FullName%2A?displayProperty=fullName>egenskapen för format `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Om du gör ett tidigt bundet anrop till en metod `M` för ett objekt av typen `T1` som returnerades av <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, och att metoden gör ett tidigt bundet anrop till en metod för ett objekt av typen `T2` i en sammansättning `C` än den aktuella sammansättningen eller att sammansättningen som innehåller `T1`, sammansättningen `C` läses in i den aktuella domänen.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Den här inläsningen sker även om den tidiga bunden anrop till `T1.M()` gjordes i brödtexten för en <xref:System.Reflection.Emit.DynamicMethod>, eller i andra dynamiskt genererade koden.</xref:System.Reflection.Emit.DynamicMethod> Om den aktuella domänen är standarddomänen sammansättningen `C` kan inte tas bort förrän processen avslutas. Om den aktuella domänen senare görs ett försök att läsa in sammansättningen `C`, belastningen misslyckas."
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    return:
      type: System.Object
      description: "En instans av objektet som anges av <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>hittades inte i <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte behörighet att anropa den här konstruktorn."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningen som anger om ignoreras i fallet med typnamnet; bindningen-attribut och binder som används för att välja den typ som ska skapas. argument för konstruktorn; kultur. och Aktiveringsattribut."
  remarks: "Detta är en metod för bekvämlighet som kombinerar <xref:System.AppDomain.CreateInstance%2A>och <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Se <xref:System.Reflection.AssemblyName>för format `assemblyName`.</xref:System.Reflection.AssemblyName> Finns det <xref:System.Type.FullName%2A?displayProperty=fullName>egenskapen för format `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Om du gör ett tidigt bundet anrop till en metod `M` för ett objekt av typen `T1` som returnerades av <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, och att metoden gör ett tidigt bundet anrop till en metod för ett objekt av typen `T2` i en sammansättning `C` än den aktuella sammansättningen eller att sammansättningen som innehåller `T1`, sammansättningen `C` läses in i den aktuella domänen.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Den här inläsningen sker även om den tidiga bunden anrop till `T1.M()` gjordes i brödtexten för en <xref:System.Reflection.Emit.DynamicMethod>, eller i andra dynamiskt genererade koden.</xref:System.Reflection.Emit.DynamicMethod> Om den aktuella domänen är standarddomänen sammansättningen `C` kan inte tas bort förrän processen avslutas. Om den aktuella domänen senare görs ett försök att läsa in sammansättningen `C`, belastningen misslyckas."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: ignoreCase
      type: System.Boolean
      description: "Ett booleskt värde som anger om du vill utföra en skiftlägeskänslig sökning eller inte."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "En kombination av noll eller fler bitar flaggor som påverkar Sök efter den `typeName` konstruktor. Om `bindingAttr` är noll, en skiftlägeskänslig sökning för offentliga konstruktorer utförs."
    - id: binder
      type: System.Reflection.Binder
      description: "Typer av ett objekt som gör att bindningen tvång för argumentet, anrop av medlemmar och hämtning av <xref:System.Reflection.MemberInfo>objekt med hjälp av reflektion.</xref:System.Reflection.MemberInfo> Om `binder` är null, standard binder används."
    - id: args
      type: System.Object[]
      description: "Argument att skicka vidare till konstruktorn. Denna matris argument måste matcha antalet ordning, och Skriv parametrar för att anropa konstruktorn. Om Standardkonstruktorn föredras `args` måste vara en tom matris eller null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "En kultur-specifika objekt som används för att styra tvång typer. Om `culture` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> för den aktuella tråden används."
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt. som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    return:
      type: System.Object
      description: "En instans av objektet som anges av <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande konstruktor hittades."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>hittades inte i <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte behörighet att anropa den här konstruktorn."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - <code>assemblyName</code> kompilerades med en senare version av CLR än den version som för närvarande är inläst."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen. Parametrarna anger namnet på typen och hur det hittas och skapas."
  remarks: "Detta är en metod för bekvämlighet som kombinerar <xref:System.AppDomain.CreateInstance%2A>och <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Se <xref:System.Reflection.AssemblyName>för format `assemblyName`.</xref:System.Reflection.AssemblyName> Finns det <xref:System.Type.FullName%2A?displayProperty=fullName>egenskapen för format `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Om du gör ett tidigt bundet anrop till en metod `M` för ett objekt av typen `T1` som returnerades av <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, och att metoden gör ett tidigt bundet anrop till en metod för ett objekt av typen `T2` i en sammansättning `C` än den aktuella sammansättningen eller att sammansättningen som innehåller `T1`, sammansättningen `C` läses in i den aktuella domänen.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Den här inläsningen sker även om den tidiga bunden anrop till `T1.M()` gjordes i brödtexten för en <xref:System.Reflection.Emit.DynamicMethod>, eller i andra dynamiskt genererade koden.</xref:System.Reflection.Emit.DynamicMethod> Om den aktuella domänen är standarddomänen sammansättningen `C` kan inte tas bort förrän processen avslutas. Om den aktuella domänen senare görs ett försök att läsa in sammansättningen `C`, belastningen misslyckas."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: ignoreCase
      type: System.Boolean
      description: "Ett booleskt värde som anger om du vill utföra en skiftlägeskänslig sökning eller inte."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "En kombination av noll eller fler bitar flaggor som påverkar Sök efter den `typeName` konstruktor. Om `bindingAttr` är noll, en skiftlägeskänslig sökning för offentliga konstruktorer utförs."
    - id: binder
      type: System.Reflection.Binder
      description: "Typer av ett objekt som gör att bindningen tvång för argumentet, anrop av medlemmar och hämtning av <xref:System.Reflection.MemberInfo>objekt med hjälp av reflektion.</xref:System.Reflection.MemberInfo> Om `binder` är null, standard binder används."
    - id: args
      type: System.Object[]
      description: "Argument att skicka vidare till konstruktorn. Denna matris argument måste matcha antalet ordning, och Skriv parametrar för att anropa konstruktorn. Om Standardkonstruktorn föredras `args` måste vara en tom matris eller null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "En kultur-specifika objekt som används för att styra tvång typer. Om `culture` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> för den aktuella tråden används."
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Information som används för att auktorisera skapandet av `typeName`."
    return:
      type: System.Object
      description: "En instans av objektet som anges av <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande konstruktor hittades."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>hittades inte i <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte behörighet att anropa den här konstruktorn."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningsfilen."
  remarks: "Standardkonstruktor för `typeName` har anropats.       Mer information finns i <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metod.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       När metoden CreateInstanceFrom används för att skapa en instans i Måltillämpningsdomänen än programdomänen från vilken anropet görs är sammansättningen inläst i Måltillämpningsdomänen. Om instansen har packats upp i anropa programdomän kan med okrypterad-instansen på vissa sätt dock göra sammansättningen som ska läsas in i domänen anropande programmet. Till exempel efter att instansen har packats upp dess typinformation kan begäras, för att kunna anropa dess metoder sent bundna. När sammansättningen är inläst i anropa programdomänen kan undantag inträffa.      – Om en annan version av samma sammansättning lästes in tidigare till anropande programdomänen, eller om belastningen är sökvägen till den anropande programdomänen skiljer sig från Måltillämpningsdomänen undantag som <xref:System.MissingMethodException>kan uppstå.</xref:System.MissingMethodException>      -Om anropa programdomänen gör tidiga bundna anrop till vilken instans <xref:System.InvalidCastException>kan genereras när ett försök görs att omvandla instansen.</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Filnamnet, inklusive sökvägen, till en fil som innehåller en sammansättning som definierar den begärda typen. Sammansättningen har lästs in med hjälp av den <xref:System.Reflection.Assembly.LoadFrom*>metoden.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om <code> typeName </code> finns inte. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>hittades inte i <code>assemblyFile</code>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen parameterlös konstruktor har offentliga hittades."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte tillräcklig behörighet för att anropa den här konstruktorn."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyFile</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Den här instansen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningsfilen."
  remarks: "Standardkonstruktor för `typeName` har anropats.       Mer information om den här metoden finns i <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metod.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       När den <xref:System.AppDomain.CreateInstanceFrom%2A>metoden används för att skapa en instans i Måltillämpningsdomänen än programdomänen från vilken anropet görs, sammansättningen är inläst i Måltillämpningsdomänen.</xref:System.AppDomain.CreateInstanceFrom%2A> Om instansen har packats upp i anropa programdomän kan med okrypterad-instansen på vissa sätt dock göra sammansättningen som ska läsas in i domänen anropande programmet. Till exempel efter att instansen har packats upp dess typinformation kan begäras, för att kunna anropa dess metoder sent bundna. När sammansättningen är inläst i anropa programdomänen kan undantag inträffa.      – Om en annan version av samma sammansättning lästes in tidigare till anropande programdomänen, eller om belastningen är sökvägen till den anropande programdomänen skiljer sig från Måltillämpningsdomänen undantag som <xref:System.MissingMethodException>kan uppstå.</xref:System.MissingMethodException>      -Om anropa programdomänen gör tidiga bundna anrop till vilken instans <xref:System.InvalidCastException>kan genereras när ett försök görs att omvandla instansen.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Filnamnet, inklusive sökvägen, till en fil som innehåller en sammansättning som definierar den begärda typen. Sammansättningen har lästs in med hjälp av den <xref:System.Reflection.Assembly.LoadFrom*>metoden.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om <code> typeName </code> finns inte. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>hittades inte i <code>assemblyFile</code>."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte tillräcklig behörighet för att anropa den här konstruktorn."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyFile</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Den här instansen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningsfilen."
  remarks: "Mer information finns i <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metod.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       När den <xref:System.AppDomain.CreateInstanceFrom%2A>metoden används för att skapa en instans i Måltillämpningsdomänen än programdomänen från vilken anropet görs, sammansättningen är inläst i Måltillämpningsdomänen.</xref:System.AppDomain.CreateInstanceFrom%2A> Om instansen har packats upp i anropa programdomän kan med okrypterad-instansen på vissa sätt dock göra sammansättningen som ska läsas in i domänen anropande programmet. Till exempel efter att instansen har packats upp dess typinformation kan begäras, för att kunna anropa dess metoder sent bundna. När sammansättningen är inläst i anropa programdomänen kan undantag inträffa.      – Om en annan version av samma sammansättning lästes in tidigare till anropande programdomänen, eller om belastningen är sökvägen till den anropande programdomänen skiljer sig från Måltillämpningsdomänen undantag som <xref:System.MissingMethodException>kan uppstå.</xref:System.MissingMethodException>      -Om anropa programdomänen gör tidiga bundna anrop till vilken instans <xref:System.InvalidCastException>kan genereras när ett försök görs att omvandla instansen.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Filnamnet, inklusive sökvägen, till en fil som innehåller en sammansättning som definierar den begärda typen. Sammansättningen har lästs in med hjälp av den <xref:System.Reflection.Assembly.LoadFrom*>metoden.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: ignoreCase
      type: System.Boolean
      description: "Ett booleskt värde som anger om du vill utföra en skiftlägeskänslig sökning eller inte."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "En kombination av noll eller fler bitar flaggor som påverkar Sök efter den `typeName` konstruktor. Om `bindingAttr` är noll, en skiftlägeskänslig sökning för offentliga konstruktorer utförs."
    - id: binder
      type: System.Reflection.Binder
      description: "Typer av ett objekt som gör att bindningen tvång för argumentet, anrop av medlemmar och hämtning av <xref:System.Reflection.MemberInfo>objekt via reflektion.</xref:System.Reflection.MemberInfo> Om `binder` är null, standard binder används."
    - id: args
      type: System.Object[]
      description: "Argument att skicka vidare till konstruktorn. Denna matris argument måste matcha antalet ordning, och Skriv parametrar för att anropa konstruktorn. Om Standardkonstruktorn föredras `args` måste vara en tom matris eller null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kultur-specifik information som reglerar tvång av `args` till formella typer som har deklarerats för den `typeName` konstruktor. Om `culture` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>för den aktuella tråden används.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om <code> typeName </code> finns inte. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>hittades inte i <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte tillräcklig behörighet för att anropa den här konstruktorn."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - <code>assemblyFile</code> kompilerades med en senare version av CLR än den version som för närvarande är inläst."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Den här instansen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningsfilen."
  remarks: "Mer information om den här metoden finns i <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metod.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       När den <xref:System.AppDomain.CreateInstanceFrom%2A>metoden används för att skapa en instans i Måltillämpningsdomänen än programdomänen från vilken anropet görs, sammansättningen är inläst i Måltillämpningsdomänen.</xref:System.AppDomain.CreateInstanceFrom%2A> Om instansen har packats upp i anropa programdomän kan med okrypterad-instansen på vissa sätt dock göra sammansättningen som ska läsas in i domänen anropande programmet. Till exempel efter att instansen har packats upp dess typinformation kan begäras, för att kunna anropa dess metoder sent bundna. När sammansättningen är inläst i anropa programdomänen kan undantag inträffa.      – Om en annan version av samma sammansättning lästes in tidigare till anropande programdomänen, eller om belastningen är sökvägen till den anropande programdomänen skiljer sig från Måltillämpningsdomänen undantag som <xref:System.MissingMethodException>kan uppstå.</xref:System.MissingMethodException>      -Om anropa programdomänen gör tidiga bundna anrop till vilken instans <xref:System.InvalidCastException>kan genereras när ett försök görs att omvandla instansen.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Filnamnet, inklusive sökvägen, till en fil som innehåller en sammansättning som definierar den begärda typen. Sammansättningen har lästs in med hjälp av den <xref:System.Reflection.Assembly.LoadFrom*>metoden.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: ignoreCase
      type: System.Boolean
      description: "Ett booleskt värde som anger om du vill utföra en skiftlägeskänslig sökning eller inte."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "En kombination av noll eller fler bitar flaggor som påverkar Sök efter den `typeName` konstruktor. Om `bindingAttr` är noll, en skiftlägeskänslig sökning för offentliga konstruktorer utförs."
    - id: binder
      type: System.Reflection.Binder
      description: "Typer av ett objekt som gör att bindningen tvång för argumentet, anrop av medlemmar och hämtning av <xref:System.Reflection.MemberInfo>objekt via reflektion.</xref:System.Reflection.MemberInfo> Om `binder` är null, standard binder används."
    - id: args
      type: System.Object[]
      description: "Argument att skicka vidare till konstruktorn. Denna matris argument måste matcha antalet ordning, och Skriv parametrar för att anropa konstruktorn. Om Standardkonstruktorn föredras `args` måste vara en tom matris eller null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kultur-specifik information som reglerar tvång av `args` till formella typer som har deklarerats för den `typeName` konstruktor. Om `culture` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>för den aktuella tråden används.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Information som används för att auktorisera skapandet av `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Ett objekt som är en wrapper för den nya instansen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om <code> typeName </code> finns inte. Returvärdet måste vara packats upp för att komma åt det verkliga objektet."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. När äldre CAS-principen inte är aktiverad <code> securityAttributes </code> ska vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>hittades inte i <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte tillräcklig behörighet för att anropa den här konstruktorn."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyFile</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Den här instansen är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningsfilen."
  remarks: "Detta är en metod för bekvämlighet som kombinerar <xref:System.AppDomain.CreateInstanceFrom%2A>och <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Den här metoden anropar standardkonstruktor för `typeName`.       Mer information finns i <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metod.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Filnamnet och sökvägen till den sammansättning som definierar den begärda typen."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    return:
      type: System.Object
      description: "Det begärda objektet eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om <code> typeName </code> finns inte."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>hittades inte i <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen parameterlös konstruktor har offentliga hittades."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte tillräcklig behörighet för att anropa den här konstruktorn."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningsfilen."
  remarks: "Detta är en metod för bekvämlighet som kombinerar <xref:System.AppDomain.CreateInstanceFrom%2A>och <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Den här metoden anropar standardkonstruktor för `typeName`.       Mer information om den här metoden finns i <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metod.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Filnamnet och sökvägen till den sammansättning som definierar den begärda typen."
    - id: typeName
      type: System.String
      description: "Den begärda typen, inklusive namnområdet, men inte sammansättningen fullständigt kvalificerade namnet (finns i &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskap)."
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    return:
      type: System.Object
      description: "Det begärda objektet eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om <code> typeName </code> finns inte."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>hittades inte i <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen parameterlös konstruktor har offentliga hittades."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte tillräcklig behörighet för att anropa den här konstruktorn."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningsfilen anger om ignoreras i fallet med typnamnet; bindningen-attribut och binder som används för att välja den typ som ska skapas. argument för konstruktorn; kultur. och Aktiveringsattribut."
  remarks: "Detta är en metod för bekvämlighet som kombinerar <xref:System.AppDomain.CreateInstanceFrom%2A>och <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Mer information om den här metoden finns i <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metod.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Filnamnet och sökvägen till den sammansättning som definierar den begärda typen."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: ignoreCase
      type: System.Boolean
      description: "Ett booleskt värde som anger om du vill utföra en skiftlägeskänslig sökning eller inte."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "En kombination av noll eller fler bitar flaggor som påverkar Sök efter den `typeName` konstruktor. Om `bindingAttr` är noll, en skiftlägeskänslig sökning för offentliga konstruktorer utförs."
    - id: binder
      type: System.Reflection.Binder
      description: "Typer av ett objekt som gör att bindningen tvång för argumentet, anrop av medlemmar och hämtning av <xref:System.Reflection.MemberInfo>objekt via reflektion.</xref:System.Reflection.MemberInfo> Om `binder` är null, standard binder används."
    - id: args
      type: System.Object[]
      description: "Argument att skicka vidare till konstruktorn. Denna matris argument måste matcha antalet ordning, och Skriv parametrar för att anropa konstruktorn. Om Standardkonstruktorn föredras `args` måste vara en tom matris eller null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kultur-specifik information som reglerar tvång av `args` till formella typer som har deklarerats för den `typeName` konstruktor. Om `culture` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>för den aktuella tråden används.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    return:
      type: System.Object
      description: "Det begärda objektet eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om <code> typeName </code> finns inte."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>hittades inte i <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte tillräcklig behörighet för att anropa den här konstruktorn."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - <code>assemblyName</code> kompilerades med en senare version av CLR att versionen som för närvarande är inlästa."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Skapar en ny instans av den angivna typen som definierats i den angivna sammansättningsfilen."
  remarks: "Detta är en metod för bekvämlighet som kombinerar <xref:System.AppDomain.CreateInstanceFrom%2A>och <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Mer information om den här metoden finns i <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metod.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Filnamnet och sökvägen till den sammansättning som definierar den begärda typen."
    - id: typeName
      type: System.String
      description: "Det fullständigt kvalificerade namnet för den begärda typen, inklusive namnområdet, men inte sammansättningen som returneras av den &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; egenskapen."
    - id: ignoreCase
      type: System.Boolean
      description: "Ett booleskt värde som anger om du vill utföra en skiftlägeskänslig sökning eller inte."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "En kombination av noll eller fler bitar flaggor som påverkar Sök efter den `typeName` konstruktor. Om `bindingAttr` är noll, en skiftlägeskänslig sökning för offentliga konstruktorer utförs."
    - id: binder
      type: System.Reflection.Binder
      description: "Typer av ett objekt som gör att bindningen tvång för argumentet, anrop av medlemmar och hämtning av <xref:System.Reflection.MemberInfo>objekt via reflektion.</xref:System.Reflection.MemberInfo> Om `binder` är null, standard binder används."
    - id: args
      type: System.Object[]
      description: "Argument att skicka vidare till konstruktorn. Denna matris argument måste matcha antalet ordning, och Skriv parametrar för att anropa konstruktorn. Om Standardkonstruktorn föredras `args` måste vara en tom matris eller null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Kultur-specifik information som reglerar tvång av `args` till formella typer som har deklarerats för den `typeName` konstruktor. Om `culture` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>för den aktuella tråden används.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "En matris med ett eller flera attribut som kan delta i aktivering. Normalt en matris som innehåller en enda <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> objekt som anger den URL som krävs för att aktivera ett fjärrobjekt.       Den här parametern är relaterad till klienten aktiverats objekt. Aktivering av klienten är en äldre teknik som bevaras för bakåtkompatibilitet, men rekommenderas inte för utveckling av nya. Distribuerade program bör i stället använda Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Information som används för att auktorisera skapandet av `typeName`."
    return:
      type: System.Object
      description: "Det begärda objektet eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om <code> typeName </code> finns inte."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Anroparen kan inte tillhandahålla Aktiveringsattribut för ett objekt som inte ärver från <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>hittades inte."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>hittades inte i <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Ingen matchande offentlig konstruktor hittades."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Anroparen har inte tillräcklig behörighet för att anropa den här konstruktorn."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyName</code> kompilerades med en senare version."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar den aktuella domänen för aktuellt <xref href=&quot;System.Threading.Thread&quot;> </xref>."
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "Den aktuella domänen i programmet."
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namn och åtkomst-läget."
  remarks: "Den här metoden bör endast användas för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du använder en överlagring av den <xref:System.AppDomain.DefineDynamicAssembly%2A>metod som anger bevis och behörigheter, lämna bevis som du vill använda dynamisk sammansättning har och inkludera <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Åtkomstläge för dynamisk sammansättning."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namn och åtkomst-läget."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet och åtkomstläge anpassade attribut."
  remarks: "Använd den här metodöverlagringen för att ange attribut som inte fungerar korrekt om de tillämpas när en dynamisk sammansättning har skapats. Till exempel säkerhetsattribut som <xref:System.Security.SecurityTransparentAttribute>och <xref:System.Security.SecurityCriticalAttribute>fungerar inte korrekt om de har lagts till efter en dynamisk sammansättning har skapats.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Den här metoden bör användas endast för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information om den här begränsningen finns på <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       Den här metodöverlagringen införs i den [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Åtkomstläge för dynamisk sammansättning."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "En enumerable lista över attribut som ska tillämpas på sammansättningen, eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om det inte finns några attribut."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet, åtkomstläge och bevis."
  remarks: "Endast fullständigt betrodda anropare kan ange sina `evidence` när du definierar en dynamisk <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Körningen mappas i <xref:System.Security.Policy.Evidence>i en säkerhetsprincip för att bestämma de beviljade behörigheterna.</xref:System.Security.Policy.Evidence> Delvis betrodda anropare måste ange ett null-värde `evidence`. Om `evidence` är `null`körningsmiljön kopierar Behörighetsgrupperna, det vill säga aktuellt bevilja och neka uppsättningar, från anroparens <xref:System.Reflection.Assembly>att dynamiskt <xref:System.Reflection.Assembly>som definieras och uppger princip som löst.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Om dynamiskt <xref:System.Reflection.Assembly>är sparas till disk efterföljande belastningar får ger utifrån principerna som associeras med platsen där den <xref:System.Reflection.Assembly>sparades.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Den här metoden bör endast användas för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du använder en överlagring av den <xref:System.AppDomain.DefineDynamicAssembly%2A>metod som anger bevis och behörigheter, lämna bevis som du vill använda dynamisk sammansättning har och inkludera <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som angetts för dynamisk sammansättning. Bevisen används utan ändringar som den slutgiltiga uppsättningen bevis för princip för namnmatchning."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet, åtkomstläge och Arkivkatalog."
  remarks: "Den här metoden bör endast användas för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du använder en överlagring av den <xref:System.AppDomain.DefineDynamicAssembly%2A>metod som anger bevis och behörigheter, lämna bevis som du vill använda dynamisk sammansättning har och inkludera <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: dir
      type: System.String
      description: "Namnet på den katalog där paketet ska sparas. Om `dir` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, katalogen som standard den aktuella katalogen."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet och åtkomstläge anpassade attribut och använder den angivna källan för säkerhetskontext."
  remarks: "Använd den här metodöverlagringen för att ange attribut som inte fungerar korrekt om de tillämpas när en dynamisk sammansättning har skapats. Till exempel säkerhetsattribut som <xref:System.Security.SecurityTransparentAttribute>och <xref:System.Security.SecurityCriticalAttribute>fungerar inte korrekt om de har lagts till efter en dynamisk sammansättning har skapats.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Den här metoden bör användas endast för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information om den här begränsningen finns på <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Åtkomstläge för dynamisk sammansättning."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "En enumerable lista över attribut som ska tillämpas på sammansättningen, eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om det inte finns några attribut."
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "Källan för säkerhetskontexten."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Värdet för <code> securityContextSource </code> var inte något uppräkningsvärdena."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet, åtkomstläge, Arkivkatalog och bevis."
  remarks: "Endast fullständigt betrodda anropare kan ange sina `evidence` när du definierar en dynamisk <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Körningen mappas i <xref:System.Security.Policy.Evidence>i en säkerhetsprincip för att bestämma de beviljade behörigheterna.</xref:System.Security.Policy.Evidence> Delvis betrodda anropare måste ange ett null-värde `evidence`. Om `evidence` är `null`körningsmiljön kopierar Behörighetsgrupperna, det vill säga aktuellt bevilja och neka uppsättningar, från anroparens <xref:System.Reflection.Assembly>att dynamiskt <xref:System.Reflection.Assembly>som definieras och uppger princip som löst.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Om dynamiskt <xref:System.Reflection.Assembly>är sparas till disk efterföljande belastningar får ger utifrån principerna som associeras med platsen där den <xref:System.Reflection.Assembly>sparades.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Den här metoden bör endast användas för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du använder en överlagring av den <xref:System.AppDomain.DefineDynamicAssembly%2A>metod som anger bevis och behörigheter, lämna bevis som du vill använda dynamisk sammansättning har och inkludera <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: dir
      type: System.String
      description: "Namnet på den katalog där paketet ska sparas. Om `dir` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, katalogen som standard den aktuella katalogen."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som angetts för dynamisk sammansättning. Bevisen används utan ändringar som den slutgiltiga uppsättningen bevis för princip för namnmatchning."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet, åtkomstläge och för behörighetsbegäranden."
  remarks: "Behörighetsbegäranden som angetts för `requiredPermissions`, `optionalPermissions`, och `refusedPermissions` används inte om inte dynamisk sammansättning har sparats och in igen i minnet. Ange behörighetsbegäranden för en tillfällig sammansättning som aldrig har sparats till disk, Använd en överlagring av den <xref:System.AppDomain.DefineDynamicAssembly%2A>metod som anger bevis så väl som begärda behörigheter och ange ett <xref:System.Security.Policy.Evidence>objekt.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du använder en överlagring av den <xref:System.AppDomain.DefineDynamicAssembly%2A>metod som anger bevis och behörigheter, lämna bevis som du vill använda dynamisk sammansättning har och inkludera <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>       Den här metoden bör endast användas för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som krävs."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som är valfria."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Begäran nekades behörigheter."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med angivet namn, åtkomstläge, Arkivkatalog och synkroniseringsalternativ."
  remarks: "Använd den här metodöverlagringen för att ange attribut som inte fungerar korrekt om de tillämpas när en dynamisk sammansättning har skapats. Till exempel säkerhetsattribut som <xref:System.Security.SecurityTransparentAttribute>och <xref:System.Security.SecurityCriticalAttribute>fungerar inte korrekt om de har lagts till efter en dynamisk sammansättning har skapats.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Om `isSynchronized` är `true`, följande metoder för det resulterande <xref:System.Reflection.Emit.AssemblyBuilder>ska synkroniseras: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, och <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Om två av dessa metoder kallas på olika trådar, blockerar en tills den andra är klar."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: dir
      type: System.String
      description: "Namnet på den katalog där dynamisk sammansättning kommer att sparas. Om `dir` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, används den aktuella katalogen."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>att synkronisera skapandet av moduler, typer och medlemmar i en dynamisk sammansättning; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "En enumerable lista över attribut som ska tillämpas på sammansättningen, eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om det inte finns några attribut."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet, åtkomstläge, bevis och behörighetsbegäranden."
  remarks: "Behörighetsbegäranden som angetts för `requiredPermissions`, `optionalPermissions`, och `refusedPermissions` används endast om `evidence` också har angetts, eller om dynamisk sammansättning sparas och in igen i minnet.      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du inkluderar <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>       Endast fullständigt betrodda anropare kan ange sina `evidence` när du definierar en dynamisk <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Körningen mappas i <xref:System.Security.Policy.Evidence>i en säkerhetsprincip för att bestämma de beviljade behörigheterna.</xref:System.Security.Policy.Evidence> Delvis betrodda anropare måste ange ett null-värde `evidence`. Om `evidence` är `null`körningsmiljön kopierar Behörighetsgrupperna, det vill säga aktuellt bevilja och neka uppsättningar, från anroparens <xref:System.Reflection.Assembly>att dynamiskt <xref:System.Reflection.Assembly>som definieras och uppger princip som löst.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Om dynamiskt <xref:System.Reflection.Assembly>är sparas till disk efterföljande belastningar får ger utifrån principerna som associeras med platsen där den <xref:System.Reflection.Assembly>sparades.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Den här metoden bör endast användas för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som angetts för dynamisk sammansättning. Bevisen används utan ändringar som den slutgiltiga uppsättningen bevis för princip för namnmatchning."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som krävs."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som är valfria."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Begäran nekades behörigheter."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet, åtkomstläge, Arkivkatalog och behörighetsbegäranden."
  remarks: "Behörighetsbegäranden som angetts för `requiredPermissions`, `optionalPermissions`, och `refusedPermissions` används inte om inte dynamisk sammansättning har sparats och in igen i minnet. Ange behörighetsbegäranden för en tillfällig sammansättning som aldrig har sparats till disk, Använd en överlagring av den <xref:System.AppDomain.DefineDynamicAssembly%2A>metod som anger bevis så väl som begärda behörigheter och ange ett <xref:System.Security.Policy.Evidence>objekt.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du använder en överlagring av den <xref:System.AppDomain.DefineDynamicAssembly%2A>metod som anger bevis och behörigheter, lämna bevis som du vill använda dynamisk sammansättning har och inkludera <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>       Den här metoden bör endast användas för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: dir
      type: System.String
      description: "Namnet på den katalog där paketet ska sparas. Om `dir` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, katalogen som standard den aktuella katalogen."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som krävs."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som är valfria."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Begäran nekades behörigheter."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med det angivna namnet, åtkomstläge, Arkivkatalog, bevis och behörighetsbegäranden."
  remarks: "Behörighetsbegäranden som angetts för `requiredPermissions`, `optionalPermissions`, och `refusedPermissions` används endast om `evidence` också har angetts, eller om dynamisk sammansättning sparas och in igen i minnet.      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du inkluderar <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>       Endast fullständigt betrodda anropare kan ange sina `evidence` när du definierar en dynamisk <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Körningen mappas i <xref:System.Security.Policy.Evidence>i en säkerhetsprincip för att bestämma de beviljade behörigheterna.</xref:System.Security.Policy.Evidence> Delvis betrodda anropare måste ange ett null-värde `evidence`. Om `evidence` är `null`körningsmiljön kopierar Behörighetsgrupperna, det vill säga aktuellt bevilja och neka uppsättningar, från anroparens <xref:System.Reflection.Assembly>att dynamiskt <xref:System.Reflection.Assembly>som definieras och uppger princip som löst.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Om dynamiskt <xref:System.Reflection.Assembly>är sparas till disk efterföljande belastningar får ger utifrån principerna som associeras med platsen där den <xref:System.Reflection.Assembly>sparades.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Den här metoden bör endast användas för att definiera en dynamisk sammansättning i den aktuella domänen. Mer information finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: dir
      type: System.String
      description: "Namnet på den katalog där paketet ska sparas. Om `dir` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, katalogen som standard den aktuella katalogen."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som angetts för dynamisk sammansättning. Bevisen används utan ändringar som den slutgiltiga uppsättningen bevis för princip för namnmatchning."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som krävs."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som är valfria."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Begäran nekades behörigheter."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med angivet namn, åtkomstläge, Arkivkatalog, bevis, behörighetsbegäranden och synkroniseringsalternativ."
  remarks: "Behörighetsbegäranden som angetts för `requiredPermissions`, `optionalPermissions`, och `refusedPermissions` används endast om `evidence` också har angetts, eller om dynamisk sammansättning sparas och in igen i minnet.      > [!NOTE] > Under utvecklingen av kod som skickar dynamiska sammansättningar, rekommenderas att du inkluderar <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>i `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Inklusive <xref:System.Security.Permissions.SecurityPermissionFlag>i den `refusedPermissions` parametern säkerställer att MSIL har verifierats.</xref:System.Security.Permissions.SecurityPermissionFlag> En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>       Endast fullständigt betrodda anropare kan ange sina bevis när du definierar en dynamisk <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Körningen mappas i <xref:System.Security.Policy.Evidence>i en säkerhetsprincip för att bestämma de beviljade behörigheterna.</xref:System.Security.Policy.Evidence> Delvis betrodda anropare måste ange `null` för den `evidence` parameter. Om `evidence` är `null`körningsmiljön kopierar Behörighetsgrupperna, det vill säga aktuellt bevilja och neka uppsättningar, från anroparens <xref:System.Reflection.Assembly>att dynamiskt <xref:System.Reflection.Assembly>som definieras och uppger princip som löst.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Om dynamiskt <xref:System.Reflection.Assembly>är sparas till disk efterföljande belastningar får ger utifrån principerna som associeras med platsen där den <xref:System.Reflection.Assembly>sparades.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Om `isSynchronized` är `true`, följande metoder för det resulterande <xref:System.Reflection.Emit.AssemblyBuilder>ska synkroniseras: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, och <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Om två av dessa metoder kallas på olika trådar, blockerar en tills den andra är klar."
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: dir
      type: System.String
      description: "Namnet på den katalog där dynamisk sammansättning kommer att sparas. Om `dir` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, katalogen som standard den aktuella katalogen."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som angetts för dynamisk sammansättning. Bevisen används utan ändringar som den slutgiltiga uppsättningen bevis för princip för namnmatchning."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som krävs."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som är valfria."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Begäran nekades behörigheter."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>att synkronisera skapandet av moduler, typer och medlemmar i en dynamisk sammansättning; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med ett blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definierar en dynamisk sammansättning med angivet namn, åtkomstläge, Arkivkatalog, bevis, behörighetsbegäranden, synkroniseringsalternativ och anpassade attribut."
  remarks: "Använd den här metodöverlagringen för att ange attribut som inte fungerar korrekt om de tillämpas när en dynamisk sammansättning har skapats. Till exempel säkerhetsattribut som <xref:System.Security.SecurityTransparentAttribute>och <xref:System.Security.SecurityCriticalAttribute>fungerar inte korrekt om de har lagts till efter en dynamisk sammansättning har skapats.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Behörighetsbegäranden som angetts för den `requiredPermissions`, `optionalPermissions`, och `refusedPermissions` parametrar används endast om den `evidence` parametern tillhandahålls även, eller om dynamisk sammansättning sparas och in igen i minnet.      > [!NOTE] > När du utvecklar kod som skickar dynamiska sammansättningar, rekommenderar vi att du inkluderar den <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>flaggan i den `refusedPermissions` parameter.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Med den här flaggan garanterar att Microsofts mellanliggande språk (MSIL) kommer att verifieras. Den här tekniken identifierar oavsiktlig generering av ej verifierbara kod som annars är väldigt svårt att identifiera. En begränsning i den här metoden är att den också gör <xref:System.Security.SecurityException>positionsundantagsfel när det används med kod som kräver fullständigt förtroende.</xref:System.Security.SecurityException>       Endast fullständigt betrodda anropare kan lämna bevis när du definierar en dynamisk <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Körningen mappar den <xref:System.Security.Policy.Evidence>i en säkerhetsprincip för att bestämma de beviljade behörigheterna.</xref:System.Security.Policy.Evidence> Delvis betrodda anropare måste ange `null` för den `evidence` parameter. Om `evidence` är `null`, körningsmiljön kopierar behörighetsgrupper (som är aktuella bevilja och neka anger) från anroparens sammansättningen till dynamisk sammansättning som definieras och markerar principen som löst.       Om dynamisk sammansättning sparas till disk, efterföljande belastningar får ger baserat på principer som är kopplade till platsen där dynamisk sammansättning sparades.       Om `isSynchronized` är `true`, följande metoder för det resulterande <xref:System.Reflection.Emit.AssemblyBuilder>ska synkroniseras: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, och <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Om två av dessa metoder kallas på olika trådar, blockerar en tills den andra är klar.       Den här metodöverlagringen införs i den [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Dynamisk sammansättning unika identitet."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Det läge som dynamisk sammansättning används."
    - id: dir
      type: System.String
      description: "Namnet på den katalog där dynamisk sammansättning kommer att sparas. Om `dir` är <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, används den aktuella katalogen."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Bevis som har angetts för dynamisk sammansättning. Bevisen används utan ändringar som den slutgiltiga uppsättningen bevis för princip för namnmatchning."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som krävs."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Begäran om behörigheterna som är valfria."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Begäran nekades behörigheter."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>att synkronisera skapandet av moduler, typer och medlemmar i en dynamisk sammansättning; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "En enumerable lista över attribut som ska tillämpas på sammansättningen, eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om det inte finns några attribut."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "En dynamisk sammansättning med det angivna namnet och funktioner."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - eller - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> -egenskapen för <code> name </code> börjar med blanksteg eller innehåller framåt och bakåt snedstreck."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Koden körs i en annan domän som identifieras av det angivna ombudet."
  remarks: '`callBackDelegate`Ange en konvertering-av-värde, <xref:System.MarshalByRefObject>, eller <xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "En delegat som anger en metod för att anropa."
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar domänhanteraren som angavs av värden när programdomänen initierades."
  remarks: "En ohanterad common language runtime (CLR)-värd kan ge en hanterare för domänen. Domänhanteraren som kan delta i vid initiering av den nya domänen i programmet och ange andra chefer som en <xref:System.Security.HostSecurityManager>, som ingår i åtgärderna programdomänen.</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "Ett objekt som representerar domänhanteraren som tillhandahålls av värden när programdomänen initierades eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om ingen domän manager angavs."
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när en <xref href=&quot;System.AppDomain&quot;> </xref> håller på att tas bort från minnet."
  remarks: "Den <xref:System.EventHandler>Delegera för den här händelsen kan utföra alla aktiviteter avslutning innan programdomänen tas bort.</xref:System.EventHandler>       Varje domän som behöver för att utföra bearbetningen när den tas bort bör registrera en händelsehanterare för den här händelsen. En delad händelsehanterare bör inte användas eftersom den <xref:System.EventHandler>ombud identifierar inte domänen som minnet.</xref:System.EventHandler>      > [!NOTE] > Denna händelse utlöses aldrig i standarddomänen.       Du inte göra några antaganden om tråden händelsen visas på. Händelsen som visas i en annan tråd än den som kallas den <xref:System.AppDomain.Unload%2A>metoden.</xref:System.AppDomain.Unload%2A>       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar den katalog som sammansättningen matcharen används för att avsökning för dynamiskt skapade sammansättningar."
  remarks: "Om du vill ange dynamisk katalog, tilldela en baskatalog sökväg till den <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>egenskapen för den <xref:System.AppDomainSetup>objekt som ska användas för att skapa nya programdomänen.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> Grundläggande sökvägen till du tilldelar egenskapen har ändrats genom att lägga till en underkatalog vars enkla namn är hash-koden för strängen som du tilldelar den <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>egenskap, så har baskatalogen format *ursprungliga sökvägen*\\\\*hash-kod*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> Den dynamiska katalogen är en underkatalog till den här baskatalog. Enkla namnet är värdet för den <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>egenskap, så att dess format är *ursprungliga sökvägen*\\\\*hash-kod*\\\\*programnamn*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "Katalogen som sammansättningen matcharen använder för att söka efter dynamiskt skapa sammansättningar."
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar den <xref href=&quot;System.Security.Policy.Evidence&quot;> </xref> som är associerade med den här domänen."
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "Bevis som associeras med den här domänen."
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör sammansättningen i den angivna filen."
  remarks: "Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.       Den här metoden läser in sammansättningar som använder den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> Du kan också köra sammansättningar som använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod som läser in sammansättningar som använder den <xref:System.Reflection.Assembly.Load%2A>metoden.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Att skapa den <xref:System.AppDomain>för att läsa in och köra, använda den <xref:System.AppDomain.CreateDomain%2A>metoden.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Namnet på den fil som innehåller sammansättningen som ska köras."
    return:
      type: System.Int32
      description: "Värdet som returneras av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyFile</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör sammansättningen i den angivna filen med den angivna bevisen."
  remarks: "Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den <xref:System.AppDomain.ExecuteAssembly%2A>metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.</xref:System.AppDomain.ExecuteAssembly%2A>       Den här metoden läser in sammansättningar som använder den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> Du kan också köra sammansättningar som använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod som läser in sammansättningar som använder den <xref:System.Reflection.Assembly.Load%2A>metoden.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Namnet på den fil som innehåller sammansättningen som ska köras."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Bevis för att läsa in sammansättningen."
    return:
      type: System.Int32
      description: "Värdet som returneras av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyFile</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör sammansättningen i den angivna filen med hjälp av de angivna argumenten."
  remarks: "Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.       Den här metoden läser in sammansättningar som använder den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> Du kan också köra sammansättningar som använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod som läser in sammansättningar som använder den <xref:System.Reflection.Assembly.Load%2A>metoden.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Namnet på den fil som innehåller sammansättningen som ska köras."
    - id: args
      type: System.String[]
      description: "Argumenten till startpunkten för sammansättningen."
    return:
      type: System.Int32
      description: "Det värde som returnerades av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - <code>assemblyFile</code> kompilerades med en senare version av CLR än den version som för närvarande är inläst."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör sammansättningen i den angivna filen med hjälp av angivna bevis och argument."
  remarks: "Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.       Den här metoden läser in sammansättningar som använder den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> Du kan också köra sammansättningar som använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod som läser in sammansättningar som använder den <xref:System.Reflection.Assembly.Load%2A>metoden.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Namnet på den fil som innehåller sammansättningen som ska köras."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Den angivna sammansättningsbevis för sammansättningen."
    - id: args
      type: System.String[]
      description: "Argumenten till startpunkten för sammansättningen."
    return:
      type: System.Int32
      description: "Värdet som returneras av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyFile</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. När äldre CAS-principen inte är aktiverad <code>assemblySecurity</code> ska vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör sammansättningen i den angivna filen med hjälp av angivna argument, hash-värde och hash-algoritm."
  remarks: "Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.       Den här metoden läser in sammansättningar som använder den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> Du kan också köra sammansättningar som använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod som läser in sammansättningar som använder den <xref:System.Reflection.Assembly.Load%2A>metoden.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Namnet på den fil som innehåller sammansättningen som ska köras."
    - id: args
      type: System.String[]
      description: "Argumenten till startpunkten för sammansättningen."
    - id: hashValue
      type: System.Byte[]
      description: "Representerar värdet för beräknade hash-koden."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representerar den hash-algoritm som används av sammansättningsmanifestet."
    return:
      type: System.Int32
      description: "Det värde som returnerades av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - <code>assemblyFile</code> kompilerades med en senare version av CLR än den version som för närvarande är inläst."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör sammansättningen i den angivna filen med den angivna bevis, argument, hash-värde och hash-algoritm."
  remarks: "Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.       Den här metoden läser in sammansättningar som använder den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> Du kan också köra sammansättningar som använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod som läser in sammansättningar som använder den <xref:System.Reflection.Assembly.Load%2A>metoden.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Namnet på den fil som innehåller sammansättningen som ska köras."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Den angivna sammansättningsbevis för sammansättningen."
    - id: args
      type: System.String[]
      description: "Argumenten till startpunkten för sammansättningen."
    - id: hashValue
      type: System.Byte[]
      description: "Representerar värdet för beräknade hash-koden."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Representerar den hash-algoritm som används av sammansättningsmanifestet."
    return:
      type: System.Int32
      description: "Värdet som returneras av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyFile</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. När äldre CAS-principen inte är aktiverad <code>assemblySecurity</code> ska vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör en sammansättning som anges i dess namn."
  remarks: "Den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ger liknande funktionalitet till den <xref:System.AppDomain.ExecuteAssembly%2A>metoden anger men sammansättningen med visningsnamnet eller <xref:System.Reflection.AssemblyName>i stället för filplats.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Därför <xref:System.AppDomain.ExecuteAssemblyByName%2A>läser in sammansättningar med den <xref:System.Reflection.Assembly.Load%2A>metoden i stället för med den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.       Att skapa den <xref:System.AppDomain>för att läsa in och köra, använda den <xref:System.AppDomain.CreateDomain%2A>metoden.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Int32
      description: "Värdet som returneras av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Sammansättningen som anges av <code> assemblyName </code> finns inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Sammansättningen som anges av <code> assemblyName </code> är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code> assemblyName </code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Sammansättningen som anges av <code> assemblyName </code> hittades, men kunde inte läsas in."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör den angivna sammansättningen en <xref:System.Reflection.AssemblyName>, med hjälp av de angivna argumenten.</xref:System.Reflection.AssemblyName>"
  remarks: "Den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ger liknande funktionalitet till den <xref:System.AppDomain.ExecuteAssembly%2A>metoden anger men sammansättningen med visningsnamnet eller <xref:System.Reflection.AssemblyName>i stället för filplats.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Därför <xref:System.AppDomain.ExecuteAssemblyByName%2A>läser in sammansättningar med den <xref:System.Reflection.Assembly.Load%2A>metoden i stället för med den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd."
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Ett <xref:System.Reflection.AssemblyName>-objekt som representerar namnet på sammansättningen.</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "Kommandoradsargument för att skicka när den startas."
    return:
      type: System.Int32
      description: "Det värde som returnerades av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Sammansättningen som anges av <code> assemblyName </code> finns inte."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Sammansättningen som anges av <code> assemblyName </code> hittades, men kunde inte läsas in."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Sammansättningen som anges av <code> assemblyName </code> är inte en giltig sammansättning.       - eller - <code> assemblyName </code> kompilerades med en senare version av CLR än den version som för närvarande är inläst."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör en sammansättning som anges dess visningsnamn med hjälp av angivna bevis."
  remarks: "Den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ger liknande funktionalitet till den <xref:System.AppDomain.ExecuteAssembly%2A>metoden anger men sammansättningen med visningsnamnet eller <xref:System.Reflection.AssemblyName>i stället för filplats.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Därför <xref:System.AppDomain.ExecuteAssemblyByName%2A>läser in sammansättningar med den <xref:System.Reflection.Assembly.Load%2A>metoden i stället för med den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > När du använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod med en <xref:System.Security.Policy.Evidence>parameter, delar av bevis slås samman.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Delar av bevis som angavs som argument till den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ersätter delar av bevis som tillhandahålls av inläsaren.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Bevis för att läsa in sammansättningen."
    return:
      type: System.Int32
      description: "Värdet som returneras av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Sammansättningen som anges av <code> assemblyName </code> finns inte."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Sammansättningen som anges av <code> assemblyName </code> hittades, men kunde inte läsas in."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Sammansättningen som anges av <code> assemblyName </code> är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code> assemblyName </code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör angivna dess visningsnamn sammansättningen med hjälp av de angivna argumenten."
  remarks: "Den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ger liknande funktionalitet till den <xref:System.AppDomain.ExecuteAssembly%2A>metoden anger men sammansättningen med visningsnamnet eller <xref:System.Reflection.AssemblyName>i stället för filplats.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Därför <xref:System.AppDomain.ExecuteAssemblyByName%2A>läser in sammansättningar med den <xref:System.Reflection.Assembly.Load%2A>metoden i stället för med den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd."
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: args
      type: System.String[]
      description: "Kommandoradsargument för att skicka när den startas."
    return:
      type: System.Int32
      description: "Det värde som returnerades av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Sammansättningen som anges av <code> assemblyName </code> finns inte."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Sammansättningen som anges av <code> assemblyName </code> hittades, men kunde inte läsas in."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Sammansättningen som anges av <code> assemblyName </code> är inte en giltig sammansättning.       - eller - <code> assemblyName </code> kompilerades med en senare version av CLR än den version som för närvarande är inläst."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör den angivna sammansättningen en <xref:System.Reflection.AssemblyName>, med hjälp av angivna bevis och argument.</xref:System.Reflection.AssemblyName>"
  remarks: "Den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ger liknande funktionalitet till den <xref:System.AppDomain.ExecuteAssembly%2A>metoden anger men sammansättningen med visningsnamnet eller <xref:System.Reflection.AssemblyName>i stället för filplats.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Därför <xref:System.AppDomain.ExecuteAssemblyByName%2A>läser in sammansättningar med den <xref:System.Reflection.Assembly.Load%2A>metoden i stället för med den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.      > [!NOTE] > När du använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod med en <xref:System.Security.Policy.Evidence>parameter, delar av bevis slås samman.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Delar av bevis som angavs som argument till den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ersätter delar av bevis som tillhandahålls av inläsaren.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Ett <xref:System.Reflection.AssemblyName>-objekt som representerar namnet på sammansättningen.</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Bevis för att läsa in sammansättningen."
    - id: args
      type: System.String[]
      description: "Kommandoradsargument för att skicka när den startas."
    return:
      type: System.Int32
      description: "Värdet som returneras av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Sammansättningen som anges av <code> assemblyName </code> finns inte."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Sammansättningen som anges av <code> assemblyName </code> hittades, men kunde inte läsas in."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Sammansättningen som anges av <code> assemblyName </code> är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code> assemblyName </code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. När äldre CAS-principen inte är aktiverad <code>assemblySecurity</code> ska vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Kör angivna dess visningsnamn sammansättningen med hjälp av angivna bevis och argument."
  remarks: "Den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ger liknande funktionalitet till den <xref:System.AppDomain.ExecuteAssembly%2A>metoden anger men sammansättningen med visningsnamnet eller <xref:System.Reflection.AssemblyName>i stället för filplats.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Därför <xref:System.AppDomain.ExecuteAssemblyByName%2A>läser in sammansättningar med den <xref:System.Reflection.Assembly.Load%2A>metoden i stället för med den <xref:System.Reflection.Assembly.LoadFile%2A>metoden.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Sammansättningen påbörjas vid den angivna startpunkten i .NET Framework-huvudet.       Den här metoden skapar inte en ny process eller programdomänen och metoden körs inte på en ny tråd.      > [!NOTE] > När du använder den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metod med en <xref:System.Security.Policy.Evidence>parameter, delar av bevis slås samman.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Delar av bevis som angavs som argument till den <xref:System.AppDomain.ExecuteAssemblyByName%2A>metoden ersätter delar av bevis som tillhandahålls av inläsaren.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Bevis för att läsa in sammansättningen."
    - id: args
      type: System.String[]
      description: "Kommandoradsargument för att skicka när den startas."
    return:
      type: System.Int32
      description: "Värdet som returneras av startpunkten för sammansättningen."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Sammansättningen som anges av <code> assemblyName </code> finns inte."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Sammansättningen som anges av <code> assemblyName </code> hittades, men kunde inte läsas in."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Sammansättningen som anges av <code> assemblyName </code> är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code> assemblyName </code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. När äldre CAS-principen inte är aktiverad <code>assemblySecurity</code> ska vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Den angivna sammansättningen har ingen startpunkt."
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när ett undantag i förvaltad kod innan körningen söker anropsstacken för en undantagshanterare i programdomänen."
  remarks: "Den här händelsen är endast ett meddelande. Hantering av den här händelsen inte hantera undantaget och påverka efterföljande undantagshantering på något sätt. När händelsen har aktiverats och händelsehanterare har anropats, börjar common language runtime (CLR) att söka efter en hanterare för undantaget. FirstChanceException ger programdomänen första möjlighet att granska alla hanterade undantag.       Händelsen kan hanteras per domän. Om en tråd som passerar genom flera programdomäner vid körning av ett anrop, utlöses händelsen i varje domän som har registrerats i en händelsehanterare innan CLR börjar söker efter en matchande undantagshanterare i den domänen. När händelsen har hanterats görs en sökning efter en matchande undantagshanterare i den domänen. Om ingen hittas visas händelsen i nästa programdomänen.       Du måste hantera alla undantag som uppstår i hanteraren för händelsen FirstChanceException. Annars är FirstChanceException upphöjt rekursivt. Detta kan resultera i ett stackspill och avslutning av programmet. Vi rekommenderar att du implementera händelsehanterare för den här händelsen som begränsad körning regioner (CERs) om du vill behålla infrastruktur-relaterade undantag, till exempel minnet är slut eller stacken spill påverkar den virtuella datorn medan undantag meddelandet bearbetas.       Denna händelse utlöses inte för undantag som anger hos processen tillstånd, till exempel åtkomstfel, såvida inte händelsehanteraren är kritiska och har den <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>attribut.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       Common language runtime pausar tråd avbryts medan det här meddelandet händelsen hanteras."
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar det egna namnet för den här domänen."
  remarks: "Det egna namnet för standarddomänen är namnet på den körbara processfilen. Till exempel om den körbara filen som används för att starta processen är `&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`, är det egna namnet för standarddomänen `&quot;MyAssembly.exe&quot;`."
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "Det egna namnet för den här tillämpningsdomän."
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar de paket som har lästs in i körningssammanhang för den här domänen."
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "En matris med sammansättningar i den här programdomän."
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar den aktuella tråden identifieraren."
  remarks: "Använd den <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>-egenskap som är stabil även när .NET Framework finns i en miljö som stöder fibrer (det vill säga lightweight trådar).</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "En 32-bitars heltal som är identifieraren för den aktuella tråden."
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar det värde som lagras i den aktuella programdomänen för det angivna namnet."
  remarks: "Använd den här metoden för att hämta värdet för en post i en cache-lagrade data namn-värdepar som beskriver egenskaperna för den här instansen av <xref:System.AppDomain>.</xref:System.AppDomain> Observera att jämförelse av `name` med namnet på nyckel-värdepar är skiftlägeskänsligt.       Cachen innehåller fördefinierade poster som infogas när programdomänen skapas automatiskt. Du kan inspektera deras värden med metoden GetData, eller motsvarande <xref:System.AppDomainSetup>Egenskaper.</xref:System.AppDomainSetup>       Du kan infoga eller ändra egna användardefinierade namn data par med den <xref:System.AppDomain.SetData%2A>metoden och granska deras värden med metoden GetData.</xref:System.AppDomain.SetData%2A>       I följande tabell beskrivs de `name` fördefinierade för varje post i systemet och dess motsvarande <xref:System.AppDomainSetup>egenskap.</xref:System.AppDomainSetup>      | Värdet för &quot;name&quot; | Egenskapen |   |---------------------|--------------|   |&quot; PROGRAMBASEN &quot;| <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|   |&quot; APP_CONFIG_FILE &quot;| <xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|   |&quot; APP_LAUNCH_URL &quot;| (ingen egenskap)</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot; representerar den URL som ursprungligen begärdes av användaren innan någon omdirigering. Det är endast tillgänglig om programmet har startats med en webbläsare, till exempel Internet Explorer. Inte alla webbläsare har detta värde. |   |&quot; PROGRAMNAMN &quot;| <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|   |&quot; BINPATH_PROBE_ONLY &quot;| <xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|   |&quot; CACHE_BASE &quot;| <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|   |&quot; CODE_DOWNLOAD_DISABLED &quot;| <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|   |&quot; DEV_PATH &quot;| (ingen egenskap) |   |&quot; DISALLOW_APP &quot;| <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_BASE_PROBING &quot;| <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_REDIRECTS &quot;| <xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|   |&quot; DYNAMIC_BASE &quot;| <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|   |&quot; FORCE_CACHE_INSTALL &quot;| <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|   |&quot; LICENSE_FILE&quot;eller en sträng med programspecifika | <xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|   |&quot; LOADER_OPTIMIZATION &quot;| <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|   |&quot; LOCATION_URI &quot;| (ingen egenskap) |   |&quot; PRIVATE_BINPATH &quot;| <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|   |&quot; REGEX_DEFAULT_MATCH_TIMEOUT &quot;| <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; är inte en system-post och dess värde kan anges genom att anropa metoden <xref:System.AppDomain.SetData%2A>. |   |&quot; SHADOW_COPY_DIRS &quot;| <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "Namnet på en fördefinierad programmet domain-egenskapen eller namnet på en domain-egenskapen för program som du har definierat."
    return:
      type: System.Object
      description: "Värdet för den <code> name </code> egenskapen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om egenskapen inte finns."
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar typ av den aktuella instansen."
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "Typ av den aktuella instansen."
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar ett heltal som unikt identifierar programdomänen inom processen."
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Ett heltal som identifierar programdomänen."
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ger den <xref href=&quot;System.AppDomain&quot;> </xref> en oändlig livstid genom att förhindra att ett lån skapas."
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar ett kan ha värdet null booleskt värde som anger om några kompatibilitet växlar ställs och i så fall, om den angivna kompatibilitet växeln har angetts."
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "Växeln kompatibilitet för att testa."
    return:
      type: System.Nullable{System.Boolean}
      description: "En null-referens (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> i Visual Basic) om inga kompatibilitet växlar konfigureras; annars ett booleskt värde som anger om kompatibiliteten växla som anges av <code> value </code> har angetts."
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Returnerar ett värde som indikerar om programdomänen är standarddomänen för processen."
  remarks: "Alla hanterade processer har en standarddomänen. Körningen börjar i standarddomänen."
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om aktuellt <xref href=&quot;System.AppDomain&quot;> </xref> -objektet representerar standarddomänen för processen; annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Anger om den här programdomänen inaktiveras och de objekt som den innehåller är att färdigställas av CLR."
  remarks: "Slutförande-metod för ett objekt ger dig möjlighet att utföra alla nödvändiga innan objektet samlas in som skräp. Efter slutförande är objektet tillgänglig men i ett ogiltigt tillstånd och därför kan inte användas. Slutligen skräpinsamling har slutförts och återtar objektet.       Ett objekt slutförande-metoden anropas i en av följande situationer: under skräpinsamling, när common language runtime stängs av, eller när den domän som innehåller objektet tas bort. Metoden IsFinalizingForUnload returnerar `true` endast för det sista fallet, återgår den inte `true` om slutförande resulterar från rutinunderhåll skräpinsamling eller CLR avstängning.      > [!NOTE] > För att avgöra om slutföras på grund av avstängning av CLR, använder den <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>egenskapen.</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> Den returnerar `true` om slutföras på grund av en tillämpningsdomän tas bort från minnet eller till CLR avslutas.       Vid körning i slutförande-metoden under domän avlastning, kanske du vill komma åt ett annat objekt som refereras till av ett statiskt fält och har en slutförande-metod. Men kan inte du på ett tillförlitligt sätt göra det eftersom objektet används kanske redan har slutförts.      > [!NOTE] > Ett undantag till den här regeln är den <xref:System.Console>-klassen, som innehåller statiska fält som refererar till stream-objekt, men implementeras särskilt så att du alltid kan skriva till systemkonsolen även under domän avlastning system avstängning.</xref:System.Console>       Använd den här metoden i ett objekt slutförande-metoden för att avgöra om programdomänen som innehåller objektet tas bort. Om så är fallet kan du på ett tillförlitligt sätt komma åt alla objekt som har en metod för slutförande och refereras av ett statiskt fält."
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den här domänen är har avlastning och CLR startat anropar finaliserare; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar ett värde som anger om sammansättningar som läses in i den aktuella domänen för programmet ska köras med fullständigt förtroende."
  remarks: "Den här metoden returnerar alltid `true` för standarddomänen för ett program som körs på skrivbordet. Den returnerar `false` för ett begränsat läge programdomänen som har skapats med hjälp av den [AppDomain.CreateDomain (sträng, bevis, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) metoden överlagra, om inte de behörigheter som beviljas för programdomänen som är likvärdiga med fullständigt förtroende."
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om sammansättningar som läses in i den aktuella programdomänen körs med fullständigt förtroende; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar ett värde som anger om den aktuella domänen har en uppsättning behörigheter som ges till alla sammansättningar som läses in i programdomänen."
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om den aktuella domänen har en homogen uppsättning behörigheter. Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Läser in <xref:System.Reflection.Assembly>med en gemensam objektet filen format (COFF) baserat avbildning som innehåller en skickade <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>"
  remarks: "Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], förtroendenivå för en sammansättning som har lästs in med den här metoden är samma som förtroendenivå i programdomänen.       Den här metoden ska användas endast för att läsa in en sammansättning i den aktuella domänen. Den här metoden används bara i syfte att underlätta för samverkan anropare som det går inte att anropa statiskhet <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metod.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Om du vill läsa in sammansättningar i andra programdomäner, använder du en metod, till exempel <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Information som är gemensamma för alla överlagringar av den här metoden finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "En matris av typen <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> som är en COFF-baserad avbildning som innehåller en skickade sammansättning."
    return:
      type: System.Reflection.Assembly
      description: "Läsa in sammansättningen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>rawAssembly</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Läser in ett <xref:System.Reflection.Assembly>givet dess <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Den här metoden ska användas endast för att läsa in en sammansättning i den aktuella domänen. Den här metoden används bara i syfte att underlätta för samverkan anropare som det går inte att anropa statiskhet <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metod.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Om du vill läsa in sammansättningar i andra programdomäner, använder du en metod, till exempel <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Om en version av den begärda sammansättningen har redan lästs in, returnerar den här metoden läsa in sammansättningen, även om en annan version krävs.       Tillhandahåller ett partiellt sammansättningsnamn för `assemblyRef` rekommenderas inte. (En del av namnet utesluter en eller flera av kultur, version eller token för offentlig nyckel. För överlagringar som en sträng i stället för en <xref:System.Reflection.AssemblyName>objektet &quot;Minsammansättning, Version =&1;.0.0.0&quot; är ett exempel på ett partiellt namn och &quot;Minsammansättning, Version =&1;.0.0.0 kultur = neutral, PublicKeyToken =&18;ab3442da84b47&quot; är ett exempel på ett fullständigt namn.)</xref:System.Reflection.AssemblyName> Med hjälp av partiellt namn har en negativ inverkan på prestanda. Dessutom kan en partiell sammansättningsnamnet kan läsa in en sammansättning från den globala sammansättningscachen endast om det är en exakt kopia av sammansättningen i programmets baskatalog (<xref:System.AppDomain.BaseDirectory%2A> eller <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>).</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       Om aktuellt <xref:System.AppDomain>-objektet representerar programdomänen `A`, och <xref:System.AppDomain.Load%2A>metoden anropas från programdomänen `B`, sammansättningen är inläst i båda programdomäner.</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> Till exempel i följande kod belastningar `MyAssembly` till den nya domänen i programmet `ChildDomain` och även i programdomänen där koden körs: [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ] sammansättningen har lästs in i båda domänerna eftersom <xref:System.Reflection.Assembly>är inte härledd från <xref:System.MarshalByRefObject>, och därför returvärdet för den <xref:System.AppDomain.Load%2A>metod kan inte konverteras.</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     I stället common language runtime görs ett försök att läsa in sammansättningen i anropa programdomänen. Sammansättningar som läses in i två programdomäner skilja om sökvägsinställningarna två programdomäner är olika.      > [!NOTE] > Om både den <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>egenskapen och <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>ställs egenskapen, det första försöket att läsa in sammansättningen använder visningsnamnet (inklusive version, kultur och så vidare, som returneras av den <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>egenskapen).</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> Om filen inte hittas i <xref:System.Reflection.AssemblyName.CodeBase%2A>egenskapen används för att söka efter sammansättningen.</xref:System.Reflection.AssemblyName.CodeBase%2A> Om sammansättningen hittas med <xref:System.Reflection.AssemblyName.CodeBase%2A>, visningsnamnet har matchats mot sammansättningen.</xref:System.Reflection.AssemblyName.CodeBase%2A> Om matchningen misslyckas en <xref:System.IO.FileLoadException>genereras.</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Ett objekt som beskriver att läsa in sammansättningen."
    return:
      type: System.Reflection.Assembly
      description: "Läsa in sammansättningen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyRef</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Belastningar en <xref:System.Reflection.Assembly>anges dess visningsnamn.</xref:System.Reflection.Assembly>"
  remarks: "Den här metoden ska användas endast för att läsa in en sammansättning i den aktuella domänen. Den här metoden används bara i syfte att underlätta för samverkan anropare som det går inte att anropa statiskhet <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metod.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Om du vill läsa in sammansättningar i andra programdomäner, använder du en metod, till exempel <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Information som är gemensamma för alla överlagringar av den här metoden finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Reflection.Assembly
      description: "Läsa in sammansättningen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>är<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyString</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Läser in <xref:System.Reflection.Assembly>med en gemensam objektet filen format (COFF) baserat avbildning som innehåller en skickade <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly> De byte som representerar symboler för den <xref:System.Reflection.Assembly>läses också.</xref:System.Reflection.Assembly>"
  remarks: "Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], förtroendenivå för en sammansättning som har lästs in med den här metoden är samma som förtroendenivå i programdomänen.       Den här metoden ska användas endast för att läsa in en sammansättning i den aktuella domänen. Den här metoden används bara i syfte att underlätta för samverkan anropare som det går inte att anropa statiskhet <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metod.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Om du vill läsa in sammansättningar i andra programdomäner, använder du en metod, till exempel <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Information som är gemensamma för alla överlagringar av den här metoden finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "En matris av typen <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> som är en COFF-baserad avbildning som innehåller en skickade sammansättning."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "En matris av typen <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> som innehåller de byte som representerar symbolerna för sammansättningen."
    return:
      type: System.Reflection.Assembly
      description: "Läsa in sammansättningen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>rawAssembly</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Läser in ett <xref:System.Reflection.Assembly>givet dess <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Den här metoden ska användas endast för att läsa in en sammansättning i den aktuella domänen. Den här metoden används bara i syfte att underlätta för samverkan anropare som det går inte att anropa statiskhet <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metod.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Om du vill läsa in sammansättningar i andra programdomäner, använder du en metod, till exempel <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Information som är gemensamma för alla överlagringar av den här metoden finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Ett objekt som beskriver att läsa in sammansättningen."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Bevis för att läsa in sammansättningen."
    return:
      type: System.Reflection.Assembly
      description: "Läsa in sammansättningen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>är<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyRef</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Belastningar en <xref:System.Reflection.Assembly>anges dess visningsnamn.</xref:System.Reflection.Assembly>"
  remarks: "Den här metoden ska användas endast för att läsa in en sammansättning i den aktuella domänen. Den här metoden används bara i syfte att underlätta för samverkan anropare som det går inte att anropa statiskhet <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metod.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Om du vill läsa in sammansättningar i andra programdomäner, använder du en metod, till exempel <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Information som är gemensamma för alla överlagringar av den här metoden finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "Visningsnamnet för sammansättningen. Se &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Bevis för att läsa in sammansättningen."
    return:
      type: System.Reflection.Assembly
      description: "Läsa in sammansättningen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>är<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>hittades inte."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>assemblyString</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Läser in <xref:System.Reflection.Assembly>med en gemensam objektet filen format (COFF) baserat avbildning som innehåller en skickade <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly> De byte som representerar symboler för den <xref:System.Reflection.Assembly>läses också.</xref:System.Reflection.Assembly>"
  remarks: "Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], förtroendenivå för en sammansättning som har lästs in med den här metoden är samma som förtroendenivå i programdomänen.       Den här metoden ska användas endast för att läsa in en sammansättning i den aktuella domänen. Den här metoden används bara i syfte att underlätta för samverkan anropare som det går inte att anropa statiskhet <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metod.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Om du vill läsa in sammansättningar i andra programdomäner, använder du en metod, till exempel <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Information som är gemensamma för alla överlagringar av den här metoden finns i <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>metodöverlagringen.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "En matris av typen <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> som är en COFF-baserad avbildning som innehåller en skickade sammansättning."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "En matris av typen <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> som innehåller de byte som representerar symbolerna för sammansättningen."
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "Bevis för att läsa in sammansättningen."
    return:
      type: System.Reflection.Assembly
      description: "Läsa in sammansättningen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>är inte en giltig sammansättning.       - eller - Version 2.0 eller senare av CLR för närvarande är inlästa och <code>rawAssembly</code> kompilerades med en senare version."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "En sammansättningen eller modulen lästes in två gånger med två olika evidences."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. När äldre CAS-principen inte är aktiverad <code>securityEvidence</code> ska vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar eller anger ett värde som anger om processor och för minnesövervakning av programdomäner är aktiverat för den aktuella processen. När övervakning är aktiverad för en process, kan inte inaktiveras."
  remarks: "Detta `static` egenskap (`Shared` egenskapen i Visual Basic) styr CPU och för minnesövervakning av alla tillämpningsdomäner i processen.       Om du försöker ange egenskapen till `false`, en <xref:System.ArgumentException>undantag, även om det aktuella värdet på egenskapen är `false`.</xref:System.ArgumentException>       När övervakning är aktiverad, kan du använda den <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, och <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>instansen egenskaper för att övervaka CPU och minne använder enskilda programdomäner.</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>om övervakning är aktiverad; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Den aktuella processen gjordes ett försök att tilldela värdet <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> till den här egenskapen."
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar antalet byte som fortfarande varit i livet senaste samlingen och som är känt som refereras av den aktuella domänen."
  remarks: "Statistik har uppdaterats med varje skräpinsamling. Men är de garanterat korrekt förrän en fullständig blockerar samling; det vill säga inträffar en samling som innehåller alla generationer och som slutar programmet när samlingen. Till exempel den <xref:System.GC.Collect?displayProperty=fullName>överlagring för metoden utför en fullständig blockerar samling.</xref:System.GC.Collect?displayProperty=fullName> (Samtidiga samlingen sker i bakgrunden och blockerar inte programmet)."
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "Antalet kvarvarande byte."
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> i Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>egenskap är inställd på <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar det totala antalet byte som fortfarande varit i livet från den senaste samlingen för alla tillämpningsdomäner i processen."
  remarks: "Efter en fullständig, blockerar samling hanterade motsvarar denna siffra antalet byte som för tillfället hålls live på heapar. Det bör vara nära antal som rapporterats av den <xref:System.GC.GetTotalMemory%2A>metoden.</xref:System.GC.GetTotalMemory%2A> När en tillfällig samling det här talet anger antalet byte som för tillfället hålls live i tillfälliga generationer."
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "Det totala antalet kvarvarande byte för processen."
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> i Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>egenskap är inställd på <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar den sammanlagda storleken, i byte, för alla minnesallokering som har gjorts av programdomänen eftersom det har skapats utan att subtrahera minne som har samlats in."
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "Den totala storleken på alla minnesallokering."
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> i Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>egenskap är inställd på <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar den totala processortiden som har använts av alla trådar vid körning i den aktuella domänen i programmet sedan processen startades."
  remarks: "Den totala tid som har rapporterats för en tillämpningsdomän innehåller tidsåtgång varje tråd i processen körs i den domänen.       En tråd som anropar till ohanterad kod är fortfarande kopplad till en domän och processortiden tagit för att köra ohanterad kod som har rapporterats för den domän där anropet gjordes.       När en tråd är blockerad eller i viloläge, den inte tar upp processortid."
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Total processortid för den aktuella domänen."
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> i Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>egenskap är inställd på <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar behörighetsgrupp för en begränsade tillämpningsdomän."
  remarks: "Begränsade programdomäner som har skapats med hjälp av den [AppDomain.CreateDomain (sträng, bevis, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) metodöverlagringen har en homogen uppsättning behörigheter, som är samma uppsättning behörigheter beviljas för alla delvis betrodd sammansättningar som läses in i programdomänen. Begränsade programdomänen har du en lista med starkt krypterat namn sammansättningar som är undantagna från den här behörigheten ställa och i stället köra med fullständigt förtroende."
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "Behörighetsgrupp för begränsade tillämpningsdomän."
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när standard programdomänen överordnade processen avslutas."
  remarks: "Den <xref:System.EventHandler>för den här händelsen kan utföra avslutning aktiviteter, till exempel stänga filer, släppa lagring och så vidare innan processen avslutas.</xref:System.EventHandler>       Från och med .NET Framework version 2.0 kan utlöses den här händelsen i varje domän som registrerar en händelsehanterare.      > [!NOTE] > Totala körningstiden för händelsehanterare för alla ProcessExit är begränsad, precis som den totala tiden för körningen av alla finaliserare begränsas vid avslutning av processen. Standardvärdet är två sekunderna. En ohanterad värd kan ändra den här körningstid genom att anropa den [ICLRPolicyManager::SetTimeout](~/add/includes/ajax-current-ext-md.md) metod med den [OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md) uppräkningsvärde.       I .NET Framework-versioner 1.0- och 1.1 är den här händelsen aktiveras endast i standarddomänen och endast om en händelsehanterare är registrerad i standarddomänen.       Du måste ha behörigheterna som krävs för att registrera en händelsehanterare för den här händelsen, eller en <xref:System.Security.SecurityException>genereras.</xref:System.Security.SecurityException>       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när matchning av en sammansättning inte inom ramen reflection-only."
  remarks: "Inom ramen reflection-only löses beroenden inte automatiskt. De måste i förväg eller returnerades av hanteraren för den här händelsen. Den här händelsen utlöses när en sammansättning har ett beroende som inte redan har lästs in i ramen reflection-only. Saknat beroende anges av den <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>egenskapen.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> Den <xref:System.ResolveEventHandler>för den här händelsen måste returnera en sammansättning som uppfyller beroendet.</xref:System.ResolveEventHandler> Sammansättningen som returneras måste läsas in ramen reflection-only.      > [!IMPORTANT] > Händelsen aktiveras endast för saknade beroenden för sammansättningen som du laddar till ramen reflection-only (till exempel med hjälp av den <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>metod).</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> Det uppstår inte om du läser in sammansättningen inte hittades.       Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>-egenskap returnerar sammansättningen som begärt belastningen sammansättning som inte kunde matchas.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Känna till den begärande sammansättningen identitet kan vara användbar för att identifiera rätt version av beroende, om mer än en version är tillgänglig. Mer information finns i <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       För den här händelsen på <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>-egenskap returnerar sammansättningsnamnet innan principen tillämpas.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Returnerar de paket som har lästs in i ramen reflection-only för programdomänen."
  remarks: "Den här metoden returnerar de paket som har lästs in i ramen reflection-only. För att få de paket som har lästs in för körning kan använda den <xref:System.AppDomain.GetAssemblies%2A>metoden.</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "En matris med <xref:System.Reflection.Assembly>objekt som representerar sammansättningarna som läses in i ramen reflection-only för programdomänen.</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "En åtgärd utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar sökväg under baskatalog där sammansättningen matcharen bör avsökning för privata sammansättningar."
  remarks: "Privata sammansättningar distribueras i samma katalogstruktur som programmet. Om sökvägen som anges av egenskapen RelativeSearchPath inte under <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>, ignoreras.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       Den här egenskapen returnerar värdet med hjälp av <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "Sökvägen under baskatalog där sammansättningen matcharen bör avsökning för privata sammansättningar."
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när matchning av en resurs misslyckas eftersom resursen inte är en giltig länkade eller inbäddade resurs i sammansättningen."
  remarks: "<xref:System.ResolveEventHandler>För den här händelsen kan försöka att hitta sammansättningen som innehåller resursen och returnera det.</xref:System.ResolveEventHandler>      > [!IMPORTANT] > Denna händelse utlöses inte om matchningen misslyckas eftersom ingen fil kan hittas för en giltig länkade resurs. Utlöses om det går inte att hitta en Manifestresursen dataström, men aktiveras inte om en enskild resurs-nyckel inte kan hittas.       Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>-egenskapen innehåller sammansättningen som begärt resursen.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Mer information finns i <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Du måste ha behörigheterna som krävs för att registrera en händelsehanterare för den här händelsen, eller en <xref:System.Security.SecurityException>genereras.</xref:System.Security.SecurityException>       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Upprättar säkerhetsnivån för principen för den här domänen."
  remarks: "Anropa den här metoden innan en sammansättning har lästs in i den <xref:System.AppDomain>för säkerhetsprincipen att gälla.</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "Säkerhetsnivå för principen."
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "Säkerhetsnivå för principen har redan angetts."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Anger sökvägen till angivna katalogen som platsen för sammansättningar skuggkopior."
  remarks: "Cachesökvägen till ignoreras om den <xref:System.AppDomainSetup.ApplicationName%2A>egenskapen har inte angetts.</xref:System.AppDomainSetup.ApplicationName%2A> Finns det <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>egenskap.</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       Läs mer om hur du kopierar shadow [Shadow kopierar sammansättningar](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Den fullständiga sökvägen till shadow copy-plats."
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Det angivna värdet tilldelar domain-egenskapen för angivet program."
  remarks: "Använd den här metoden för att infoga en post eller ändra värdet för en post i en cache-lagrade data namn-värdepar som beskriver egenskaperna för den här instansen av <xref:System.AppDomain>.</xref:System.AppDomain>       Cachen innehåller fördefinierade poster som infogas när programdomänen skapas automatiskt. Du kan inte infoga eller ändra system poster med den här metoden. Ett metodanrop som försöker ändra en system-post har ingen effekt; metoden Inget undantag genereras. Du kan inspektera värden av system med <xref:System.AppDomain.GetData%2A>metoden, eller i motsvarande <xref:System.AppDomainSetup>Egenskaper som beskrivs i <xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>       Du kan anropa den här metoden om du vill ange värdet för timeout standardintervallet för utvärdering av mönster för reguljära uttryck genom att ange &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; som värde för den `name` argumentet och en <xref:System.TimeSpan>värde som representerar timeout-intervall som värde för den `data` argument.</xref:System.TimeSpan> Du kan också infoga eller ändra egna användardefinierade namn data par med den här metoden och granska deras värden med den <xref:System.AppDomain.GetData%2A>metoden.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "Namnet på en användardefinierad programmet domain-egenskapen för att skapa eller ändra."
    - id: data
      type: System.Object
      description: "Värdet för egenskapen."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tilldelar det angivna värdet för egenskapen angivet program domän med en angiven behörighet till begäran anroparens när egenskapen hämtas."
  remarks: "Använd den här metoden för att infoga eller ändra posterna med användardefinierade i internt cacheminne med par av namn/data som beskriver egenskaperna för programdomänen. När du infogar en post, anger du en behörighet begäran att tvinga när posten har hämtats. Dessutom kan du anropa den här metoden om du vill ange värdet för timeout standardintervallet för utvärdering av mönster för reguljära uttryck genom att ange &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; som värde för den `name` argumentet och en <xref:System.TimeSpan>värde som representerar timeout-intervall som värde för den `data` argument.</xref:System.TimeSpan>       Du kan inte använda den här metoden för att tilldela en säkerhets-begäran till en systemdefinierade egenskapssträng.       Cachen innehåller fördefinierade poster som infogas när programdomänen skapas automatiskt. Du kan inte infoga eller ändra system poster med den här metoden. Ett metodanrop som försöker ändra en system-post har ingen effekt; metoden Inget undantag genereras. Du kan inspektera värden av system med den <xref:System.AppDomain.GetData%2A>metoden eller motsvarande <xref:System.AppDomainSetup>Egenskaper som beskrivs i avsnittet Anmärkningar för den <xref:System.AppDomain.GetData%2A>metoden.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "Namnet på en användardefinierad programmet domain-egenskapen för att skapa eller ändra."
    - id: data
      type: System.Object
      description: "Värdet för egenskapen."
    - id: permission
      type: System.Security.IPermission
      description: "Behörighet att begäran anroparens när egenskapen hämtas."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>Anger en systemdefinierade egenskapssträng och <code>permission</code> är inte <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Anger sökvägen till angivna katalogen som baskatalog underkataloger där dynamiskt skapade filer lagras och komma åt."
  remarks: "Den här metoden anger det <xref:System.AppDomainSetup.DynamicBase%2A>egenskap i den interna <xref:System.AppDomainSetup>som är associerade med den här instansen.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "Den fullständiga sökvägen är baskatalog underkataloger där dynamiska sammansättningar lagras."
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Anger hur huvudnamn och identitet objekt ska kopplas till en tråd om tråden görs ett försök att binda till en huvudansvarig vid körning i den här domänen."
  remarks: "Det här värdet kommer endast tillämpas om du ställer in innan du använder den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapen.</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Till exempel om du ställer in <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>till en viss säkerhetsobjekt (till exempel en allmän huvudnamn) och sedan använda metoden SetPrincipalPolicy för att ange den <xref:System.Security.Principal.PrincipalPolicy>till <xref:System.Security.Principal.PrincipalPolicy>, aktuella principal förblir den allmänna huvudnamn.</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "En av de <xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;> </xref> värden som anger typen av huvudobjekt att ansluta till trådar."
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Aktiverar shadow kopiera."
  remarks: "Mer information om hur du kopierar shadow finns [Shadow kopierar sammansättningar](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Anger sökvägen till angivna katalogen som platsen för sammansättningar ska skuggkopior."
  remarks: "Som standard innehåller alla sammansättningar som hittades via sökning i en skuggkopia. Metoden SetShadowCopyPath begränsar skuggkopian till sammansättningar i kataloger som anges av `path`.       Metoden SetShadowCopyPath anger inte ytterligare kataloger som ska genomsökas för sammansättningar. Sammansättningar ska kopieras shadow måste redan finnas i sökvägen, till exempel under <xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> Metoden SetShadowCopyPath anger vilka sökvägar som är berättigade till shadow-kopieras.       Den här metoden anger det <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>egenskap i den interna <xref:System.AppDomainSetup>som är associerade med den här instansen.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       Mer information om hur du kopierar shadow finns [Shadow kopierar sammansättningar](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "En lista över katalognamn, där varje namn separerade med semikolon."
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Anger det standard för huvudobjektet som ska kopplas till trådar om de försöker att binda till en huvudansvarig vid körning i den här domänen."
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "Huvudobjektet att ansluta till trådar."
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "Tråd-objektet har redan angetts."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar programmet configuration domäninformation för den här instansen."
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "Programmet initieringen domäninformation."
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar en indikation om programdomänen är konfigurerad att shadow copy-filer."
  remarks: "Mer information finns i <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>och [Shadow kopierar sammansättningar](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>om programdomänen är konfigurerad till shadow copy-filer. Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Åtgärden utförs på en inaktiverats programdomän."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Matchar en uppsättning namn med en motsvarande uppsättning dispatch-identifierare."
  remarks: "Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod. Mer information om `IDispatch::GetIDsOfNames`, finns i MSDN Library."
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Reserverat för framtida användning. Måste vara IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "Skickades i matris med namn som ska mappas."
    - id: cNames
      type: System.UInt32
      description: "Antal namnen mappas."
    - id: lcid
      type: System.UInt32
      description: "Språkvariant-kontext att tolka namnen."
    - id: rgDispId
      type: System.IntPtr
      description: "Anroparen allokerade matris som tar emot de ID: N som motsvarar namnen."
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Sent bundna åtkomst med hjälp av COM `IDispatch` gränssnittet stöds inte."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar typinformation för ett objekt som kan användas för att hämta typinformation för ett gränssnitt."
  remarks: "Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod. Mer information om `IDispatch::GetTypeInfo`, finns i MSDN Library."
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "Informationen att returnera."
    - id: lcid
      type: System.UInt32
      description: "Språkvariant-ID för informationen."
    - id: ppTInfo
      type: System.IntPtr
      description: "Tar emot en pekare till informationsobjektet för den begärda typen."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Sent bundna åtkomst med hjälp av COM `IDispatch` gränssnittet stöds inte."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar antalet typen information gränssnitt att ett objekt tillhandahåller (0 eller 1)."
  remarks: "Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod. Mer information om `IDispatch::GetTypeInfoCount`, finns i MSDN Library."
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Pekar på en plats som tar emot antalet skriver information gränssnitt som tillhandahålls av objektet."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Sent bundna åtkomst med hjälp av COM `IDispatch` gränssnittet stöds inte."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tillhandahåller åtkomst till egenskaper och metoder som visas av ett objekt."
  remarks: "Den här metoden är för åtkomst till hanterade klasser från ohanterad kod och ska inte anropas från hanterad kod. Mer information om `IDispatch::Invoke`, finns i MSDN Library."
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identifierar medlemmen."
    - id: riid
      type: System.Guid
      description: "Reserverat för framtida användning. Måste vara IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "Språkvariant-kontext att tolka argument."
    - id: wFlags
      type: System.Int16
      description: "Flaggor som beskriver kontexten för anropet."
    - id: pDispParams
      type: System.IntPtr
      description: "Pekare till en struktur som innehåller en matris med argument, en matris med argumentet DISPID för namngivna argument och antal för antalet element i matriser."
    - id: pVarResult
      type: System.IntPtr
      description: "Pekar till den plats där resultatet ska lagras."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Pekare till en struktur som innehåller undantagsinformation om."
    - id: puArgErr
      type: System.IntPtr
      description: "Indexet för det första argumentet som har ett fel."
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Sent bundna åtkomst med hjälp av COM `IDispatch` gränssnittet stöds inte."
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hämtar en strängrepresentation som innehåller namnet på programdomänen och eventuella Kontextprinciper."
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "En sträng formaterad genom att den exakta strängen &quot;namn:&quot;, det egna namnet på programdomänen samt sträng som representerar Kontextprinciper eller strängen &quot;det finns inga Kontextprinciper.&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Programdomänen som representeras av aktuellt <xref href=&quot;System.AppDomain&quot;> </xref> har inaktiverats."
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när matchning av en typ som inte."
  remarks: "TypeResolve-händelsen inträffar när CLR kan inte fastställa sammansättningen som kan skapa den begärda typen. Detta kan inträffa om typen är definierad i en dynamisk sammansättning eller typen har inte definierats i en dynamisk sammansättning utan körningsmiljön inte vet vilken typen har definierats i sammansättningen. Den senare situationen kan inträffa när <xref:System.Type.GetType%2A?displayProperty=fullName>anropas med ett namn som inte är kvalificerad med sammansättningsnamnet.</xref:System.Type.GetType%2A?displayProperty=fullName>       Den <xref:System.ResolveEventHandler>för den här händelsen kan försöka att leta upp och skapa typen.</xref:System.ResolveEventHandler>       Händelsen TypeResolve sker dock inte om körningen vet att det inte går att hitta en typ i vissa sammansättningar. Den här händelsen uppstår till exempel inte om typen inte finns i en statisk sammansättning eftersom körningen vet typer inte kan läggas till dynamiskt till statisk sammansättningar.       Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>-egenskapen innehåller sammansättningen som begärt typen.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Mer information finns i <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Du måste ha behörigheterna som krävs för att registrera en händelsehanterare för den här händelsen, eller en <xref:System.Security.SecurityException>genereras.</xref:System.Security.SecurityException>       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inträffar när ett inte är undantagsfel."
  remarks: "Den här händelsen ger meddelande om undantagsfel utan felhantering. Det innebär att du kan logga information om undantaget innan systemet standard hanteraren rapporterar undantag för användaren och avslutar programmet. Om det finns tillräckligt med information om tillståndet för programmet andra åtgärder kan genomföras – till exempel spara programdata för senare återställning. Försiktighet rekommenderas eftersom programdata kan skadas om undantag som inte hanteras.      > [!NOTE] > I .NET Framework-versioner 1.0- och 1.1 programmet avslutas och felsökningsalternativ rapporteras för användaren innan den här händelsen inträffar, snarare än efter.       Den här händelsen kan hanteras i en domän. Dock visas händelsen inte nödvändigtvis i den domän där undantaget inträffade. Ett undantag är ohanterade endast om hela stacken för tråden har frigöras utan att hitta en tillämplig undantagshanterare så att den första plats händelsen som kan visas är i programdomänen som tråden kom från.      > [!NOTE] > I .NET Framework version 1.0 och 1.1, den här händelsen inträffar bara för standarddomänen som skapas av systemet när programmet startas. Om ett program skapar ytterligare programdomäner, har ange ett ombud för den här händelsen i domänerna program ingen effekt.       Om händelsen UnhandledException hanteras i standarddomänen kan uppstår det det för alla undantag i en tråd, oavsett vilken tillämpningsdomän som tråden startades i. Om tråden startades i en domän som har en händelsehanterare för UnhandledException, visas händelsen i den domänen. Om den domänen är inte standarddomänen och det finns också en händelsehanterare i standarddomänen, visas händelsen i båda programdomäner.       Till exempel anta att en tråd startar i programdomänen &quot;AD1&quot; anropar en metod i programdomänen &quot;AD2&quot; och därifrån anropar en metod i programdomänen &quot;AD3&quot;, där det genererar ett undantag. Första programdomänen som händelsen UnhandledException kan aktiveras är &quot;AD1&quot;. Om den domänen inte är standarddomänen kan du även upp händelsen i standarddomänen.      > [!NOTE] > Common language runtime pausar tråd avbryts medan händelsehanterare för händelsen UnhandledException körs.       Om händelsehanteraren har en <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>attribut med korrekta flaggor händelsehanteraren behandlas som ett begränsat körningsområde.</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], inte den här händelsen utlöses för undantag som skadad tillståndet för processen som flödar över stack eller komma åt överträdelser, såvida inte händelsehanteraren är kritiska och har den <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>attribut.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       Ett ohanterat undantag som uppstår i en annan tråd än tråden som programmets fångas upp av körningsmiljön i .NET Framework-versioner 1.0- och 1.1 och därför medföra inte att programmet avslutas. Därför är det möjligt för UnhandledException-händelse ska uppstå utan att programmet avslutas. Från och med .NET Framework version 2.0 kan den här backstop ohanterat undantag i underordnade trådar har tagits bort, eftersom den kumulativa effekten av sådana tysta fel ingår prestandaförsämring skadade data och låsningar som har svårt att felsöka. Mer information, inklusive en lista över fall där körningsmiljön inte avslutas, se [undantag i hanterade trådar](~/add/includes/ajax-current-ext-md.md).       Du måste ha behörigheterna som krävs för att registrera en händelsehanterare för den här händelsen, eller en <xref:System.Security.SecurityException>genereras.</xref:System.Security.SecurityException>       Mer information om hur du hanterar händelser finns [händelser](~/add/includes/ajax-current-ext-md.md).      ## Andra händelser för ohanterat undantag för vissa program modeller, UnhandledException händelse kan avbrytas av andra händelser om ohanterat undantag inträffar i tråden huvudfönster.       Ohanterat undantag i programmets tråd orsak i program som använder Windows Forms på <xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>-händelse.</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> Om den här händelsen hanteras är standardbeteendet att ohanterat undantag inte avslutar programmet, även om programmet finns kvar i ett okänt tillstånd. I så fall utlöses UnhandledException händelsen inte. Detta beteende kan ändras med hjälp av programmets konfigurationsfil eller med hjälp av <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>metoden för att ändra läget till <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>innan <xref:System.Windows.Forms.Application.ThreadException>händelsehanteraren är ansluten Utskriftsforma</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> Detta gäller endast för programmets tråd. UnhandledException händelsen utlöses för ohanterat undantag i andra trådar.       Från och med Microsoft Visual Studio 2005, innehåller Visual Basic application framework en annan händelse för ohanterade undantag i programmets tråden. Finns det <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>händelse.</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> Den här händelsen har ett argument objekt med samma namn som händelse-argument som används av UnhandledException, men med olika egenskaper. I synnerhet objektet händelse argument har en <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>egenskap som gör att program kan fortsätta körs, ignorerar ohanterat undantag (och lämnar programmet i ett okänt tillstånd).</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> I så fall utlöses UnhandledException händelsen inte."
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "Som ska läggas till."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Inaktiverar den angivna domänen."
  remarks: "I .NET Framework version 2.0 har en tråd att ta bort programdomäner. Detta ger bättre tillförlitlighet, särskilt när är värd för .NET Framework. När tråden-anrop Unload markeras måldomänen för avlastning. Dedikerad tråden försöker ta bort domänen och avbryts alla trådar i domänen. Om en tråd inte att avbryta, till exempel eftersom det körs ohanterad kod, eller eftersom det körs en `finally` block, sedan efter en viss tidsperiod en <xref:System.CannotUnloadAppDomainException>genereras i tråden som ursprungligen kallas Unload.</xref:System.CannotUnloadAppDomainException> Om den tråd som inte kunde avbrytas slutligen slutar är måldomänen inte bort från minnet. Därför i .NET Framework version 2.0 `domain` är inte säkert att ta bort, eftersom det inte kanske är möjligt att avsluta trådar som körs.      > [!NOTE] > I vissa fall kan anropa Unload orsakar en omedelbar <xref:System.CannotUnloadAppDomainException>, till exempel om den anropas i en slutföraren.</xref:System.CannotUnloadAppDomainException>       Trådarna i `domain` avslutas med hjälp av den <xref:System.Threading.Thread.Abort%2A>metod som genererar en <xref:System.Threading.ThreadAbortException>i tråden.</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> Även om tråden ska avslutas omedelbart, kan fortsätta körs för en oförutsägbart tidsperiod i en `finally` satsen.      ## Version programkompatibilitet i .NET Framework version 1.0 och 1.1 om tråden som anropar Unload körs i `domain`, en annan tråd har startats för att utföra åtgärden ta bort. Om `domain` kan inte tas bort, en <xref:System.CannotUnloadAppDomainException>genereras i tråden, inte i den ursprungliga tråden som kallas Unload.</xref:System.CannotUnloadAppDomainException> Men om tråden som anropar Unload körs utanför `domain`, att tråden får undantaget."
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "En tillämpningsdomän ta bort."
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>Det gick inte bort från minnet."
  - type: System.Exception
    commentId: T:System.Exception
    description: "Ett fel uppstod under processen bort från minnet."
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
