### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "Representerar en först in, först ut samling objekt."
  remarks: "Den här klassen implementerar en kö som en cirkulär matris. Objekt som lagras i en kö infogas i en slutet och tas bort från den andra.       Köer och grupper är användbara när du behöver tillfällig lagring för information. det vill säga när kanske du vill ta bort ett element efter hämtning av dess värde. Använd kö om du behöver ha tillgång till informationen i samma ordning som det lagras i samlingen. Använd <xref:System.Collections.Stack>Om du behöver komma åt information i omvänd ordning.</xref:System.Collections.Stack> Använd <xref:System.Collections.Concurrent.ConcurrentQueue%601>eller <xref:System.Collections.Concurrent.ConcurrentStack%601>Om du behöver åtkomst till samlingen från flera trådar samtidigt.</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       Tre huvudsakliga åtgärder kan utföras på en kö och dess element:- <xref:System.Collections.Queue.Enqueue%2A>lägger till ett element i slutet av kön.</xref:System.Collections.Queue.Enqueue%2A>      - <xref:System.Collections.Queue.Dequeue%2A>tar bort det äldsta elementet från början av kön.</xref:System.Collections.Queue.Dequeue%2A>      - <xref:System.Collections.Queue.Peek%2A>returnerar den äldsta element som är i början av kön men tar inte bort från kön.</xref:System.Collections.Queue.Peek%2A>       Antalet element i kön kan innehålla har kapacitet för en kö. Som läggs till i en kö, ökas automatiskt kapaciteten som krävs genom omfördelning.  Kapaciteten kan minskas genom att anropa <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Tillväxtfaktor är det tal som den aktuella kapaciteten multipliceras när en större kapacitet krävs.  Tillväxtfaktor bestäms när kön har skapats. Standard-tillväxtfaktor är 2.0. Kapaciteten för kön ökas alltid med minst minst fyra, oavsett tillväxtfaktor. Till exempel ökar en kö med en tillväxtfaktor 1.0 alltid kapaciteten av de fyra när en större kapacitet krävs.       Kön accepterar `null` som ett giltigt värde och tillåter dubblettelement.       Den allmänna versionen av den här samlingen, se<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initierar en ny instans av den <xref href=&quot;System.Collections.Queue&quot;> </xref> klass som är tomt, har den inledande standardkapaciteten och använder tillväxtfaktor standard."
  remarks: "Kapaciteten för en <xref:System.Collections.Queue>är antalet element i <xref:System.Collections.Queue>kan innehålla.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Som läggs till i en <xref:System.Collections.Queue>, ökas automatiskt kapaciteten som krävs genom omfördelning.</xref:System.Collections.Queue>  Kapaciteten kan minskas genom att anropa <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Tillväxtfaktor är det tal som den aktuella kapaciteten multipliceras när en större kapacitet krävs.  Tillväxtfaktor bestäms när den <xref:System.Collections.Queue>konstrueras.</xref:System.Collections.Queue>       Den här konstruktorn är en O(1)-åtgärd."
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initierar en ny instans av den <xref href=&quot;System.Collections.Queue&quot;> </xref> klass som innehåller element som kopieras från den angivna samlingen har samma inledande kapacitet som antalet element kopieras och använder tillväxtfaktor standard."
  remarks: "Kapaciteten för en <xref:System.Collections.Queue>är antalet element i <xref:System.Collections.Queue>kan innehålla.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Som läggs till i en <xref:System.Collections.Queue>, ökas automatiskt kapaciteten som krävs genom omfördelning.</xref:System.Collections.Queue>  Kapaciteten kan minskas genom att anropa <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Tillväxtfaktor är det tal som den aktuella kapaciteten multipliceras när en större kapacitet krävs.  Tillväxtfaktor bestäms när den <xref:System.Collections.Queue>konstrueras.</xref:System.Collections.Queue>       Elementen kopieras till <xref:System.Collections.Queue>i samma ordning som de läses av <xref:System.Collections.IEnumerator>i <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Queue>       Den här konstruktorn är en O (`n`) igen, där `n` är antalet element i `col`."
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "Den <xref:System.Collections.ICollection>att kopiera element från.</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initierar en ny instans av den <xref href=&quot;System.Collections.Queue&quot;> </xref> klass som är tomt, har den angivna inledande kapaciteten och använder tillväxtfaktor standard."
  remarks: "Kapaciteten för en <xref:System.Collections.Queue>är antalet element i <xref:System.Collections.Queue>kan innehålla.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Som läggs till i en <xref:System.Collections.Queue>, ökas automatiskt kapaciteten som krävs genom omfördelning.</xref:System.Collections.Queue>  Kapaciteten kan minskas genom att anropa <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Tillväxtfaktor är det tal som den aktuella kapaciteten multipliceras när en större kapacitet krävs.  Tillväxtfaktor bestäms när den <xref:System.Collections.Queue>konstrueras.</xref:System.Collections.Queue>       Om storleken på samlingen kan vara eliminerar att ange den inledande kapaciteten behovet av att genomföra ett antal storleksändringar när du lägger till element i <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Den här konstruktorn är en O (`n`) igen, där `n` är `capacity`."
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Det ursprungliga numret för element som det <xref href=&quot;System.Collections.Queue&quot;> </xref> kan innehålla."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>är mindre än noll."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initierar en ny instans av den <xref href=&quot;System.Collections.Queue&quot;> </xref> klass som är tomt, har den angivna inledande kapaciteten och använder den angivna tillväxtfaktor."
  remarks: "Kapaciteten för en <xref:System.Collections.Queue>är antalet element i <xref:System.Collections.Queue>kan innehålla.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Som läggs till i en <xref:System.Collections.Queue>, ökas automatiskt kapaciteten som krävs genom omfördelning.</xref:System.Collections.Queue>  Kapaciteten kan minskas genom att anropa <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Tillväxtfaktor är det tal som den aktuella kapaciteten multipliceras när en större kapacitet krävs.  Tillväxtfaktor bestäms när den <xref:System.Collections.Queue>konstrueras.</xref:System.Collections.Queue> Kapaciteten för den <xref:System.Collections.Queue>alltid ökar med ett minsta värde, oavsett tillväxtfaktor; en tillväxtfaktor 1.0 hindrar inte den <xref:System.Collections.Queue>från ökar i storlek.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Om storleken på samlingen kan vara eliminerar att ange den inledande kapaciteten behovet av att genomföra ett antal storleksändringar när du lägger till element i <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Den här konstruktorn är en O (`n`) igen, där `n` är `capacity`."
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Det ursprungliga numret för element som det <xref href=&quot;System.Collections.Queue&quot;> </xref> kan innehålla."
    - id: growFactor
      type: System.Single
      description: "Faktorn som kapaciteten för den <xref href=&quot;System.Collections.Queue&quot;> </xref> utökas."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>är mindre än noll.       - eller - <code>growFactor</code> är större än 10.0 eller mindre än 1,0."
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Tar bort alla objekt från den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "<xref:System.Collections.Queue.Count%2A>är angivet till noll och släpps också referenser till andra objekt från element i mängden.</xref:System.Collections.Queue.Count%2A>       Kapaciteten förblir oförändrad. Att återställa kapacitet <xref:System.Collections.Queue>anropa <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> </xref:System.Collections.Queue> Minska en tom <xref:System.Collections.Queue>anger kapaciteten för den <xref:System.Collections.Queue>till standardkapaciteten.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Skapar en lite kopia av den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "En lite kopia av en samling kopieras endast element i mängden, om de är referenstyper eller värdetyper, men kopierar inte de objekt som referenserna refererar till. Referenserna i den nya samlingen pekar på samma objekt som refererar till i samlingen ursprungliga pekar på.       Däremot en djup kopia av en samling kopierar elementen och allt direkt eller indirekt refereras av elementen.       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "En lite kopia av den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Anger om det är ett element i den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Den här metoden anger likheten genom att anropa <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Den här metoden utförs en linjär sökning. den här metoden är därför en O (`n`) igen, där `n` är <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>       Från och med .NET Framework 2.0 kan den här metoden använder den samling objekt <xref:System.Object.Equals%2A>och <xref:System.IComparable.CompareTo%2A>metoder i `obj` att avgöra om `item` finns.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> I tidigare versioner av .NET Framework gjordes detta genom att använda den <xref:System.Object.Equals%2A>och <xref:System.IComparable.CompareTo%2A>metoder för den `obj` parameter på objekten i samlingen.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Den <xref:System.Object>att hitta i den <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Object> Värdet kan vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopior av <xref href=&quot;System.Collections.Queue&quot;> </xref> element i en befintlig endimensionell <xref:System.Array>början från det angivna matrisindexet.</xref:System.Array>"
  remarks: "Elementen kopieras till <xref:System.Array>i den ordning i vilken uppräknaren går igenom <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Array>       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "Den endimensionell <xref:System.Array>som är mål för element som kopieras från <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Array> Den <xref:System.Array>måste ha Nollbaserad indexering.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "Det nollbaserade indexet i `array` vilka kopiera börjar."
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>är mindre än noll."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>är multidimensionell.       - eller - antalet element i källan <xref href=&quot;System.Collections.Queue&quot;> </xref> är större än det tillgängliga utrymmet från <code>index</code> till slutet av destinationen <code>array</code>."
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "Typ av källan <xref href=&quot;System.Collections.Queue&quot;> </xref> kan inte omvandlas automatiskt till typ av målet <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hämtar antalet element som ingår i den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Kapaciteten för en <xref:System.Collections.Queue>är antalet element som det <xref:System.Collections.Queue>kan lagra.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Antalet är antalet element som finns i <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Kapaciteten för en <xref:System.Collections.Queue>alltid är större än eller lika med Count.</xref:System.Collections.Queue> Om antalet överstiger kapaciteten när du lägger till element, ökar kapaciteten automatiskt med omallokera den interna matrisen innan du kopierar gamla element och lägga till nya element. Den nya kapaciteten bestäms genom att multiplicera den aktuella kapaciteten med tillväxtfaktor som är fastställt när den <xref:System.Collections.Queue>konstrueras.</xref:System.Collections.Queue> Kapaciteten för den <xref:System.Collections.Queue>alltid ökar med ett minsta värde, oavsett tillväxtfaktor; en tillväxtfaktor 1.0 hindrar inte den <xref:System.Collections.Queue>från ökar i storlek.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Kapaciteten kan minskas genom att anropa <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Hämtar värdet för den här egenskapen är en O(1)-åtgärd."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Antalet element i den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Tar bort och returnerar objektet i början av den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Den här metoden påminner om den <xref:System.Collections.Queue.Peek%2A>metoden, men <xref:System.Collections.Queue.Peek%2A>inte ändra <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Peek%2A> </xref:System.Collections.Queue.Peek%2A>       `null`Du kan lägga till den <xref:System.Collections.Queue>som ett-värde.</xref:System.Collections.Queue> Att skilja mellan ett null-värde och i slutet av den <xref:System.Collections.Queue>, kontrollera den <xref:System.Collections.Queue.Count%2A>egenskapen eller catch den <xref:System.InvalidOperationException>, som genereras när den <xref:System.Collections.Queue>är tom.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Den här metoden är en O(1)-åtgärd."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "Det objekt som tas bort från början av den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref href=&quot;System.Collections.Queue&quot;> </xref> är tom."
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Lägger till ett objekt i slutet av den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Kapaciteten för en <xref:System.Collections.Queue>är antalet element i <xref:System.Collections.Queue>kan innehålla.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Som läggs till i en <xref:System.Collections.Queue>, ökas automatiskt kapaciteten som krävs genom omfördelning.</xref:System.Collections.Queue>  Kapaciteten kan minskas genom att anropa <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Tillväxtfaktor är det tal som den aktuella kapaciteten multipliceras när en större kapacitet krävs.  Tillväxtfaktor bestäms när den <xref:System.Collections.Queue>konstrueras.</xref:System.Collections.Queue> Kapaciteten för den <xref:System.Collections.Queue>alltid ökar med ett minsta värde, oavsett tillväxtfaktor; en tillväxtfaktor 1.0 hindrar inte den <xref:System.Collections.Queue>från ökar i storlek.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Om <xref:System.Collections.Queue.Count%2A>är mindre än kapaciteten på den interna matrisen, den här metoden är en O(1) åtgärd.</xref:System.Collections.Queue.Count%2A> Om den interna matrisen måste allokeras om för att hantera nya element, blir den här metoden en O (`n`) igen, där `n` är <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Objektet för att lägga till den <xref href=&quot;System.Collections.Queue&quot;> </xref>. Värdet kan vara <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Returnerar en uppräknare går igenom den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Den `foreach` satsen i C#-språk (`for each` i Visual Basic) döljer komplexiteten i uppräknare.  Därför använder `foreach` rekommenderas, i stället för direkt manipulering uppräknaren.       Uppräknare kan användas för att läsa data i samlingen, men de kan inte användas för att ändra den underliggande mängden.       Inledningsvis har uppräknaren placerats före det första elementet i mängden. <xref:System.Collections.IEnumerator.Reset%2A>medför också uppräknaren tillbaka till den här positionen.</xref:System.Collections.IEnumerator.Reset%2A>  I den här positionen <xref:System.Collections.IEnumerator.Current%2A>är odefinierad.</xref:System.Collections.IEnumerator.Current%2A> Därför måste du anropa <xref:System.Collections.IEnumerator.MoveNext%2A>att avancera uppräknaren till det första elementet i mängden innan du läser värdet för <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>returnerar samma objekt förrän antingen <xref:System.Collections.IEnumerator.MoveNext%2A>eller <xref:System.Collections.IEnumerator.Reset%2A>kallas.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Anger <xref:System.Collections.IEnumerator.Current%2A>till nästa element.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Om <xref:System.Collections.IEnumerator.MoveNext%2A>passerar slutet på mängden uppräknaren är placerad efter det sista elementet i mängden och <xref:System.Collections.IEnumerator.MoveNext%2A>returnerar `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> När uppräknaren är på denna position efterföljande anrop till <xref:System.Collections.IEnumerator.MoveNext%2A>också returnera `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Om senast anropet till <xref:System.Collections.IEnumerator.MoveNext%2A>returnerade `false`, <xref:System.Collections.IEnumerator.Current%2A>är odefinierad.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Ange <xref:System.Collections.IEnumerator.Current%2A>att det första elementet i mängden igen, kan du anropa <xref:System.Collections.IEnumerator.Reset%2A>följt av <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       En uppräknare är giltig så länge samlingen förblir oförändrad. Om ändringar görs i samlingen, till exempel att lägga till, ändra eller ta bort element, uppräknaren blir inaktuella och sitt beteende är odefinierad.       Uppräknaren har inte exklusiv åtkomst till samlingen; uppräkning av en samling är därför är inte en trådsäker procedur.  Om du vill garantera tråd under uppräkning, kan du låsa samlingen under hela uppräkningen.  Om du vill tillåta en samling som ska användas av flera trådar för läsning och skrivning, måste du implementera ditt eget synkronisering.       Den här metoden är en O(1)-åtgärd."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hämtar ett värde som anger om åtkomst till den <xref href=&quot;System.Collections.Queue&quot;> </xref> är synkroniserade (trådsäkra)."
  remarks: "Att garantera säkerhet tråd i <xref:System.Collections.Queue>, alla åtgärder måste utföras via adapterprogram returneras av den <xref:System.Collections.Queue.Synchronized%2A>metoden.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       Uppräkning av en samling är är inte en trådsäker procedur. Även när en samling har synkroniserats, kan andra trådar ändå ändra samlingen, vilket gör att uppräknaren att utlösa ett undantag. För att garantera tråd under uppräkning, kan du låsa samlingen under hela uppräkning eller fånga undantag som uppstår till följd av ändringar som gjorts av andra trådar."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om åtkomst till den <xref href=&quot;System.Collections.Queue&quot;> </xref> är synkroniserade (trådsäkra); annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardvärdet är <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Returnerar objekt i början av den <xref href=&quot;System.Collections.Queue&quot;> </xref> utan att ta bort den."
  remarks: "Den här metoden liknar <xref:System.Collections.Queue.Dequeue%2A>metoden, men titt inte ändrar <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Dequeue%2A>       `null`Du kan lägga till den <xref:System.Collections.Queue>som ett-värde.</xref:System.Collections.Queue> Att skilja mellan ett null-värde och i slutet av den <xref:System.Collections.Queue>, kontrollera den <xref:System.Collections.Queue.Count%2A>egenskapen eller catch den <xref:System.InvalidOperationException>, som genereras när den <xref:System.Collections.Queue>är tom.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Den här metoden är en O(1)-åtgärd."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "Objektet i början av den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref href=&quot;System.Collections.Queue&quot;> </xref> är tom."
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Returnerar en ny <xref href=&quot;System.Collections.Queue&quot;> </xref> som omsluter ursprungliga kön och är trådsäkra."
  remarks: "Adapterprogram returneras av den här metoden låser kön innan en åtgärd utförs så att den utförs på ett trådsäkert sätt.       Att garantera säkerhet tråd i <xref:System.Collections.Queue>, alla åtgärder måste göras via den här wrapper endast.</xref:System.Collections.Queue>       Uppräkning av en samling är är inte en trådsäker procedur. Även när en samling har synkroniserats, kan andra trådar ändå ändra samlingen, vilket gör att uppräknaren att utlösa ett undantag. För att garantera tråd under uppräkning, kan du låsa samlingen under hela uppräkning eller fånga undantag som uppstår till följd av ändringar som gjorts av andra trådar."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "Den <xref href=&quot;System.Collections.Queue&quot;> </xref> att synkronisera."
    return:
      type: System.Collections.Queue
      description: "En <xref href=&quot;System.Collections.Queue&quot;> </xref> omslutning som är synkroniserade (trådsäkra)."
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hämtar ett objekt som kan användas för att synkronisera åtkomst till den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Så här skapar du en synkroniserade version av den <xref:System.Collections.Queue>, använda den <xref:System.Collections.Queue.Synchronized%2A>metoden.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> Härledda klasser kan dock ge sina egna synkroniserade versionen av den <xref:System.Collections.Queue>med egenskapen SyncRoot.</xref:System.Collections.Queue> Synkronisera kod måste utföra åtgärder på SyncRoot av den <xref:System.Collections.Queue>, inte direkt på <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Detta säkerställer att samlingar som är härledda från andra objekt ska fungera korrekt. Mer specifikt den upprätthåller rätt synkronisering med andra trådar samtidigt ändra den <xref:System.Collections.Queue>objekt.</xref:System.Collections.Queue>       Uppräkning av en samling är är inte en trådsäker procedur. Även när en samling har synkroniserats, kan andra trådar ändå ändra samlingen, vilket gör att uppräknaren att utlösa ett undantag. För att garantera tråd under uppräkning, kan du låsa samlingen under hela uppräkning eller fånga undantag som uppstår till följd av ändringar som gjorts av andra trådar."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Ett objekt som kan användas för att synkronisera åtkomst till den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopior av <xref href=&quot;System.Collections.Queue&quot;> </xref> element till en ny matris."
  remarks: "Den <xref:System.Collections.Queue>ändras inte.</xref:System.Collections.Queue> Ordningen på elementen i den nya matrisen är samma som ordningen på elementen från början av den <xref:System.Collections.Queue>till dess slut.</xref:System.Collections.Queue>       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "En ny matris som innehåller element som kopieras från den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Anger kapaciteten till det faktiska antalet element i den <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Den här metoden kan användas för att minimera minne för en kö försämras om inga nya objekt läggs till i kön.       Så här återställer du en <xref:System.Collections.Queue>till det ursprungliga tillståndet anropa den <xref:System.Collections.Queue.Clear%2A>metoden innan du anropar TrimToSize.</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> Minska en tom <xref:System.Collections.Queue>anger kapaciteten för den <xref:System.Collections.Queue>till standardkapaciteten.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Den här metoden är en O (`n`) igen, där `n` är <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den <xref href=&quot;System.Collections.Queue&quot;> </xref> är skrivskyddad."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
