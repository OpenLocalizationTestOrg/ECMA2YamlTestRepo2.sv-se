### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "Innehåller ett antal trådar som kan användas för att köra aktiviteter, publicera arbetsobjekt, bearbeta asynkrona i/o, vänta på uppdrag av andra trådar och bearbeta timers."
  remarks: "Många program skapar trådar som tillbringar mycket tid i tillståndet vilande väntar på att en händelse ska inträffa. Andra trådar kan ange vilande tillstånd endast aktiveras med jämna mellanrum för att söka efter en ändring eller uppdatera statusinformation. Trådpoolen kan du använda trådar effektivare genom att tillhandahålla ditt program med en pool av trådar som hanteras av systemet. Exempel på åtgärder som använder tråd pool trådar är följande: – när du skapar en <xref:System.Threading.Tasks.Task>eller <xref:System.Threading.Tasks.Task%601>objekt för att utföra en uppgift asynkront som standard aktiviteten är schemalagd att köras på en tråd pooltråd.</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Asynkron timers använda trådpoolen. Tråd pool trådar köra återanrop från <xref:System.Threading.Timer?displayProperty=fullName>klassen och generera händelser från <xref:System.Timers.Timer?displayProperty=fullName>klass.</xref:System.Timers.Timer?displayProperty=fullName> </xref:System.Threading.Timer?displayProperty=fullName>      -När du använder registrerade vänta handtag övervakar statusen för handtagen vänta en systemtråd. När en vänta har slutförts, kör en arbetstråd från trådpoolen motsvarande Återanropsfunktionen.      -När du anropar den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metod för att kön är en metod för körning på en tråd pooltråd.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Du kan göra detta genom att skicka metoden en <xref:System.Threading.WaitCallback>Delegera.</xref:System.Threading.WaitCallback>   Delegaten har signatur <CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder> där `state` är ett objekt som innehåller data som ska användas av delegaten.    Den faktiska data kan skickas till delegaten genom att anropa den <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>metoden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Trådarna i hanterade trådpoolen är bakgrundstrådar. Det vill säga deras <xref:System.Threading.Thread.IsBackground%2A>Egenskaper är `true`.</xref:System.Threading.Thread.IsBackground%2A> Det innebär att en arbetstråd tråd inte har kvar ett program som körs när alla trådar i förgrunden har avslutats.      > [!IMPORTANT] > När trådpoolen återanvänder en tråd, tas inte bort data i tråden lokal lagring eller fält som är markerade med den <xref:System.ThreadStaticAttribute>attribut.</xref:System.ThreadStaticAttribute> Därför när en metod undersöker tråd lokal lagring eller fält som har markerats med den <xref:System.ThreadStaticAttribute>attribut och värden som påträffas kan bli från en tidigare körning av tråd pooltråd.</xref:System.ThreadStaticAttribute>       Du kan också kö arbetsobjekt som inte är relaterade till en åtgärd för vänta till trådpoolen. Om du vill begära att ett arbetsobjekt ska hanteras av en tråd i trådpoolen anropa den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metoden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Den här metoden tar en referens till metoden eller ombud som kommer att anropas av tråd markerats trådpoolen som en parameter. Det går inte att avbryta en arbetsuppgift när har placerats i kö.       Timer-kön timers och registrerade vänta åtgärder du också använda trådpoolen. Deras Återanropsfunktioner köas till trådpoolen.       Det finns en trådpoolen processer. Från och med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], standardstorleken för trådpoolen för en process är beroende av flera faktorer, till exempel storleken på det virtuella adressutrymmet. En process kan anropa den <xref:System.Threading.ThreadPool.GetMaxThreads%2A>metod för att bestämma antalet trådar.</xref:System.Threading.ThreadPool.GetMaxThreads%2A> Antalet trådar som trådpoolen kan ändras med hjälp av den <xref:System.Threading.ThreadPool.SetMaxThreads%2A>metoden.</xref:System.Threading.ThreadPool.SetMaxThreads%2A> Varje tråd körs vid standardprioritet använder stack standardstorleken.      > [!NOTE] > Ohanterad kod som är värd för .NET Framework kan ändra storlek på trådpoolen med hjälp av den `CorSetMaxThreads` funktion, definieras i filen mscoree.h.       Trådpoolen ger nya arbetstrådar eller i/o-slutförande trådar på begäran tills minst för varje kategori. När minst uppnås trådpoolen skapa ytterligare trådar i den kategorin eller vänta tills några uppgifter är klar. Från och med den [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], trådpoolen skapas och förstörs trådar för att optimera genomflödet som definieras som antalet aktiviteter som Slutför per tidsenhet. För få trådar kan inte göra optimal användning av tillgängliga resurser för många trådar kan öka resurskonflikter.      > [!NOTE] > När begäran har låg det faktiska antalet trådar som tråd pool kan faller under de lägsta värdena.       Du kan använda den <xref:System.Threading.ThreadPool.GetMinThreads%2A>metod för att hämta dessa minimivärden.</xref:System.Threading.ThreadPool.GetMinThreads%2A>      > [!CAUTION] > Du kan använda den <xref:System.Threading.ThreadPool.SetMinThreads%2A>metod för att öka det minsta antalet trådar.</xref:System.Threading.ThreadPool.SetMinThreads%2A> Men kan i onödan öka dessa värden orsaka prestandaproblem. För många aktiviteter som startas samtidigt, kan alla verkar vara långsam. Trådpoolen fungerar bättre med sin egen algoritmen för fördelning av trådar i de flesta fall."
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Binder en operativsystemet referensen till den <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "En <xref:System.IntPtr>som innehåller referensen.</xref:System.IntPtr> Referensen måste har öppnats för överlappande I/O på ohanterade sida."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om referensen är bundet; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Binder en operativsystemet referensen till den <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  remarks: "Den `osHandle` parameter ska vara en <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>som härleds från en abstrakt <xref:System.Runtime.InteropServices.SafeHandle>klass.</xref:System.Runtime.InteropServices.SafeHandle> </xref:Microsoft.Win32.SafeHandles.SafeFileHandle>"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "En <xref:System.Runtime.InteropServices.SafeHandle>som innehåller operativsystemet referensen.</xref:System.Runtime.InteropServices.SafeHandle> Referensen måste har öppnats för överlappande I/O på ohanterade sida."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om referensen är bundet; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar skillnaden mellan det maximala antalet tråd pool trådar som returneras av den <xref:System.Threading.ThreadPool.GetMaxThreads*>metoden och hur många som för närvarande är aktiva.</xref:System.Threading.ThreadPool.GetMaxThreads*>"
  remarks: "När GetAvailableThreads returnerar den variabel som anges av `workerThreads` innehåller antalet ytterligare trådar som kan startas och variabeln anges av `completionPortThreads` innehåller antalet ytterligare asynkrona i/o-trådar som kan startas.       Om det finns inga tillgängliga trådar, förblir ytterligare tråd pool begäranden i kö tills tråd pool trådar blir tillgängliga."
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Antal tillgängliga arbetstrådar."
    - id: completionPortThreads
      type: System.Int32
      description: "Antal tillgängliga asynkrona i/o-trådar."
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar antalet begäranden till trådpoolen som kan vara aktiva samtidigt. Alla förfrågningar högre än den finns kvar i kö tills tråd pool trådar blir tillgängliga."
  remarks: "När GetMaxThreads returnerar den variabel som anges av `workerThreads` innehåller det maximala antalet trådar som tillåts i trådpoolen och variabeln anges av `completionPortThreads` innehåller det maximala antalet asynkrona i/o-trådar som tillåts i trådpoolen.       Du kan använda den <xref:System.Threading.ThreadPool.GetAvailableThreads%2A>metod för att bestämma det faktiska antalet trådar som trådpoolen vid en given tidpunkt.</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>       Du kan använda den <xref:System.Threading.ThreadPool.SetMaxThreads%2A>att ange det maximala antalet trådar och asynkrona i/o-trådar i trådpoolen.</xref:System.Threading.ThreadPool.SetMaxThreads%2A>       Du kan kö som många tråd pool begäranden som tillåter systemminnet. Om det finns flera begäranden än tråd pool trådar, förblir ytterligare begäranden i kö tills tråd pool trådar blir tillgängliga."
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Maximalt antal trådar i trådpoolen."
    - id: completionPortThreads
      type: System.Int32
      description: "Maximalt antal asynkrona i/o-trådar som trådpoolen."
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hämtar det minsta antalet trådar som trådpoolen skapas på begäran, nya begäran görs innan du växlar till en algoritm för att hantera tråd skapas och förstörs."
  remarks: "Trådpoolen ger nya arbetstrådar eller i/o-slutförande trådar på begäran tills minst för varje kategori. Det minsta antalet trådar är som standard, antalet processorer på ett system. När minst har uppnåtts trådpoolen skapa ytterligare trådar i den kategorin eller vänta tills några uppgifter är klar. Från och med den [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], trådpoolen trådar skapas och förstörs för att optimera genomflödet som definieras som antalet aktiviteter som Slutför per tidsenhet. För få trådar kan inte göra optimal användning av tillgängliga resurser för många trådar kan öka resurskonflikter.      > [!NOTE] > När begäran har låg det faktiska antalet trådar som tråd pool kan faller under de lägsta värdena."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "När den här metoden returnerar innehåller det minsta antalet trådar som trådpoolen skapas på begäran."
    - id: completionPortThreads
      type: System.Int32
      description: "När den här metoden returnerar innehåller det minsta antalet asynkrona i/o-trådar som trådpoolen skapas på begäran."
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Köar en metod för körning. Metoden körs när en tråd pooltråd blir tillgänglig."
  remarks: "Du kan placera data som krävs av den köade-metoden i Instansfält i klassen som definieras eller använda den <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>överlagring som accepterar ett objekt som innehåller nödvändiga data.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Visual Basic-användare kan utelämna den <xref:System.Threading.WaitCallback>konstruktorn och välja den `AddressOf` operatorn vid övergång Återanropsmetoden till <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.WaitCallback> Visual Basic anropar automatiskt rätt delegatkonstruktor.      ## Version Information i .NET Framework version 2.0 av <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapens värde sprids till trådar i kö med den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metoden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Den huvudsakliga informationen sprids inte i tidigare versioner."
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "En <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> som representerar metoden som ska köras."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om metoden är korrekt i kö; <xref:System.NotSupportedException>genereras om arbetsobjektet inte placeras i kö.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Common language runtime (CLR) är värdbaserad och värden stöder inte den här åtgärden."
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Köar en metod för körning och anger ett objekt som innehåller data som ska användas av-metoden. Metoden körs när en tråd pooltråd blir tillgänglig."
  remarks: "Om Återanropsmetoden kräver komplexa data, kan du definiera en klass som innehåller data.      > [!NOTE] > Visual Basic-användare kan utelämna den <xref:System.Threading.WaitCallback>konstruktorn och välja den `AddressOf` operatorn vid övergång Återanropsmetoden till QueueUserWorkItem.</xref:System.Threading.WaitCallback> Visual Basic anropar automatiskt rätt delegatkonstruktor.      ## Version Information i .NET Framework version 2.0 av <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapens värde sprids till trådar i kö med den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metoden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Den huvudsakliga informationen sprids inte i tidigare versioner."
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "En <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> som representerar metoden som ska köras."
    - id: state
      type: System.Object
      description: "Ett objekt som innehåller data som ska användas av-metoden."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om metoden är korrekt i kö; <xref:System.NotSupportedException>genereras om arbetsobjektet inte placeras i kö.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Common language runtime (CLR) är värdbaserad och värden stöder inte den här åtgärden."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerar ett ombud för en <xref:System.Threading.WaitHandle>, ange ett 32-bitars heltal för tidsgräns i millisekunder.</xref:System.Threading.WaitHandle>"
  remarks: "När du är klar med den <xref:System.Threading.RegisteredWaitHandle>som returneras av den här metoden, anropa dess <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod för att frigöra referenser till väntereferens.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi rekommenderar att du alltid anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod, även om du anger `true` för `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Skräpinsamling fungerar mer effektivt om du anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod i stället för beroende på den registrerade väntereferens slutföraren.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoden RegisterWaitForSingleObject köar angivna delegaten till trådpoolen. En arbetstråd körs delegaten när något av följande inträffar:-det angivna objektet är i tillståndet signalerat.      -Tidsgränsen har gått ut.       Metoden RegisterWaitForSingleObject kontrollerar det aktuella tillståndet för det angivna objektet <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Om objektets tillstånd är unsignaled registrerar metoden en vänta-åtgärd. Vänta åtgärden utförs av en tråd från trådpoolen. Delegaten körs av en arbetstråd när objektets tillstånd blir signal eller timeout-intervall långa. Om den `timeOutInterval` parametern är inte 0 (noll) och `executeOnlyOnce` parametern är `false`, återställer timern varje gång händelsen signal eller timeout-intervall långa.      > [!IMPORTANT] > Med hjälp av en <xref:System.Threading.Mutex>för `waitObject` ger inte ömsesidigt uteslutande för återanrop eftersom den underliggande Win32 API använder förvalet `WT_EXECUTEDEFAULT` flaggan så att varje återanrop skickas i en separat tråd pooltråd.</xref:System.Threading.Mutex> I stället för en <xref:System.Threading.Mutex>, använda en <xref:System.Threading.Semaphore>med det maximala antalet 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Om du vill avbryta åtgärden vänta anropa den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Vänta tråd använder Win32 `WaitForMultipleObjects` funktion för att övervaka registrerade vänta drift. Därför, om du måste använda samma operativsystem referensen i flera anrop till RegisterWaitForSingleObject, måste du duplicera referensen med hjälp av Win32 `DuplicateHandle` funktion. Observera att du inte ska pulsval ett objekt skickades till RegisterWaitForSingleObject, eftersom tråden vänta inte kan identifiera händelsen signal innan den återställs.       Innan det returneras, ändrar funktionen tillståndet för vissa typer av Synkroniseringsobjekten. Ändring inträffar bara för objektet vars signalerat tillstånd orsakas väntevillkor är uppfyllda. Till exempel minskar antalet en semafor med en.      ## Version Information från och med .NET Framework version 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapens värde sprids till trådar i kö med hjälp av den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Den huvudsakliga informationen sprids inte i tidigare versioner."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>att registrera.</xref:System.Threading.WaitHandle> Använd ett <xref:System.Threading.WaitHandle>annat än <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Den <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> ombud att anropa när den `waitObject` parametern signaleras."
    - id: state
      type: System.Object
      description: "Det objekt som har överförts till delegaten."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Tidsgräns i millisekunder. Om den `millisecondsTimeOutInterval` parametern är 0 (noll), funktionen testar objektets tillstånd och returnerar omedelbart. Om `millisecondsTimeOutInterval` är-1, aldrig långa funktionens timeout-intervall."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Anger att tråden inte väntar den `waitObject` parametern efter delegaten har anropats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att indikera att timern återställs varje gång vänta åtgärden har slutförts förrän väntetiden har avregistrerats."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> som kapslar in den egna referensen."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parametern är mindre än -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerar ett ombud för en <xref:System.Threading.WaitHandle>, ange ett 64-bitars heltal för tidsgräns i millisekunder.</xref:System.Threading.WaitHandle>"
  remarks: "När du är klar med den <xref:System.Threading.RegisteredWaitHandle>som returneras av den här metoden, anropa dess <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod för att frigöra referenser till väntereferens.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi rekommenderar att du alltid anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod, även om du anger `true` för `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Skräpinsamling fungerar mer effektivt om du anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod i stället för beroende på den registrerade väntereferens slutföraren.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoden RegisterWaitForSingleObject köar angivna delegaten till trådpoolen. En arbetstråd körs delegaten när något av följande inträffar:-det angivna objektet är i tillståndet signalerat.      -Tidsgränsen har gått ut.       Metoden RegisterWaitForSingleObject kontrollerar det aktuella tillståndet för det angivna objektet <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Om objektets tillstånd är unsignaled registrerar metoden en vänta-åtgärd. Vänta åtgärden utförs av en tråd från trådpoolen. Delegaten körs av en arbetstråd när objektets tillstånd blir signal eller timeout-intervall långa. Om den `timeOutInterval` parametern är inte 0 (noll) och `executeOnlyOnce` parametern är `false`, återställer timern varje gång händelsen signal eller timeout-intervall långa.      > [!IMPORTANT] > Med hjälp av en <xref:System.Threading.Mutex>för `waitObject` ger inte ömsesidigt uteslutande för återanrop eftersom den underliggande Win32 API använder förvalet `WT_EXECUTEDEFAULT` flaggan så att varje återanrop skickas i en separat tråd pooltråd.</xref:System.Threading.Mutex> I stället för en <xref:System.Threading.Mutex>, använda en <xref:System.Threading.Semaphore>med det maximala antalet 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Om du vill avbryta åtgärden vänta anropa den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Vänta tråd använder Win32 `WaitForMultipleObjects` funktion för att övervaka registrerade vänta drift. Därför, om du måste använda samma operativsystem referensen i flera anrop till RegisterWaitForSingleObject, måste du duplicera referensen med hjälp av Win32 `DuplicateHandle` funktion. Observera att du inte ska pulsval ett objekt skickades till RegisterWaitForSingleObject, eftersom tråden vänta inte kan identifiera händelsen signal innan den återställs.       Innan det returneras, ändrar funktionen tillståndet för vissa typer av Synkroniseringsobjekten. Ändring inträffar bara för objektet vars signalerat tillstånd orsakas väntevillkor är uppfyllda. Till exempel minskar antalet en semafor med en.      ## Version Information från och med .NET Framework version 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapens värde sprids till trådar i kö med hjälp av den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Den huvudsakliga informationen sprids inte i tidigare versioner."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>att registrera.</xref:System.Threading.WaitHandle> Använd ett <xref:System.Threading.WaitHandle>annat än <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Den <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> ombud att anropa när den `waitObject` parametern signaleras."
    - id: state
      type: System.Object
      description: "Objektet som skickats till ombudet."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Tidsgräns i millisekunder. Om den `millisecondsTimeOutInterval` parametern är 0 (noll), funktionen testar objektets tillstånd och returnerar omedelbart. Om `millisecondsTimeOutInterval` är-1, aldrig långa funktionens timeout-intervall."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Anger att tråden inte väntar den `waitObject` parametern efter delegaten har anropats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att indikera att timern återställs varje gång vänta åtgärden har slutförts förrän väntetiden har avregistrerats."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> som kapslar in den egna referensen."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parametern är mindre än -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerar ett ombud för en <xref:System.Threading.WaitHandle>, ange en <xref:System.TimeSpan>värdet för tidsgränsen.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle>"
  remarks: "När du är klar med den <xref:System.Threading.RegisteredWaitHandle>som returneras av den här metoden, anropa dess <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod för att frigöra referenser till väntereferens.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi rekommenderar att du alltid anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod, även om du anger `true` för `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Skräpinsamling fungerar mer effektivt om du anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod i stället för beroende på den registrerade väntereferens slutföraren.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoden RegisterWaitForSingleObject köar angivna delegaten till trådpoolen. En arbetstråd körs delegaten när något av följande inträffar:-det angivna objektet är i tillståndet signalerat.      -Tidsgränsen har gått ut.       Metoden RegisterWaitForSingleObject kontrollerar det aktuella tillståndet för det angivna objektet <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Om objektets tillstånd är unsignaled registrerar metoden en vänta-åtgärd. Vänta åtgärden utförs av en tråd från trådpoolen. Delegaten körs av en arbetstråd när objektets tillstånd blir signal eller timeout-intervall långa. Om den `timeOutInterval` parametern är inte 0 (noll) och `executeOnlyOnce` parametern är `false`, återställer timern varje gång händelsen signal eller timeout-intervall långa.      > [!IMPORTANT] > Med hjälp av en <xref:System.Threading.Mutex>för `waitObject` ger inte ömsesidigt uteslutande för återanrop eftersom den underliggande Win32 API använder förvalet `WT_EXECUTEDEFAULT` flaggan så att varje återanrop skickas i en separat tråd pooltråd.</xref:System.Threading.Mutex> I stället för en <xref:System.Threading.Mutex>, använda en <xref:System.Threading.Semaphore>med det maximala antalet 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Om du vill avbryta åtgärden vänta anropa den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Vänta tråd använder Win32 `WaitForMultipleObjects` funktion för att övervaka registrerade vänta drift. Därför, om du måste använda samma operativsystem referensen i flera anrop till RegisterWaitForSingleObject, måste du duplicera referensen med hjälp av Win32 `DuplicateHandle` funktion. Observera att du inte ska pulsval ett objekt skickades till RegisterWaitForSingleObject, eftersom tråden vänta inte kan identifiera händelsen signal innan den återställs.       Innan det returneras, ändrar funktionen tillståndet för vissa typer av Synkroniseringsobjekten. Ändring inträffar bara för objektet vars signalerat tillstånd orsakas väntevillkor är uppfyllda. Till exempel minskar antalet en semafor med en.      ## Version Information från och med .NET Framework version 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapens värde sprids till trådar i kö med hjälp av den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Den huvudsakliga informationen sprids inte i tidigare versioner."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>att registrera.</xref:System.Threading.WaitHandle> Använd ett <xref:System.Threading.WaitHandle>annat än <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Den <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> ombud att anropa när den `waitObject` parametern signaleras."
    - id: state
      type: System.Object
      description: "Objektet som skickats till ombudet."
    - id: timeout
      type: System.TimeSpan
      description: "Timeout-värdet som representeras av ett <xref:System.TimeSpan>.</xref:System.TimeSpan> Om `timeout` är 0 (noll), funktionen testar objektets tillstånd och returnerar omedelbart. Om `timeout` är-1, aldrig långa funktionens timeout-intervall."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Anger att tråden inte väntar den `waitObject` parametern efter delegaten har anropats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att indikera att timern återställs varje gång vänta åtgärden har slutförts förrän väntetiden har avregistrerats."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> som kapslar in den egna referensen."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> timeout </code> parametern är mindre än -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den <code> timeout </code> parameter är större än &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerar ett ombud för en <xref:System.Threading.WaitHandle>, ange en 32-bitars heltal utan tecken timout-värdet för i millisekunder.</xref:System.Threading.WaitHandle>"
  remarks: "När du är klar med den <xref:System.Threading.RegisteredWaitHandle>som returneras av den här metoden, anropa dess <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod för att frigöra referenser till väntereferens.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi rekommenderar att du alltid anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod, även om du anger `true` för `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Skräpinsamling fungerar mer effektivt om du anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod i stället för beroende på den registrerade väntereferens slutföraren.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden köer angivna delegaten till trådpoolen.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> En arbetstråd körs delegaten när något av följande inträffar:-det angivna objektet är i tillståndet signalerat.      -Tidsgränsen har gått ut.       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>Metoden kontrollerar det aktuella tillståndet för det angivna objektet <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> </xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Om objektets tillstånd är unsignaled registrerar metoden en vänta-åtgärd. Vänta åtgärden utförs av en tråd från trådpoolen. Delegaten körs av en arbetstråd när objektets tillstånd blir signal eller timeout-intervall långa. Om den `timeOutInterval` parametern är inte 0 (noll) och `executeOnlyOnce` parametern är `false`, återställer timern varje gång händelsen signal eller timeout-intervall långa.      > [!IMPORTANT] > Med hjälp av en <xref:System.Threading.Mutex>för `waitObject` ger inte ömsesidigt uteslutande för återanrop eftersom den underliggande Win32 API använder förvalet `WT_EXECUTEDEFAULT` flaggan så att varje återanrop skickas i en separat tråd pooltråd.</xref:System.Threading.Mutex> I stället för en <xref:System.Threading.Mutex>, använda en <xref:System.Threading.Semaphore>med det maximala antalet 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Om du vill avbryta åtgärden vänta anropa den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Vänta tråd använder Win32 `WaitForMultipleObjects` funktion för att övervaka registrerade vänta drift. Därför, om du måste använda samma operativsystem referensen i flera-anrop till <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, måste du duplicera referensen med hjälp av Win32 `DuplicateHandle` funktion.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Observera att du inte pulsval ett objekt skickades till <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>eftersom tråden vänta inte upptäcker kanske att händelsen signal innan den återställs.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>       Innan det returneras, ändrar funktionen tillståndet för vissa typer av Synkroniseringsobjekten. Ändring inträffar bara för objektet vars signalerat tillstånd orsakas väntevillkor är uppfyllda. Till exempel minskar antalet en semafor med en.      ## Version Information från och med .NET Framework version 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapens värde sprids till trådar i kö med hjälp av den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Den huvudsakliga informationen sprids inte i tidigare versioner."
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>att registrera.</xref:System.Threading.WaitHandle> Använd ett <xref:System.Threading.WaitHandle>annat än <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Den <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> ombud att anropa när den `waitObject` parametern signaleras."
    - id: state
      type: System.Object
      description: "Objektet som skickats till ombudet."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Tidsgräns i millisekunder. Om den `millisecondsTimeOutInterval` parametern är 0 (noll), funktionen testar objektets tillstånd och returnerar omedelbart. Om `millisecondsTimeOutInterval` är-1, aldrig långa funktionens timeout-intervall."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Anger att tråden inte väntar den `waitObject` parametern efter delegaten har anropats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att indikera att timern återställs varje gång vänta åtgärden har slutförts förrän väntetiden har avregistrerats."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> som kan användas för att avbryta registrerade vänta."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parametern är mindre än -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Anger antalet begäranden till trådpoolen som kan vara aktiva samtidigt. Alla förfrågningar högre än den finns kvar i kö tills tråd pool trådar blir tillgängliga."
  remarks: "Du kan inte ange det maximala antalet arbetstrådar eller -trådar för i/o-slutförande till ett värde mindre än antalet processorer på datorn. För att avgöra hur många processorer finns att hämta värdet för den <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>egenskapen.</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> Dessutom kan du ange det maximala antalet arbetstrådar eller i/o-slutförande trådar till ett tal som är mindre än motsvarande minsta antalet arbetstrådar eller i/o slutförande trådar. För att fastställa poolstorleken minsta tråd anropa den <xref:System.Threading.ThreadPool.GetMinThreads%2A>metoden.</xref:System.Threading.ThreadPool.GetMinThreads%2A>       Om CLR finns, till exempel av Internet Information Services (IIS) eller SQL Server kan värden begränsa eller förhindra att tråden poolens storlek ändras.       Var försiktig när du ändrar det maximala antalet trådar som trådpoolen. När koden har nytta kan ändringarna ha en negativ effekt på koden bibliotek som du använder.       Storleken anges tråd pool för stor kan orsaka prestandaproblem. Om för många trådar som körs på samma gång blir uppgiften växling tillsynen en viktig faktor."
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Maximalt antal trådar i trådpoolen."
    - id: completionPortThreads
      type: System.Int32
      description: "Maximalt antal asynkrona i/o-trådar som trådpoolen."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om ändringen är genomförd; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Anger det minsta antalet trådar som trådpoolen skapas på begäran, nya begäran görs innan du växlar till en algoritm för att hantera tråd skapas och förstörs."
  remarks: "Trådpoolen ger nya arbetstrådar eller i/o-slutförande trådar på begäran tills minst för varje kategori. När minst har uppnåtts trådpoolen skapa ytterligare trådar i den kategorin eller vänta tills några uppgifter är klar. Från och med den [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], trådpoolen trådar skapas och förstörs för att optimera genomflödet som definieras som antalet aktiviteter som Slutför per tidsenhet. För få trådar kan inte göra optimal användning av tillgängliga resurser för många trådar kan öka resurskonflikter.       När begäran är låg, kan det faktiska antalet trådar som tråd pool faller under de lägsta värdena.       Om du anger ett negativt tal eller en siffra som är större än det maximala antalet trådar som aktiv tråd pool (erhållits med <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), SetMinThreads returnerar `false` och ändrar inte någon av de lägsta värdena.</xref:System.Threading.ThreadPool.GetMaxThreads%2A>      > [!CAUTION] > Det minsta antalet trådar är som standard att antalet processorer på ett system. Du kan använda metoden SetMinThreads för att öka det minsta antalet ofthreads. Men kan i onödan öka dessa värden orsaka prestandaproblem. För många aktiviteter som startas samtidigt, kan alla verkar vara långsam. Trådpoolen fungerar bättre med sin egen algoritmen för fördelning av trådar i de flesta fall. Minska minst till mindre än antalet processorer kan också försämra prestanda."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Minsta antal trådar som trådpoolen skapas på begäran."
    - id: completionPortThreads
      type: System.Int32
      description: "Det minsta antalet asynkrona i/o-trådar som trådpoolen skapas på begäran."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om ändringen är genomförd; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Köar en överlappande i/o-åtgärd för körning."
  remarks: "Information om hur du använder inbyggd Win32 överlappad i/o, finns i <xref:System.Threading.Overlapped>klassen, de <xref:System.Threading.NativeOverlapped>struktur, och `OVERLAPPED` strukturen i Win32 Platform SDK.</xref:System.Threading.NativeOverlapped> </xref:System.Threading.Overlapped>      > [!CAUTION] > Med hjälp av UnsafeQueueNativeOverlapped metod kan oavsiktligt öppna ett säkerhetshål. Kodåtkomstsäkerhet baserar behörigheterna för alla anropare behörighet kontrollen på stacken. När arbetet är i kö på en tråd pooltråd med hjälp av UnsafeQueueNativeOverlapped, har inte stacken tråd pool trådens kontexten för de faktiska anropare. Skadlig kod kanske kan utnyttja detta för att undvika behörighet kontroller."
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "Den <xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref> struktur till kö."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om åtgärden har i kö för ett i/o-slutförandeport; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Köer angivna delegaten till trådpoolen, men spridas inte till arbetstråden anropa stacken."
  remarks: "Till skillnad från den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>UnsafeQueueUserWorkItem-metoden inte spridas till arbetstråden anropa stacken.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Detta gör att kod förlorar den anropande stacken och därigenom höja dess behörighet.      > [!CAUTION] > Med UnsafeQueueUserWorkItem kan oavsiktligt öppna ett säkerhetshål. Kodåtkomstsäkerhet baserar behörigheterna för alla anropare behörighet kontrollen på stacken. När arbetet är i kö på en tråd pooltråd med hjälp av UnsafeQueueUserWorkItem, tråd pool trådens stacken inte kontexten för de faktiska anropare. Skadlig kod kanske kan utnyttja detta för att undvika behörighet kontroller."
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "En <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> som representerar ombudet som ska anropas när en tråd i trådpoolen hämtar arbetsobjektet."
    - id: state
      type: System.Object
      description: "Det objekt som har överförts till delegaten när underhålls från trådpoolen."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om metoden lyckas; <xref:System.OutOfMemoryException>genereras om arbetsobjektet inte placeras i kö.</xref:System.OutOfMemoryException>"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Ett villkor i minnet är slut har påträffats."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Arbetsobjektet kunde inte i kö."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerar ett ombud för en <xref:System.Threading.WaitHandle>, med ett 32-bitars heltal för tidsgräns i millisekunder.</xref:System.Threading.WaitHandle> Den här metoden inte spridas till arbetstråden anropa stacken."
  remarks: "Till skillnad från den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject-metoden inte spridas till arbetstråden anropa stacken.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Detta gör att kod förlorar den anropande stacken och därigenom höja dess behörighet.      > [!CAUTION] > Med UnsafeRegisterWaitForSingleObject kan oavsiktligt öppna ett säkerhetshål. Kodåtkomstsäkerhet baserar behörigheterna för alla anropare behörighet kontrollen på stacken. När arbetet är i kö på en tråd pooltråd med hjälp av UnsafeRegisterWaitForSingleObject, tråd pool trådens stacken inte kontexten för de faktiska anropare. Skadlig kod kanske kan utnyttja detta för att undvika behörighet kontroller.       Med hjälp av en <xref:System.Threading.Mutex>för `waitObject` ger inte ömsesidigt uteslutande för återanrop eftersom den underliggande Win32 API använder förvalet `WT_EXECUTEDEFAULT` flaggan så att varje återanrop skickas i en separat tråd pooltråd.</xref:System.Threading.Mutex>       När du är klar med den <xref:System.Threading.RegisteredWaitHandle>som returneras av den här metoden, anropa dess <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod för att frigöra referenser till väntereferens.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi rekommenderar att du alltid anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod, även om du anger `true` för `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Skräpinsamling fungerar mer effektivt om du anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod i stället för beroende på den registrerade väntereferens slutföraren.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>att registrera.</xref:System.Threading.WaitHandle> Använd ett <xref:System.Threading.WaitHandle>annat än <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Delegaten att anropa när den `waitObject` parametern signaleras."
    - id: state
      type: System.Object
      description: "Det objekt som har överförts till delegaten."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Tidsgräns i millisekunder. Om den `millisecondsTimeOutInterval` parametern är 0 (noll), funktionen testar objektets tillstånd och returnerar omedelbart. Om `millisecondsTimeOutInterval` är-1, aldrig långa funktionens timeout-intervall."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Anger att tråden inte väntar den `waitObject` parametern efter delegaten har anropats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att indikera att timern återställs varje gång vänta åtgärden har slutförts förrän väntetiden har avregistrerats."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objekt som kan användas för att avbryta registrerade vänta."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parametern är mindre än -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerar ett ombud för en <xref:System.Threading.WaitHandle>, ange ett 64-bitars heltal för tidsgräns i millisekunder.</xref:System.Threading.WaitHandle> Den här metoden inte spridas till arbetstråden anropa stacken."
  remarks: "Till skillnad från den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject-metoden inte spridas till arbetstråden anropa stacken.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Detta gör att kod förlorar den anropande stacken och därigenom höja dess behörighet.      > [!CAUTION] > Med UnsafeRegisterWaitForSingleObject kan oavsiktligt öppna ett säkerhetshål. Kodåtkomstsäkerhet baserar behörigheterna för alla anropare behörighet kontrollen på stacken. När arbetet är i kö på en tråd pooltråd med hjälp av UnsafeRegisterWaitForSingleObject, tråd pool trådens stacken inte kontexten för de faktiska anropare. Skadlig kod kanske kan utnyttja detta för att undvika behörighet kontroller.       Med hjälp av en <xref:System.Threading.Mutex>för `waitObject` ger inte ömsesidigt uteslutande för återanrop eftersom den underliggande Win32 API använder förvalet `WT_EXECUTEDEFAULT` flaggan så att varje återanrop skickas i en separat tråd pooltråd.</xref:System.Threading.Mutex>       När du är klar med den <xref:System.Threading.RegisteredWaitHandle>som returneras av den här metoden, anropa dess <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod för att frigöra referenser till väntereferens.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi rekommenderar att du alltid anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod, även om du anger `true` för `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Skräpinsamling fungerar mer effektivt om du anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod i stället för beroende på den registrerade väntereferens slutföraren.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>att registrera.</xref:System.Threading.WaitHandle> Använd ett <xref:System.Threading.WaitHandle>annat än <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Delegaten att anropa när den `waitObject` parametern signaleras."
    - id: state
      type: System.Object
      description: "Det objekt som har överförts till delegaten."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Tidsgräns i millisekunder. Om den `millisecondsTimeOutInterval` parametern är 0 (noll), funktionen testar objektets tillstånd och returnerar omedelbart. Om `millisecondsTimeOutInterval` är-1, aldrig långa funktionens timeout-intervall."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Anger att tråden inte väntar den `waitObject` parametern efter delegaten har anropats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att indikera att timern återställs varje gång vänta åtgärden har slutförts förrän väntetiden har avregistrerats."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objekt som kan användas för att avbryta registrerade vänta."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parametern är mindre än -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerar ett ombud för en <xref:System.Threading.WaitHandle>, ange en <xref:System.TimeSpan>värdet för tidsgränsen.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle> Den här metoden inte spridas till arbetstråden anropa stacken."
  remarks: "Till skillnad från den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject-metoden inte spridas till arbetstråden anropa stacken.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Detta gör att kod förlorar den anropande stacken och därigenom höja dess behörighet.      > [!CAUTION] > Med UnsafeRegisterWaitForSingleObject kan oavsiktligt öppna ett säkerhetshål. Kodåtkomstsäkerhet baserar behörigheterna för alla anropare behörighet kontrollen på stacken. När arbetet är i kö på en tråd pooltråd med hjälp av UnsafeRegisterWaitForSingleObject, tråd pool trådens stacken inte kontexten för de faktiska anropare. Skadlig kod kanske kan utnyttja detta för att undvika behörighet kontroller.       Med hjälp av en <xref:System.Threading.Mutex>för `waitObject` ger inte ömsesidigt uteslutande för återanrop eftersom den underliggande Win32 API använder förvalet `WT_EXECUTEDEFAULT` flaggan så att varje återanrop skickas i en separat tråd pooltråd.</xref:System.Threading.Mutex>       När du är klar med den <xref:System.Threading.RegisteredWaitHandle>som returneras av den här metoden, anropa dess <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod för att frigöra referenser till väntereferens.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi rekommenderar att du alltid anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod, även om du anger `true` för `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Skräpinsamling fungerar mer effektivt om du anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod i stället för beroende på den registrerade väntereferens slutföraren.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>att registrera.</xref:System.Threading.WaitHandle> Använd ett <xref:System.Threading.WaitHandle>annat än <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Delegaten att anropa när den `waitObject` parametern signaleras."
    - id: state
      type: System.Object
      description: "Det objekt som har överförts till delegaten."
    - id: timeout
      type: System.TimeSpan
      description: "Timeout-värdet som representeras av ett <xref:System.TimeSpan>.</xref:System.TimeSpan> Om `timeout` är 0 (noll), funktionen testar objektets tillstånd och returnerar omedelbart. Om `timeout` är-1, aldrig långa funktionens timeout-intervall."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Anger att tråden inte väntar den `waitObject` parametern efter delegaten har anropats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att indikera att timern återställs varje gång vänta åtgärden har slutförts förrän väntetiden har avregistrerats."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objekt som kan användas för att avbryta registrerade vänta."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> timeout </code> parametern är mindre än -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den <code> timeout </code> parameter är större än &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerar ett ombud för en <xref:System.Threading.WaitHandle>, ange en 32-bitars heltal utan tecken timout-värdet för i millisekunder.</xref:System.Threading.WaitHandle> Den här metoden inte spridas till arbetstråden anropa stacken."
  remarks: "Till skillnad från den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject-metoden inte spridas till arbetstråden anropa stacken.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Detta gör att kod förlorar den anropande stacken och därigenom höja dess behörighet.      > [!CAUTION] > Med UnsafeRegisterWaitForSingleObject kan oavsiktligt öppna ett säkerhetshål. Kodåtkomstsäkerhet baserar behörigheterna för alla anropare behörighet kontrollen på stacken. När arbetet är i kö på en tråd pooltråd med hjälp av UnsafeRegisterWaitForSingleObject, tråd pool trådens stacken inte kontexten för de faktiska anropare. Skadlig kod kanske kan utnyttja detta för att undvika behörighet kontroller.       Med hjälp av en <xref:System.Threading.Mutex>för `waitObject` ger inte ömsesidigt uteslutande för återanrop eftersom den underliggande Win32 API använder förvalet `WT_EXECUTEDEFAULT` flaggan så att varje återanrop skickas i en separat tråd pooltråd.</xref:System.Threading.Mutex>       När du är klar med den <xref:System.Threading.RegisteredWaitHandle>som returneras av den här metoden, anropa dess <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod för att frigöra referenser till väntereferens.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi rekommenderar att du alltid anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod, även om du anger `true` för `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Skräpinsamling fungerar mer effektivt om du anropar den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metod i stället för beroende på den registrerade väntereferens slutföraren.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>att registrera.</xref:System.Threading.WaitHandle> Använd ett <xref:System.Threading.WaitHandle>annat än <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Delegaten att anropa när den `waitObject` parametern signaleras."
    - id: state
      type: System.Object
      description: "Det objekt som har överförts till delegaten."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Tidsgräns i millisekunder. Om den `millisecondsTimeOutInterval` parametern är 0 (noll), funktionen testar objektets tillstånd och returnerar omedelbart. Om `millisecondsTimeOutInterval` är-1, aldrig långa funktionens timeout-intervall."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Anger att tråden inte väntar den `waitObject` parametern efter delegaten har anropats; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att indikera att timern återställs varje gång vänta åtgärden har slutförts förrän väntetiden har avregistrerats."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objekt som kan användas för att avbryta registrerade vänta."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Anroparen har inte behörigheten som krävs."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
