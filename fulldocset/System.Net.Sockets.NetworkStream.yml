### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "Innehåller den underliggande dataströmmen för nätverksåtkomst."
  remarks: "NetworkStream-klassen innehåller metoder för att skicka och ta emot data via <xref:System.Net.Sockets.SocketType>sockets i blockerande läge.</xref:System.Net.Sockets.SocketType> Mer information om att blockera jämfört med icke-blockerande <xref:System.Net.Sockets.Socket>s, se [med hjälp av en asynkron klientsocket](~/add/includes/ajax-current-ext-md.md).</xref:System.Net.Sockets.Socket> Du kan använda klassen NetworkStream för båda synkrona och asynkrona dataöverföring. Läs mer om synkrona och asynkrona kommunikation [Sockets](~/add/includes/ajax-current-ext-md.md).       Om du vill skapa en NetworkStream, måste du ange en ansluten <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Du kan även ange vilken <xref:System.IO.FileAccess>behörighet i NetworkStream har över den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IO.FileAccess> Som standard stängs stänger NetworkStream inte den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Om du vill att NetworkStream har behörighet att stänga den tillhandahållna <xref:System.Net.Sockets.Socket>, måste du ange `true` för värdet för den `ownsSocket` parameter.</xref:System.Net.Sockets.Socket>       Använd den <xref:System.Net.Sockets.NetworkStream.Write%2A>och <xref:System.Net.Sockets.NetworkStream.Read%2A>metoder för att enkelt enkel tråd synkron blockerande i/o.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> Om du vill bearbeta din I/O med olika trådar kan du använda den <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>och <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>metoder eller <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>och <xref:System.Net.Sockets.NetworkStream.EndRead%2A>metoder för kommunikation.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       NetworkStream har inte stöd för direktåtkomst till dataflödet i nätverket. Värdet för den <xref:System.Net.Sockets.NetworkStream.CanSeek%2A>-egenskap som anger om dataströmmen stöder sökning, är alltid `false`; läsning av <xref:System.Net.Sockets.NetworkStream.Position%2A>egenskapen läsa den <xref:System.Net.Sockets.NetworkStream.Length%2A>egenskap, eller anropa <xref:System.Net.Sockets.NetworkStream.Seek%2A>metoden genereras ett <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       Läsa och skriva åtgärder kan utföras samtidigt på en instans av klassen NetworkStream utan att behöva för synkronisering. Så länge det finns en unik tråd för skrivåtgärder och en unik tråd för läsåtgärder, finns inga mellan störningar mellan läsa och skriva trådar och ingen synkronisering krävs."
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Skapar en ny instans av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klassen för den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Skapas med åtkomst till den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Sockets.NetworkStream>Inte äger den underliggande <xref:System.Net.Sockets.Socket>så anropar <xref:System.Net.Sockets.NetworkStream.Close%2A>metoden inte stänger <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Den <xref:System.Net.Sockets.Socket>som den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> använder för att skicka och ta emot data.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den <code> socket </code> parameter är inte anslutet.       - eller - <xref:System.Net.Sockets.Socket.SocketType*>-egenskapen för den <code> socket </code> parametern är inte &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - eller - <code> socket </code> parameter är i ett icke-blockerande tillstånd."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Initierar en ny instans av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klassen för den angivna <xref:System.Net.Sockets.Socket>med det angivna <xref:System.Net.Sockets.Socket>ägarskap.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Skapas med åtkomst till den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Om värdet för `ownsSocket` parametern är `true`, <xref:System.Net.Sockets.NetworkStream>ägarskapet till den underliggande <xref:System.Net.Sockets.Socket>, och anropar <xref:System.Net.Sockets.NetworkStream.Close%2A>metoden stängs också underliggande <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Den <xref:System.Net.Sockets.Socket>som den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> använder för att skicka och ta emot data.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Ange till <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> som indikerar att den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> ska bli ägare till den <xref:System.Net.Sockets.Socket>, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den <code> socket </code> parameter är inte anslutet.       - eller - värdet för den <xref:System.Net.Sockets.Socket.SocketType*>egenskapen för den <code> socket </code> parametern är inte &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - eller - <code> socket </code> parameter är i ett icke-blockerande tillstånd."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Skapar en ny instans av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klassen för den angivna <xref:System.Net.Sockets.Socket>med de angivna åtkomstbehörigheterna.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Med den angivna åtkomsten till den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Med den här konstruktorn <xref:System.Net.Sockets.NetworkStream>inte äger det underliggande <xref:System.Net.Sockets.Socket>så anropar <xref:System.Net.Sockets.NetworkStream.Close%2A>metoden inte Stäng den underliggande <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Den `access` parametern anger <xref:System.Net.Sockets.NetworkStream.CanRead%2A>och <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Egenskaper i <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> Om du anger <xref:System.IO.FileAccess>, sedan <xref:System.Net.Sockets.NetworkStream>tillåter anrop till den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Om du anger <xref:System.IO.FileAccess>, sedan <xref:System.Net.Sockets.NetworkStream>tillåter anrop till den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Om du anger <xref:System.IO.FileAccess>, både metodanrop tillåts.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Den <xref:System.Net.Sockets.Socket>som den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> använder för att skicka och ta emot data.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "En binär kombination av den <xref href=&quot;System.IO.FileAccess&quot;> </xref> värden som anger vilken typ av åtkomst till den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> över den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den <code> socket </code> parameter är inte anslutet.       - eller - <xref:System.Net.Sockets.Socket.SocketType*>-egenskapen för den <code> socket </code> parametern är inte &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - eller - <code> socket </code> parameter är i ett icke-blockerande tillstånd."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Skapar en ny instans av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klassen för den angivna <xref:System.Net.Sockets.Socket>med angivna behörigheter och den angivna <xref:System.Net.Sockets.Socket>ägarskap.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Skapas med åtkomst till den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Om värdet för den `ownsSocket` parametern är `true`, <xref:System.Net.Sockets.NetworkStream>ägarskapet till den underliggande <xref:System.Net.Sockets.Socket>, och anropar <xref:System.Net.Sockets.NetworkStream.Close%2A>metoden stängs också underliggande <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Den `access` parametern anger <xref:System.Net.Sockets.NetworkStream.CanRead%2A>och <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Egenskaper i <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> Om du anger <xref:System.IO.FileAccess>, sedan <xref:System.Net.Sockets.NetworkStream>tillåter anrop till den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Om du anger <xref:System.IO.FileAccess>, sedan <xref:System.Net.Sockets.NetworkStream>tillåter anrop till den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Om du anger <xref:System.IO.FileAccess>, både metodanrop tillåts.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Den <xref:System.Net.Sockets.Socket>som den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> använder för att skicka och ta emot data.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "En binär kombination av den <xref href=&quot;System.IO.FileAccess&quot;> </xref> värden som anger vilken typ av åtkomst till den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> över den angivna <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Ange till <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> som indikerar att den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> ska bli ägare till den <xref:System.Net.Sockets.Socket>, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den <code> socket </code> parameter är inte anslutet.       - eller - <xref:System.Net.Sockets.Socket.SocketType*>-egenskapen för den <code> socket </code> parametern är inte &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - eller - <code> socket </code> parameter är i ett icke-blockerande tillstånd."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Börjar en asynkron läsning från den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Metoden BeginRead startar asynkront läsning av data från inkommande nätverk buffertar. Att anropa metoden BeginRead ger dig möjlighet att ta emot data i en separat körning tråd.       Du måste skapa en metod som implementerar det <xref:System.AsyncCallback>Delegera och ange dess namn till metoden BeginRead.</xref:System.AsyncCallback> Vid mycket minimum, din `state` parameter måste innehålla <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Eftersom du vill hämta den mottagna data i din metod, bör du skapa en liten klass eller struktur för en läsbuffert och annan relevant information. Skicka strukturen eller klassen instans till metoden BeginRead via den `state` parameter.       Din metod ska anropa den <xref:System.Net.Sockets.NetworkStream.EndRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> När programmet anropar BeginRead, systemet ska vänta tills data tas emot eller ett fel uppstår, och sedan systemet att använda en separat tråd för att köra den angivna Återanropsmetoden och block på <xref:System.Net.Sockets.NetworkStream.EndRead%2A>tills angiven <xref:System.Net.Sockets.NetworkStream>läser data eller genererar ett undantag.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> Om du vill att den ursprungliga tråden ska blockeras när du anropar metoden BeginRead använder den <xref:System.Threading.WaitHandle.WaitOne%2A>metoden.</xref:System.Threading.WaitHandle.WaitOne%2A> Anropa <xref:System.Threading.EventWaitHandle.Set%2A>i Återanropsmetoden när du vill att den ursprungliga tråden att fortsätta att köra.</xref:System.Threading.EventWaitHandle.Set%2A> Mer information om hur du skriver callback-metoder finns [konvertera en delegat som en Återanropsmetoden](~/add/includes/ajax-current-ext-md.md).       Metoden BeginRead läser så mycket data som finns tillgänglig, upp till antalet byte som anges av den `size` parameter.      > [!NOTE] > Om du får ett <xref:System.IO.IOException>Kontrollera <xref:System.Exception.InnerException%2A>egenskapen för att avgöra om den orsakades av ett <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> I så fall använder den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>egenskapen för att hämta den specifika felkoden och Windows Sockets version 2 API felkod dokumentationen i MSDN för en detaljerad beskrivning av felet.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Läsa och skriva åtgärder kan utföras samtidigt på en instans av den <xref:System.Net.Sockets.NetworkStream>klass utan att behöva synkronisering.</xref:System.Net.Sockets.NetworkStream> Så länge det finns en unik tråd för skrivåtgärder och en unik tråd för läsåtgärder, finns inga mellan störningar mellan läsa och skriva trådar och ingen synkronisering krävs."
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "En matris av typen <xref:System.Byte>som plats i minnet för att lagra data läses från den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Platsen i `buffer` ska börja lagra data."
    - id: size
      type: System.Int32
      description: "Antalet byte som ska läsas från den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "Den <xref:System.AsyncCallback>delegat som körs när BeginRead har slutförts.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Ett objekt som innehåller ytterligare användardefinierade data."
    return:
      type: System.IAsyncResult
      description: "En <xref:System.IAsyncResult>som representerar asynkront anrop.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> offset </code> parameter är mindre än 0.       - eller - <code> offset </code> parameter är större än längden på den <code> buffer </code> parameter.       - eller - <code> size </code> är mindre än 0.       - eller - <code> size </code> är större än längden på <code> buffer </code> minus värdet för den <code> offset </code> parameter."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggande <xref:System.Net.Sockets.Socket>är stängd.</xref:System.Net.Sockets.Socket>       - eller - ett fel inträffade vid läsning från nätverket.       - eller - ett fel uppstod vid åtkomst till socket. I avsnittet Anmärkningar för mer information."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> är stängd."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Börjar en asynkron skrivning till en dataström."
  remarks: "Metoden BeginWrite startar en asynkron sändningsåtgärd till fjärrvärden. Att anropa metoden BeginWrite ger dig möjlighet att skicka data i en separat körning tråd.       Du måste skapa en metod som implementerar det <xref:System.AsyncCallback>Delegera och ange dess namn till metoden BeginWrite.</xref:System.AsyncCallback> Vid mycket minimum, din `state` parameter måste innehålla <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Om din återanrop behöver mer information, kan du skapa en liten klass eller struktur för att rymma den <xref:System.Net.Sockets.NetworkStream>och den nödvändiga informationen.</xref:System.Net.Sockets.NetworkStream> Skicka strukturen eller klassen instans till metoden BeginWrite via den `state` parameter.       Din metod bör genomföra den <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>metoden.</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> När programmet anropar BeginWrite, systemet använder en separat tråd för att köra den angivna Återanropsmetoden och blockerar på <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>tills den <xref:System.Net.Sockets.NetworkStream>skickar antalet byte som har begärts eller genererar ett undantag.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Om du vill att den ursprungliga tråden ska blockeras när du anropar metoden BeginWrite använder den <xref:System.Threading.WaitHandle.WaitOne%2A>metoden.</xref:System.Threading.WaitHandle.WaitOne%2A> Anropa <xref:System.Threading.EventWaitHandle.Set%2A>i Återanropsmetoden när du vill att den ursprungliga tråden att fortsätta att köra.</xref:System.Threading.EventWaitHandle.Set%2A> Mer information om hur du skriver callback-metoder finns [konvertera en delegat som en Återanropsmetoden](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Om du får ett <xref:System.IO.IOException>Kontrollera <xref:System.Exception.InnerException%2A>egenskapen för att avgöra om den orsakades av ett <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> I så fall använder den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>egenskapen för att hämta den specifika felkoden och Windows Sockets version 2 API felkod dokumentationen i MSDN för en detaljerad beskrivning av felet.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Läsa och skriva åtgärder kan utföras samtidigt på en instans av den <xref:System.Net.Sockets.NetworkStream>klass utan att behöva synkronisering.</xref:System.Net.Sockets.NetworkStream> Så länge det finns en unik tråd för skrivåtgärder och en unik tråd för läsåtgärder, finns inga mellan störningar mellan läsa och skriva trådar och ingen synkronisering krävs."
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "En matris av typen <xref:System.Byte>som innehåller data att skriva till den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Platsen i `buffer` ska börja skicka data."
    - id: size
      type: System.Int32
      description: "Antal byte att skriva till den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "Den <xref:System.AsyncCallback>delegat som körs när BeginWrite har slutförts.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Ett objekt som innehåller ytterligare användardefinierade data."
    return:
      type: System.IAsyncResult
      description: "En <xref:System.IAsyncResult>som representerar asynkront anrop.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> offset </code> parameter är mindre än 0.       - eller - <code> offset </code> parameter är större än längden på <code> buffer </code>.       - eller - <code> size </code> parameter är mindre än 0.       - eller - <code> size </code> parameter är större än längden på <code> buffer </code> minus värdet för den <code> offset </code> parameter."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggande <xref:System.Net.Sockets.Socket>är stängd.</xref:System.Net.Sockets.Socket>       - eller - ett fel uppstod vid skrivning till nätverket.       - eller - ett fel uppstod vid åtkomst till socket. I avsnittet Anmärkningar för mer information."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> är stängd."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar ett värde som anger om den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> har stöd för läsning."
  remarks: "Om CanRead är `true`, <xref:System.Net.Sockets.NetworkStream>tillåter anrop till den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Ange den lämpliga <xref:System.IO.FileAccess>räknas upp värdet i konstruktorn för att ange läsbarhet och writability i <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> CanRead-egenskap är inställd när den <xref:System.Net.Sockets.NetworkStream>har initierats.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om data som kan läsa från strömmen; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardvärdet är <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar ett värde som anger om strömmen har stöd för sökning. Den här egenskapen stöds inte för närvarande. Den här egenskapen returnerar alltid <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>i samtliga fall som indikerar att <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> kan inte söka efter en specifik plats i dataströmmen."
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Anger om timeout-egenskaper som är användbara för <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Den här egenskapen är tillgänglig eftersom den ärvts från <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>i samtliga fall."
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar ett värde som anger om den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> har stöd för skrivning."
  remarks: "Om CanWrite `true`, <xref:System.Net.Sockets.NetworkStream>tillåter anrop till den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Ange den lämpliga <xref:System.IO.FileAccess>räknas upp värdet i konstruktorn för att ange läsbarhet och writability i <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> CanWrite-egenskap är inställd när den <xref:System.Net.Sockets.NetworkStream>har initierats.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om data kan skrivas till den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardvärdet är <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Stänger den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> efter den angivna tiden så att data skickas."
  remarks: "Close-metoden Frigör både ohanterade och hanterade resurser som är associerade med <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Om den <xref:System.Net.Sockets.NetworkStream>äger den underliggande <xref:System.Net.Sockets.Socket>, den är stängd.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Om en <xref:System.Net.Sockets.NetworkStream>har associerats med en <xref:System.Net.Sockets.TcpClient>Close-metod stänger TCP-anslutning, men inte ta bort den associera <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "En 32-bitars heltal som anger antalet millisekunder att vänta med att skicka alla kvarvarande data innan du stänger."
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> timeout </code> parametern är mindre än -1."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar ett värde som anger om data är tillgängliga på den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> ska läsas."
  remarks: "Använd egenskapen DataAvailable för att avgöra om data är redo att läsas. Om DataAvailable `true`, ett anrop till <xref:System.Net.Sockets.NetworkStream.Read%2A>returnerar omedelbart.</xref:System.Net.Sockets.NetworkStream.Read%2A> Om fjärrvärden stängs av eller stänger anslutningen, kan DataAvailable utlösa en <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om data är tillgängliga på dataströmmen som ska läsas; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> är stängd."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggande <xref:System.Net.Sockets.Socket>är stängd.</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Använd den &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; egenskapen för att hämta den specifika felkoden och Windows Sockets version 2 API felkod dokumentationen i MSDN för en detaljerad beskrivning av felet."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Släpper de ohanterade resurser som används av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> och släpper du de hantera resurserna."
  remarks: "Den här metoden anropas av allmänheten `Dispose` metod och <xref:System.Object.Finalize%2A>metod.</xref:System.Object.Finalize%2A> `Dispose`anropar den skyddade `Dispose(Boolean)` metod med den `disposing` parametern `true`. <xref:System.Object.Finalize%2A>anropar `Dispose` med `disposing` inställd på `false`.</xref:System.Object.Finalize%2A>       När den `disposing` parametern är `true`, den här metoden Frigör alla resurser som innehas av alla hanterade objekt som den här <xref:System.Net.Sockets.NetworkStream>referenser.</xref:System.Net.Sockets.NetworkStream> Den här metoden startar den `Dispose` metod för varje refererade till objekt."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Frisläpp både hanterade och ohanterade resurser. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> att släppa endast resurser som inte hanteras."
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hanterar slutet av en asynkron läsning."
  remarks: "Metoden EndRead har slutförts asynkron läsning som startas i den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       Innan du anropar <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, måste du skapa en metod som implementerar det <xref:System.AsyncCallback>Delegera.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Den här Återanropsmetoden körs i en separat tråd och anropas av systemet efter <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>returnerar.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Återanropsmetoden måste acceptera den <xref:System.IAsyncResult>returnerades från den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden som en parameter.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       I Återanropsmetoden anropa den <xref:System.IAsyncResult.AsyncState%2A>egenskapen för den <xref:System.IAsyncResult>att hämta tillståndet objekt som överförts till den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> Extrahera mottagandet <xref:System.Net.Sockets.NetworkStream>från det här objektet.</xref:System.Net.Sockets.NetworkStream> När du har fått den <xref:System.Net.Sockets.NetworkStream>, anropa EndRead-metoden för att kunna slutföra Läsåtgärden och returnera antalet lästa byte.</xref:System.Net.Sockets.NetworkStream>       EndRead metoden block tills data är tillgängliga. Metoden EndRead läser så mycket data som är tillgängliga för upp till antalet byte som anges i den `size` parameter för den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Om fjärrvärden stängs av i <xref:System.Net.Sockets.Socket>anslutning och alla tillgängliga data har tagits emot, EndRead-metoden har slutförts omedelbart och returnerar noll byte.</xref:System.Net.Sockets.Socket>       Du kan hämta den mottagna data genom att anropa den <xref:System.IAsyncResult.AsyncState%2A>egenskapen för den <xref:System.IAsyncResult>, och extrahera bufferten som ingår i den resulterande tillståndsobjektet.</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      > [!NOTE] > Om du får ett <xref:System.IO.IOException>Kontrollera <xref:System.Exception.InnerException%2A>egenskapen för att avgöra om den orsakades av ett <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> I så fall använder den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>egenskapen för att hämta den specifika felkoden och Windows Sockets version 2 API felkod dokumentationen i MSDN för en detaljerad beskrivning av felet.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "En <xref:System.IAsyncResult>som representerar ett asynkront anrop.</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "Antalet byte som läses från den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggande <xref:System.Net.Sockets.Socket>är stängd.</xref:System.Net.Sockets.Socket>       - eller - ett fel uppstod vid åtkomst till socket. I avsnittet Anmärkningar för mer information."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> är stängd."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hanterar slutet av en asynkron skrivning."
  remarks: "EndWrite har slutförts startas i <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> asynkron send-åtgärden       Innan du anropar <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, måste du skapa en metod som implementerar det <xref:System.AsyncCallback>Delegera.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Den här Återanropsmetoden körs i en separat tråd och anropas av systemet efter <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>returnerar.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Återanropsmetoden måste acceptera den <xref:System.IAsyncResult>returnerades från den <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>metoden som en parameter.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       I Återanropsmetoden anropa den <xref:System.IAsyncResult.AsyncState%2A>egenskapen för den `IAsyncResult` parametern för att hämta <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> När du har fått den <xref:System.Net.Sockets.NetworkStream>, kan du anropa metoden EndWrite för att kunna slutföra send-åtgärden och returnerar antalet byte som skickats.</xref:System.Net.Sockets.NetworkStream>       EndWrite metoden block tills det begärda antalet byte som skickas.      > [!NOTE] > Om du får ett <xref:System.IO.IOException>Kontrollera <xref:System.Exception.InnerException%2A>egenskapen för att avgöra om den orsakades av ett <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> I så fall använder den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>egenskapen för att hämta den specifika felkoden och Windows Sockets version 2 API felkod dokumentationen i MSDN för en detaljerad beskrivning av felet.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Den <xref:System.IAsyncResult>som representerar asynkront anrop.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggande <xref:System.Net.Sockets.Socket>är stängd.</xref:System.Net.Sockets.Socket>       - eller - ett fel inträffade vid skrivning till nätverket.       - eller - ett fel uppstod vid åtkomst till socket. I avsnittet Anmärkningar för mer information."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> är stängd."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Frigör alla resurser som används av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Den här metoden åsidosätter <xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> Programkod bör inte anropa den här metoden. ett objekt <xref:System.Object.Finalize%2A>metoden anropas automatiskt under skräpinsamling, såvida inte slutförande av skräpinsamlingen har inaktiverats av ett anrop till den <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>metoden.</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       Mer information om hur du använder Finalize-metoden finns [Finalize-metoderna och destruktorer](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [Rensa ohanterade resurser](~/add/includes/ajax-current-ext-md.md), och [åsidosätter metoden Slutför](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Rensningar av data från dataströmmen. Den här metoden är reserverad för framtida användning."
  remarks: "Metoden Flush implementerar den <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>metoden, men eftersom <xref:System.Net.Sockets.NetworkStream>är inte buffras den påverkar inte på nätverket dataströmmar.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> Anropar metoden Flush inget undantag genereras."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Rensningar av data från dataströmmen som en asynkron åtgärd."
  remarks: "Åtgärden blockeras inte. Den returnerade <xref:System.Threading.Tasks.Task>objekt slutförs efter att data har tömts från strömmen för den <xref:System.Net.Sockets.NetworkStream>instans.</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "En annullering token som används för att sprida meddelande att åtgärden ska avbrytas."
    return:
      type: System.Threading.Tasks.Task
      description: "Returnerar <xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       Task-objekt som representerar den asynkrona åtgärden."
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar längden på data som är tillgängliga på strömmen. Den här egenskapen stöds inte för närvarande och alltid utlöser <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Längden på data som är tillgängliga på strömmen."
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "All användning av den här egenskapen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar eller anger aktuell position i dataströmmen. Den här egenskapen stöds inte för närvarande och alltid utlöser <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Aktuell position i dataströmmen."
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "All användning av den här egenskapen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Läser data från den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Den här metoden läser data till den `buffer` parametern och returnerar antalet byte som har lästs. Om inga data är tillgängliga för läsning, returnerar Läs-metoden 0. Läs åtgärden läser så mycket data som finns tillgänglig, upp till antalet byte som anges av den `size` parameter. Om fjärrvärden stängs anslutningen, och alla tillgängliga data har tagits emot, metoden Read Slutför omedelbart och returnera noll byte.      > [!NOTE] > Kontrollera om den <xref:System.Net.Sockets.NetworkStream>är läsbart genom att anropa den <xref:System.Net.Sockets.NetworkStream.CanRead%2A>egenskapen.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> Om du försöker läsa från en <xref:System.Net.Sockets.NetworkStream>som kan inte läsas, du får en <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream>      > [!NOTE] > Om du får ett <xref:System.IO.IOException>Kontrollera <xref:System.Exception.InnerException%2A>egenskapen för att avgöra om den orsakades av ett <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> I så fall använder den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>egenskapen för att hämta den specifika felkoden och Windows Sockets version 2 API felkod dokumentationen i MSDN för en detaljerad beskrivning av felet.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "En matris av typen <xref:System.Byte>som plats i minnet för att lagra data läses från den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Platsen i `buffer` ska börja lagra data."
    - id: size
      type: System.Int32
      description: "Antalet byte som ska läsas från den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    return:
      type: System.Int32
      description: "Antalet byte som läses från den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> offset </code> parameter är mindre än 0.       - eller - <code> offset </code> parameter är större än längden på <code> buffer </code>.       - eller - <code> size </code> parameter är mindre än 0.       - eller - <code> size </code> parameter är större än längden på <code> buffer </code> minus värdet för den <code> offset </code> parameter.       - eller - ett fel uppstod vid åtkomst till socket. I avsnittet Anmärkningar för mer information."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggande <xref:System.Net.Sockets.Socket>är stängd.</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> är stängd.       - eller - det finns ett fel vid läsning från nätverket."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar eller anger ett värde som anger om den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> kan läsas."
  remarks: "Du måste vara härledd från den <xref:System.Net.Sockets.NetworkStream>klass för att använda egenskapen läsbar.</xref:System.Net.Sockets.NetworkStream> Om Readable `true`, <xref:System.Net.Sockets.NetworkStream>tillåter anrop till den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Du kan också bestämma om en <xref:System.Net.Sockets.NetworkStream>är läsbart genom att kontrollera offentligt tillgänglig <xref:System.Net.Sockets.NetworkStream.CanRead%2A>egenskap.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       Egenskapen läsbar anges när den <xref:System.Net.Sockets.NetworkStream>har initierats.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>som indikerar att den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> kan vara skrivskyddade, annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardvärdet är <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar eller anger tidsperiod som en Läsåtgärd block som väntar på data."
  remarks: "Om Läsåtgärden inte slutförs inom den tid som anges av egenskapen utlöser Läsåtgärden <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Den här egenskapen påverkar endast synkron läsningar utförs genom att anropa den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> Den här egenskapen påverkar inte asynkron läsning utförs genom att anropa den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "En <xref:System.Int32>som anger hur lång tid i millisekunder som ska förflyta innan en Läsåtgärd misslyckas.</xref:System.Int32> Standardvärdet <xref:System.Threading.Timeout.Infinite>, anger att Läsåtgärden har ingen timeout.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Det angivna värdet är mindre än eller lika med noll och är inte <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Anger den aktuella positionen för dataströmmen till det angivna värdet. Den här metoden stöds inte för närvarande och alltid utlöser <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Den här parametern används inte."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Den här parametern används inte."
    return:
      type: System.Int64
      description: "Position i dataströmmen."
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "All användning av den här egenskapen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Anger längden på dataströmmen. Den här metoden utlöser alltid <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Den här parametern används inte."
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "All användning av den här egenskapen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar den underliggande <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "Klasser som härleds från <xref:System.Net.Sockets.NetworkStream>kan använda den här egenskapen för att få den underliggande <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Använd den underliggande <xref:System.Net.Sockets.Socket>returneras från egenskapen Socket om du behöver åtkomst utanför som som <xref:System.Net.Sockets.NetworkStream>ger.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      > [!NOTE] > Den här egenskapen är bara tillgänglig via den här klassen eller en härledd klass."
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "En <xref:System.Net.Sockets.Socket>som representerar den underliggande nätverksanslutningen.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Skriver data till den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Metoden Write börjar vid den angivna `offset` och skickar `size` byte från innehållet i `buffer` till nätverket. Metoden Write blockerar tills det begärda antalet byte som skickas eller en <xref:System.Net.Sockets.SocketException>genereras.</xref:System.Net.Sockets.SocketException> Om du får en <xref:System.Net.Sockets.SocketException>, använder den <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>egenskapen för att hämta den specifika felkoden och Windows Sockets version 2 API felkod dokumentationen i MSDN för en detaljerad beskrivning av felet.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Kontrollera om den <xref:System.Net.Sockets.NetworkStream>är skrivbar genom att öppna den <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>egenskapen.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> Om du försöker att skriva till en <xref:System.Net.Sockets.NetworkStream>som är inte skrivskyddad, får du ett <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> Om du får ett <xref:System.IO.IOException>Kontrollera <xref:System.Exception.InnerException%2A>egenskapen för att avgöra om den orsakades av ett <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "En matris av typen <xref:System.Byte>som innehåller data att skriva till den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Platsen i `buffer` som du vill starta skrivning av data."
    - id: size
      type: System.Int32
      description: "Antal byte att skriva till den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> offset </code> parameter är mindre än 0.       - eller - <code> offset </code> parameter är större än längden på <code> buffer </code>.       - eller - <code> size </code> parameter är mindre än 0.       - eller - <code> size </code> parameter är större än längden på <code> buffer </code> minus värdet för den <code> offset </code> parameter."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Det uppstod ett fel vid skrivning till nätverket.       - eller - ett fel uppstod vid åtkomst till socket. I avsnittet Anmärkningar för mer information."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> är stängd.       - eller - det gick inte att läsa från nätverket."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar ett värde som anger om den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> är skrivbar."
  remarks: "Du måste vara härledd från den <xref:System.Net.Sockets.NetworkStream>klass för att använda egenskapen är skrivbar.</xref:System.Net.Sockets.NetworkStream> Om Writeable `true`, <xref:System.Net.Sockets.NetworkStream>tillåter anrop till den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Du kan också bestämma om en <xref:System.Net.Sockets.NetworkStream>är skrivbar genom att kontrollera offentligt tillgänglig <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>egenskap.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       Egenskapen Writeable anges när den <xref:System.Net.Sockets.NetworkStream>har initierats.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Om data kan skrivas till dataströmmen; Annars <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardvärdet är <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hämtar eller anger tidsperiod som en skrivåtgärd åtgärden block som väntar på data."
  remarks: "Om Skrivåtgärden inte slutförs inom den tid som anges av egenskapen utlöser Skrivåtgärden <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Den här egenskapen påverkar endast synkron skrivåtgärder som utförs genom att anropa den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> Den här egenskapen påverkar inte asynkrona skrivningar utförs genom att anropa den <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "En <xref:System.Int32>som anger hur lång tid i millisekunder som ska förflyta innan en skrivåtgärd misslyckas.</xref:System.Int32> Standardvärdet <xref:System.Threading.Timeout.Infinite>, anger att åtgärden har ingen timeout.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Det angivna värdet är mindre än eller lika med noll och är inte <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
